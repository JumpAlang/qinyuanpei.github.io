---
title: 罗马数字与阿拉伯数字的相互转换
categories:
  - 编程语言
tags:
  - 数学
  - 算法
  - 数字
abbrlink: 4158690468
date: 2018-04-30 10:59:46
---
&emsp;&emsp;最近遇到一道非常有趣的题目，题目大意如下：有一个富翁在银河系里做生意，而银河系使用的是罗马数字，所以他需要一个精明能干的助手，帮助他完成罗马数字与阿拉伯数字的相互转换，题目在这个背景下衍生出交易场景，我们需要帮助他计算出相关商品的价格。对于这道题目，如果剥离开这个题目本身的交易场景，这道题目本质上就是一个纯粹的算法问题。说来惭愧，博主当时并未能快速地解决这个问题，事后通过研读别人的文章始能有所领悟。所以，今天想在这篇文章里，同大家一起来讨论下这个问题。今天，全世界都在使用0到9这10个阿拉伯数字，比阿拉伯数字早2000年的罗马数字。为什么没有流传下来为后世所用呢？我觉得这是一个非常有意思的问题，数学同计算机学科间那种千丝万缕的联系、技术演进过程中若有若无的某种必然性......这些都是令我觉得非常有意思的地方。那么，一起来看看这个问题可好？

# 罗马数字起源

&emsp;&emsp;罗马数字，顾名思义，就是古罗马人使用的数字系统。在罗马数字中，共有7个基本数字，即I、V、X、L、C、D、M，它们分别表示1、5、10、50、100、500、1000。可以注意到，在这套数字系统中，0不被视作是一个整数。据说，曾经有一位罗马学者不顾教皇的反对，执意将与0相关的知识以及0在运算中的作用向民众传播，因此被教皇囚禁并投入监狱，理由是0是一个邪物，破坏了神圣的数。同样罗马数字无法表示小数(**注：罗马数字有分数的表示方法，可仅仅能表示1/12的整数倍**)，因此罗马数字常常用来表示纪年，在欧洲国家的古书籍、建筑和钟表中，我们都可以见到罗马数字的身影。我们熟悉的元素周期表，同样采用了罗马数字来表示元素所在的"族"。需要说明的是，罗马数字是一种计数规则，而非计算规则，这意味者罗马数字是没有进位和权重的概念的，所以一般罗马数字只用以计数而不用以演算。

&emsp;&emsp;具体来讲，罗马数字的基本规则有以下4条：
* 重复次数：**一个数字重复多少次，所表示的数字就是这个罗马数字的多少倍；一个罗马数字最多重复三次。**这条规则该怎么理解呢？第一点，I、II、III分别表示1、2、3；第二点，4必须被表示为IV，而不是IIII。关于4的表示方法，在历史上一直存在争议，一种观点认为IIII这种写法占用书写空间，IV可以达到简化书写的作用；而一种观点则认为IV有亵渎神灵朱庇特、含不敬侮辱之意。
* 左减原则：**当一个较小的数字被放在一个较大数字的左边时，所表示的数字等于这个大数减去这个小数，且左边最多只能放一个较小的数字**。联系第一条原则，IV表示的实际上是V-I，所以这个数值表示4；同理，9为了满足第一条原则，必须被表示成IX。
* 右加原则：**当一个较小的数字被放在一个较大数字的右边时，所表示的数字等于这个大数加上这个小数，且右边最多只能放一个较小的数字**。这一条原则和第二条原则相对应，例如11会被表示成XI、21会被表示为XXI，以此类推。
* 搭配原则：**I只能被放在V和X的左边；X只能被放在L和C的左边；C只能被放在D和M的左边；V、L、D不能被放在左边**。这一条可以看作对是第二条的总结，所以没有什么可说的。

&emsp;&emsp;好了，通过这个这些规则我们就可以组合出不同的数字，

# 数字转换实现

## 阿拉伯转罗马
```
public static string ConvertToRoman(int number)
        {
            var output = new StringBuilder();
            var digits = digitMap.OrderByDescending(e => e.Key).ToList();

            for (int i = 0; i < digits.Count && number > 0; i++)
            {
                if (number < digits[i].Key) continue;
                while (number >= digits[i].Key)
                {
                    number -= digits[i].Key;
                    output.Append(digits[i].Value);
                }
            }

            return output.ToString();
        }
```
## 罗马转阿拉伯
```
public static int ConvertToNumber(string romanNumber)
        {
            var number = 0;
            var length = romanNumber.Length;
            var digits = digitMap
                .Where(e => e.Value.Length < 2)
                .OrderBy(e => e.Key)
                .ToDictionary(e => e.Value, e => e.Key);

            for (int i = 0; i < length - 1; i++)
            {
                //前面 n-1 位数字通过左右比较决定正负 & 第 n 位数字必然为正
                if ((digits[romanNumber[i].ToString()] > digits[romanNumber[i + 1].ToString()]) || i + 1 >= length)
                {
                    number += digits[romanNumber[i].ToString()];
                }
                else
                {
                    number -= digits[romanNumber[i].ToString()];
                }
            }



            number += digits[romanNumber[romanNumber.Length - 1].ToString()];
            return number;
        }
```
# 为什么会溢出

# 选择阿拉伯数字

# 本文小结