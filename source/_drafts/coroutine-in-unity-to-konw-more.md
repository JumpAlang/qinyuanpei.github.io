---
title: 深入了解Unity3D中的协程
categories:
  - Unity3D
tags:
  - Unity3D
  - 'C#'
  - Coroutine
abbrlink: 1992609322
date: 2016-01-14 14:28:52
---

&emsp;&emsp;Unity3D 中的协程是一个迷人而独特的存在，协程的通常定义是指一种可以分步执行的代码结构，这种代码结构在满足某种条件如 yield return 时将被挂起，直到条件被满足时会被再度唤醒继续运行下面的代码。所以简单的来描述协程，协程是一种延迟执行的机制，可以控制代码在特定的时机运行。如果说你已经厌倦了在 Update()方法 里根据时间来判断是否需要执行某个操作，我相信协程可以帮助你改善你的代码，假如你能够正确、合理地使用协程的话。从这个角度来说，协程这种机制存在的意义就是为了解决延迟执行的问题，所以当你试图解决这些问题的时候，深入了解协程将是件有趣而且必要的事情。
<!--more-->

#协程到底是什么东西？
&emsp;&emsp;协程到底是什么东西？当面对这个问题的时候，可能每个人心中都会有不同的答案，就像一千个读者就有一千个哈姆雷特一样。莎士比亚借企图复仇的丹麦王子哈姆雷特说出了他对生活的思考：
>生存还是毁灭？这是一个问题，究竟哪样更高贵，去忍受那狂暴的命运无情的摧残还是挺身去反抗那无边的烦恼

##协程是多线程吗？
&emsp;&emsp;首先我们来考虑第一个问题，协程是多线程吗？这个问题我们可以明确的说不是，可能因为**MonoBehaviour 运行在主线程中**这个观点深入人心的缘故，所以大家就会下意识地认为协程应该是异步执行的，所以协程应该就是 Unity3D 中多线程的一种替代方案。这个观点其实是错误的， Unity3D 能不能支持多线程？当然可以，唯一的限制就是我们不能在多线程中调用 Unity3D 的 API ，所以从这个角度来说，协程是 Unity3D 中多线程的替代方案这种说法自然就不攻自破了。

&emsp;&emsp;而从协程自身的角度来讲，协程本质上是一种状态机，它只有两种状态，挂起和继续执行，它和我们平时写的有限状态机从本质上来说并没有什么不同，它这个状态机优雅的地方在于它使用了 C# 中迭代器即 IEnumerator 的概念，而 IEnumerator  接口有两个方法 Current 和 MoveNext()  ，只有当 MoveNext() 返回  true 时才可以访问 Current，否则会报错。迭代器方法运行到 yield return 语句时，会返回一个表达式并保留当前在代码中的位置。当下次调用迭代器函数时执行从该位置重新启动。所以综合起来，  Unity3D 中的协程在每帧做的工作就是：调用迭代器 MoveNext() 方法，如果返回 true  ，就从当前位置继续往下执行。因此协程实际上和 MonoBehaviour 中的 Update() 方法一样，都是运行在主线程当中，而且 Unity3D 会在每一帧都去检查这个状态机是否满足条件。一个 Unity3D 协程的可能的实现代码如下：
```
public class YieldInstruction
{
    internal IEnumerator routine;
    internal YieldInstruction(){}

    internal bool MoveNext()
    {
        var yieldInstruction = routine.Current as YieldInstruction;
        if(yieldInstruction != null){
            if(yieldInstruction.MoveNext()){
                return true;
            }else if(routine.MoveNext()){
                return true;
            }else{
                return false;
            }
        }else if (routine.MoveNext()){
            return true;
        }else{
            return false;
        }
    }
}
```

##协程的执行顺序
&emsp;&emsp;既然协程和 MonoBehaviour 中的 Update() 方法一样，都是运行在主线程当中的，那么由此就引出和协程相关的一个问题，即协程的执行顺序。从下面 MonoBehaviour 函数运行图可以看出协程是在 LateUpdate() 方法以后执行的，所以我们可以将协程理解为 MonoBehaviour 每一帧都执行且在LateUpdate() 方法以后执行的一个函数，这个函数可以分步执行，每次遇到 yield return 语句就挂起，直到满足指定条件以后被再度唤醒继续执行接下来的代码。虽然协程的启动和停止都是由 MonoBehaviour 来负责维护的，可是这里比较纠结的一个地方是 MonoBehaviour 的 enable 属性对协程是没有影响的，而 GameObject 的 SetActive() 方法则可以影响协程的运行，所以虽然Unity3D没有提供停止指定协程的方法（其实是有这样的方法的，可是条件非常苛刻，即必须使用字符串来表示一个协程方法，这意味着我们将使用反射），但是可以通过 SetActive() 方法来控制协程的启动和暂停。Unity3D中的 yield return 语句可以支持的类型有：
* null : 直到下一次协程执行的时候执行协程。
* WaitForEndOfFrame() : 等待直到所有的摄像机和GUI被渲染完成后，在该帧显示在屏幕之前执行协程。
* WaitForSeconds() : 在给定秒数后执行协程，需要注意它受到 Time.timeScale 这个属性值的影响。
* WaitForFixedUpdate() : 直到在下一个 FixedUpdate() 方法执行时执行协程。
* WWW : 直到一个WWW请求完成后执行协程。
* Coroutine : 直到一个协程完成后执行协程。

#使用协程到底好不好？
&emsp;&emsp;使用协程到底好不好，这应该是一个仁者见仁的问题。从博主个人的角度来说，我更喜欢传统的异步编程的方法，因为在异步编程中我们只需要编写相关的回调函数，就可以直接在回调函数中处理相应的逻辑，而不必考虑延迟执行的问题，可是游戏编程和传统编程的不同之处就在于游戏是一个循环结构，在循环结构中实现延迟执行，就需要在每一帧里都去判断，所以Unity3D里的协程在博主心目中让人又爱又恨的一种机制，喜欢它是因为它在实现上的优雅，讨厌是因为它在使用上的混乱。虽然Unity3D中的协程让每个接触它的人，在没有了解到实质的情况下就已经学会如何使用协程这种用法，可是我个人感觉协程写出来的代码非常丑陋，因为我们常常需要在各种 if 语句中使用 yield return 这种奇怪的语法。所以我对使用协程的态度是，在深入了解协程以后再去尝试使用它，除非在必须使用协程的场合，通常情况下我更喜欢自己来实现一个时间管理器，这样可以确保我做些和协程类似的事情，如延迟数秒后执行某个操作等。因为协程在Unity3D中和资源加载、网络请求这些功能紧密关联，所以从我的角度来说，非常多的使用Unity3D的朋友除了熟悉Unity3D的API以外，基本不会去尝试了解引擎以外的东西，一个游戏引擎流行是好事，可是因为流行就让让我们对事物的探索停留在表面，这是非常可怕的事情。

#协程设计中存在哪些不足？
&emsp;&emsp;虽然协程是一种优雅的设计，可是协程从我的使用体验上来说，我觉得协程在某些方面是存在非常多的不足的。比如协程不支持泛型，所以假如我们想在 MonoBehaviour 以外使用协程，就会变成一件奢侈而困难的事情；其次，协程支持的返回类型相当有限，假如我们希望在动画播放外以后执行一个协程，或着是希望在一个事件结束以后执行一个协程，都会变得非常困难，所以从这个角度来看，目前 Unity3D 中的协程支持的功能有限，协程并非是颠扑不破的真理；最后，我们最为关心的是协程中没有异常处理，虽然我个人非常讨厌在代码中写异常处理的代码，可是具备异常处理的代码会有更好的鲁棒性，协程中 yield return 语句可以返回的类型中有一个 WWW 类型，该类型表示一个Web请求，我们可以error属性来获取错误信息，可是在普通的协程代码中就没有这样的待遇了，这意味着我们不能在协程中使用 try...catch 这样的结构，这固然是 C# 中迭代器即 IEnumerator 不允许使用异常处理的语法要求使然，可这恰恰说明了协程在设计上存在的不足。Unity3D 中编写 Shader 的痛苦就在于不能调试只能看，使用协程的痛苦大概只有 Shader能够体会了吧！