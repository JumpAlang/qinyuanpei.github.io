title: .NET平台下如何让C#程序延迟执行
date: 2016-11-16 21:20:48
categories: [编程语言]
tags: [延迟,编程,设计]
---
&emsp;&emsp;或许我们的人生注定就是一场没有终点的赛程，从学生时代我们就习惯了为学习成绩而竞争，而等到我们走出校门步入社会，我们开始逐渐习惯在职场中为工作、为薪资、为得到领导的信任而竞争，甚至在我们处在二十多岁一无所有这样的年龄的时候，我们要在成千上万的同龄人中间去竞争，我们要去竞争女朋友、房子和车子。而等到我们为人父母的时候，我们或许会沮丧地发现，这样的循环会再次在我们的孩子身上发生，不同的是竞争或许会比现在更为激烈。在乎输赢或许是这个世界永恒的真理，就像达尔文在《物种起源》里提到的“进化论”一样，大自然优胜劣汰的丛林法则从小就教会了我们去努力奔跑，因为每一个人都害怕落后和失败，所以我们每天都去努力去工作和生活，更本质的意义或许是我们想真正掌控生活。可是就在大家都在都在拼命往前追赶的时候，有一个好事者表示想要加入大家的队伍，可前提是大家必须停下来等他开始跑了以后再继续跑。那么，如果是你，你会选择停下吗？

<!--more-->
# 天之苍苍，其正色耶

&emsp;&emsp;我为什么要讲这样一个故事呢？我们的世界实际上由各种各样的规则组成，而这些我们每天接触到的、习以为常的规则，我们习惯将其称为常识。从目前人类所知的局限性上来讲，我们在短时间内或许无法解释清楚它为什么要这样，如同“上帝说，要有光，于是便有了光”，哲学家们用一句意味深长的“存在即合理”巧妙地解释了这一切。或许我们时常怀疑它们的正确性，亦或者我们认为它们的正确性不容置疑。在这一刻，如果你认为一件事情是合理的，就应该使用论证的方式来证明它，可事实是面对用户未曾经过大脑的需求的时候，我们一次次地选择了妥协，就像《皇帝的新装》里揭穿谎言的那个孩子一样，有些事情我们每个人都清楚地知道它是不对的，可我们每个人都选择了沉默不言，这是因为我们长大了变得成熟了吗？如人饮水，冷暖自知，这个世界奇妙的地方或许就在于，它不是由0和1这样非此即彼的东西构成的吧！我们这里来考虑一个问题，如何让C#程序延迟执行？

&emsp;&emsp;我们以这篇文章开头的故事为例，实际的情况是我们的程序由各种连续的过程组成，通常情况下，这些过程会在上一个过程执行完后立即执行，假设现在因为某种原因（假设的意思就是说，这是真实存在的情况），我们需要在某一个过程中让程序“停”下来，直到程序得到响应以后继续执行。注意到这里的“停”是含引号的，这表明程序在这里依然是在继续执行的，不过是因为某种原因被延迟执行了，所以至此我们终于引出了这篇文章的主题，即如何让C#程序延迟执行。延迟，我认为是一个有趣的话题，我们在Unity中可以让一个帧动画或者粒子动画延迟播放，而我们在做网络通信的时候，则需要考虑如何去减少网络延迟对通信的影响，甚至有时候为了解决问题我们会选择让程序故意“阻塞”一段时间，那么我们或许就会想要去了解，在不同场景下的延迟都是为了解决什么问题，以及这些延迟在C#中都是如何实现的，其核心原理是什么，常见的解决方案有哪些等等，所以在这篇文章中我会尝试去解决这些问题。

# C#中实现延迟的方案有哪些？
&emsp;&emsp;在提出C#中实现延迟的各种方案以前，我们可以先来考虑一个基本的问题，即什么是延迟？实现延迟的核心原理是什么？ 首先，延迟是指让程序等待一段时间后再继续执行这样一个过程，延迟的本质其实是精准地控制代码被执行的时间。从人类角度来讲，人类希望在这段时间内什么事情都不要做。可是从计算机的角度来看，这段时间内系统调度算法会对资源进行重新分配。这是因为进入多核时代以后，在硬件条件相对成熟的情况下(请参考摩尔定律)，对一个大型任务进行合理拆分，然后交给多个CPU来并行处理，其执行效率通常会比单核时代下的程序高出很多，这正是我们现在会大量使用多线程编程的原因所在，所以我认为延迟在这里应该有两种理解，即单线程条件下的的**阻塞延迟**和多线程条件下的**调度延迟**。前者在延迟期间因为是阻塞的，所以在等待的过程中什么事情都做不了除了等待；后者则可以利用系统调度算法，在延迟期间利用这段空闲时间去做其它的事情。关于这两种延迟，我们来一起通过下面这些例子来加强理解。

## 经典的While循环

```
void DoDelay(double delay)
{
    TimeSpan timeSpan = TimeSpan.FromMilliseconds(delay);
    DateTime timeNow = DateTime.Now;
    while (DateTime.Now - timeNow <= timeSpan)
    {
        //TODO:
    }
}

```
&emsp;&emsp;这种通过while循环来实现等待的思路，应该是最简单的一种延迟方案啦！因为这是最符合我们人类直觉的一种方法，其基本思想是设计一个计时器，当计时器内的时间累积到某一个值(delay)时，表示截止到目前所花费的时间长短。如果大家有过开发Unity游戏的经历的话，一定会记得我们在处理“每隔一段时间去执行某个过程”这类问题时，通常会采用在Update()方法内累积时间的这种做法，其实这就是计时器在游戏开发中的一种应用，而游戏通常都是有一个主循环的，所以在每一帧被调用的时候(指Update()方法），获取到的当前时间即为从循环开始到目前的时间长度。

&emsp;&emsp;可是这种方法的弊端非常明显，当程序中存在大量的时间处理的时候，其代码维护的难度会非常大，所以后来我们推荐使用协程(Coroutine)来处理这类问题。同样地，在这里这种方法存在的问题是，如果我们在循环体中让程序等待的话，那么程序的确是在等待了，可是在等待的这个过程中程序实际上是“阻塞”的，注意我这里说的阻塞并非是指界面发生阻塞，而是指在这个过程中，程序就仅仅是在等待，即除了等待以外我们做不了任何事情，可见系统资源在这个过程中是被随意浪费的，所以这种方式我认为可以帮助我去理解这个问题，但是它不应该被推荐作为一种实际使用中的方案。

## Thread.Sleep()

&emsp;&emsp;作为一个对多线程编程天生恐惧的人，我感觉我对多线程的理解总是云里雾里。这就像我觉得我能够理解二进制是一件困难的事情，可有一天忽然有人告诉我原来还有十六进制。这种状况直到我接触到目前的工作后稍稍得到改善，甚至我写这篇博客都是为了帮助我理解多线程的这些概念。我们工作中会使用某种内部工具，因为这个工具本身存在严重缺陷，所以我们常常会使用各种丑陋的方法来试图掩盖这些缺陷。或许这些东西对解决问题是有意义的，可是对技术提升而言是毫无意义的，所以我觉得程序员一定要使用优秀的工具，尤其是可以帮助你显著提高工作效率的那些工具，如果你能掌握这些工具的原理就更好了。而我在使用这个内部工具的过程中，最大的收获居然是Thread.Sleep()这个方法。

```
void DoDelay()
{     
    Thread thread = new Thread(() =>
    {
        Stopwatch watch = new Stopwatch();
        watch.Start();
        for (int i = 0; i < 10; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Loop {0} times in {1}", (i + 1), watch.Elapsed);
        }
    });

    thread.Start();
}
```
&emsp;&emsp;这里我们注意到我们定义了一个简单的线程，而在这个线程方法的循环体中，我们每次都会执行一次Thread.Sleep()方法，而根据这段代码的执行结果，我们可以非常清楚看到，上一次输出和本次输出的时间间隔，基本维持在1秒即1000毫秒左右，所以我们就理解了Thread.Sleep()方法，在这里的作用是将当前线程挂起一段时间。而在当前线程挂起的这段时间内，操作系统会对CPU资源进行重新分配，根据分配策略的不同，对UNIX系统其分配策略为时间片算法，而Windows系统其分配策略为抢占式。

&emsp;&emsp;前者将所有进程排入一个队列，所有进程按照系统分配的时间片依次执行，如果在该时间片内进程没有执行完，则系统会剥夺其对CPU的使用权，将CPU的使用权转交给下一个进程，同时未执行完的进程会被再次排入队列，等待下一次轮到它再执行。反之，如果在该时间片内进程执行完毕，则系统会自动将CPU使用权转交给下一个进程。而后者会对进程按照优先级进行排序，当系统将CPU使用权转交给下一个进程的时候，所有的进程都会来争夺这个机会，并且争夺到这个机会的进程会一直占用CPU。除非它主动放弃使用权否则没有人可以让它放弃，那么这样就会引发两个问题。

&emsp;&emsp;怎样的两个问题呢？第一，我们这里使用Thread.Sleep(1000)这个方法来让当前线程挂起1秒钟，那么1秒钟以后当前线程一定能够重新拥有CPU资源吗？我认为答案是不一定的，因为我们知道Windows系统是一个抢占式的分配策略，所以我们是无法保证在1秒后我们的线程会被重新唤醒，因为如果此时有一个优先级更高的线程启动，那么它很有可能会抢走本来应该属于我们的CPU资源，那么优先级高的线程是不是一定会在这场竞争中胜出呢？这同样不一定，因为Windows系统中的相关进程需要一直占用CPU，所以它会有更高的概率获得这场竞争的胜利，就像希拉里和普朗克的总统竞选一样，你总是无法预料最终的结局会是什么，这正是我们在输出结果中发现它的时间在1秒附近波动的原因。

&emsp;&emsp;第二，我们会使用Thread.Sleep(0)来尝试唤醒当前线程，那么当前线程会被立即唤醒吗？答案同样是不一定的，这就像我们抛硬币的时候知道它有正反两面两种结果，可我们从来都没有办法确定它最终会是哪一面一样。我们的生命中在会遇见哪些人，其实在冥冥之中都已经被安排好。为何我们依然如此充满期待呢，或许就是因为它变化莫测难以捉摸。这样看起来好像Windows与生俱来地就明白这样一件事情：如果你想收获什么东西就努力去争取，因为我们从小就知道这个世界是不公平的。生命是追逐自由，还是追逐规则，刺客信条用这样一种简单的阴谋论，成功戏说了千百年来人类所创造的历史。

## Task.Delay()
&emsp;&emsp;我们知道.NET中的多线程编程经历了从Thread到ThreadPool再到Task的演化过程。首先Thread即为线程，需要用户来负责调度，它就像一个马拉松长跑运动员，所以这种方式需要用户去维护整个赛程的生命周期，而且维护线程状态甚至比创建一个线程更重要，因为在上文中我们提到Windows是一个抢占式的多任务操作系统，所以我们必须保证我们创建的线程是安全和可靠的。而ThreadPool是在Thread基础上的一个线程池，其目的是为了减少频繁创建线程的开销，并且调度算法会根据程序的执行模式进行自适应调整，所以这种方式无需用户来调度线程。当我们需要执行频繁、短期的任务的时候可以优先考虑使用ThreadPool。Task则是基于Thread和ThreadPool的更为上层的一种封装，从机制来讲，Task是利用CPU多核机制将一个大任务不断分解为小任务来执行，而这些小任务具体由哪个线程来处理则完全取决于操作系统的调度。如果你想自己控制由哪一个线程来处理，要么自己创建Thread来执行代码，要么自己定义Task的Scheduling。一个典型的由Task实现的Delay方法，代码如下：

```
Task DoDelay(double delay)
{
    var tcs = new TaskCompletionSource<bool>();
    var timer = new System.Timers.Timer();
    timer.Elapsed += (sender, args) =>{
        tcs.TrySetResult(true);
    };
    timer.Interval = delay;
    timer.AutoReset = false;
    timer.Start();
    return tcs.Task;
}
```
&emsp;&emsp;这段代码来自[StackOverflow]()，而从这里我们可以了解到，实际上Task.Delay()这个静态方法底层依然是基于定时器Timer来实现的（当然微软实际的代码实现应该会比这个更为复杂，因为这仅仅代表我们的一种猜测)，这里的TaskCompletionSource的作用是手动控制任务工作流，我们可以将其理解为一个从外部控制任务执行细节的方法，显然在这里当计时器到达时间间隔以后，我们尝试告诉任务调度层当前任务执行完毕，而计时器主要的作用是控制时间间隔。所以，有时候我们之所以会迷惑，是因为我们无法认清自我，而体现在代码的设计中就是，我们常常搞不清楚到底应该用计时器还是Thread.Sleep()，虽然它们都能达到我们的目的，可是生活不是每天都在面临选择吗？对成人世界来讲，当对错变得不再重要的时候，权衡利弊就是在0和1中间找到一个合适的点吧！

## Timer

&emsp;&emsp;其实我们最早理解延迟就是从计时器开始的，我们理解的延迟无非是在计时器工作的这段时间内：(1)单线程下的**阻塞延迟**，即什么都不做；(2)多线程下的**调度延迟**，即利用这段时间做其它的事情。在如今这样一个多核时代，多线程编程之所以能够提高应用程序的性能，就是因为它能够充分利用多个核心去协调不同的任务。那么我们下面就来详细说说.NET中的计时器吧！据我所知，在.NET中有以下四种不同的计时器：

* System.Threading.Timer：采用回调函数的最简单的多线程计时器，基于线程池实现，是所有多线程计时器的核心。它提供了以指定时间间隔执行指定方法的机制，该类无法被继承。下面是一个简单的代码示例，需要说明的是它本身没有提供停止计时的方法，唯一让它停下来的方法就是调用Dispose()方法，并且其回调函数不在UI线程上被执行：
```
var timer = new System.Threading.Timer((state) =>
{
    Console.WriteLine("这里是回调函数");
});

timer.Change(1000, -1);
```
* System.Timers.Timer：采用事件驱动的多线程计时器，由第一种计时器封装而来，通过Elapsed绑定事件，通过Start()方法启动计时，通过Stop()方法停止计时，通过AutoReset属性来设置计时器是否可以重复计时。它由UI线程完成创建，但是它和第一种Timer一样，都不在UI线程上执行，准确地来讲，它是由ThreadPool中的线程来执行的，所以当你尝试在Elapsed事件中访问UI控件将会引发异常，常规解决方案是借助委托来实现，在这里它提供了一个SynchronizingObject属性可以让UI控件在单线程环境下使用。关于它的使用可以参考Task.Delay()部分。
* System.Windows.Forms.Timer：WinForm计时器，单线程计时器，运行在UI线程，线程安全，可以直接更新UI画面。因为其基于Windows消息循环机制实现，因此实际执行效率并不是特别高，适合相对轻量级的任务。 
* System.Windows.Threading.DispatcherTimer：WPF计时器，单线程计时器，运行在UI线程，线程安全，可以直接更新UI画面。因为其基于Windows消息循环机制实现，因此实际执行效率并不是特别高，适合相对轻量级的任务。 

## 异步模型

## 延迟加载


# 小结