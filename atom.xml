<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Payne&#39;s Blog</title>
  
  <subtitle>人生到处知何似，应似飞鸿踏雪泥</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qinyuanpei.github.io/"/>
  <updated>2018-06-04T06:11:50.624Z</updated>
  <id>http://qinyuanpei.github.io/</id>
  
  <author>
    <name>Payne</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于电影《暗杀》背后的故事和想法</title>
    <link href="http://qinyuanpei.github.io/posts/2462008667/"/>
    <id>http://qinyuanpei.github.io/posts/2462008667/</id>
    <published>2018-06-01T09:33:25.000Z</published>
    <updated>2018-06-04T06:11:50.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-szIhAaLJ" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="569213279" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><p>&emsp;&emsp;最近看过了由全智贤主演的电影《暗杀》，虽然说这是一部我们早已熟稔的抗战题材电影，可是在全女神颜值和演技的诱惑下，我终于还是花了点时间来看这部电影。或许是因为我们见识过了太多的<strong>“抗日神剧”</strong>，所以在面对这样一部电影的时候，我们难免带着某种不屑的眼光去审视它。可是当你看完了这部电影，突然间兴奋到难以自制，不由地惊呼一声：想不到韩国拍这种主旋律电影都能这么好看。我想，这是一种由视角转换所引起的代入感，我曾经看过日本拍摄的甲午海战，日本在明治维新以后，积极地向西方学习先进技术，从天皇到官员，都能从俸禄中省出钱来发展海军事业，相比之下，以天朝上国自诩的大清帝国则是李鸿章一人在支撑着岌岌可危的朝廷。同样地，通过《浪客剑心》同名电影，你会意识到，在明治维新这场变革背后，可能会有无数个像志志雄这样的政治牺牲品。这些都是因为视角发生变化而引起的变化，同样地，在这部电影中，它讲述了韩、朝两国人记忆中的抗日战争，这场我们曾经经历过的抗日战争，在韩国人眼中到底是什么样子的，这或许对我们看待历史会有所启示。</p><h1 id="一明一灭，两条暗杀线"><a href="#一明一灭，两条暗杀线" class="headerlink" title="一明一灭，两条暗杀线"></a>一明一灭，两条暗杀线</h1><p>&emsp;&emsp;电影讲述了19世纪30年代，以安沃允(<strong>全智贤</strong>饰)为首的暗杀三人组，奉命刺杀日军驻朝鲜司令官及本国卖国贼的故事。故事发生在京城(即韩国首尔)和上海，时任韩国临时政府局务局局长的廉锡镇(<strong>李政宰</strong>饰)，在早年刺杀日军大将失败以后，暗地里早已投靠日本人，此时更将暗杀三人组的消息泄露给日方。一时间，暗杀三人组的刺杀行动和处决叛徒廉锡镇刺杀行动，构成了一明一暗两条线索，呼应了本片片名<strong>“暗杀”</strong>，而廉锡镇更是找来赏金猎人<strong>“夏威夷手枪”</strong>(<strong>河内宇</strong>饰)，意图阻挠暗杀三人组的刺杀行动，可以说，整个故事脉络就像这个刺杀行动一样简单直接，因此其故事悬念就落在了<strong>刺客的刺杀计划如何落实</strong>以及<strong>反派的阻挠方案将如何开展</strong>。所以，这个电影吸引人的地方就在于，即使你知道反派最终一定没有好下场，可不到全女神放下枪的那一刻，你总是不肯放下心来。因为即使是看双方斗智斗勇，在颜值与演技都在线的情况下，这一切依然显得赏心悦目。全女神在片中几乎承担了所有的动作戏份，可即便如此，李政宰在片中饰演的反派廉锡镇，风头一度不亚于全女神，这些我们后面再详细说。</p><p>&emsp;&emsp;电影中前期出现的场景都是在上海，可能有朋友会疑惑：为什么一部韩国拍的电影里会出现上海。这就要首先说说这段历史，当时韩国的临时政府是设在上海的，目的是方便金九、金元凤这样的革命志士开展救亡图存活动，因为当时的韩国(在南、北朝鲜没有分裂以前，指整个朝鲜半岛）早已笼罩在日军的军事统治阴影下。历史上，这段时期长达35年之久。日本是什么时候占领朝鲜的呢？没错，就是我们熟悉的中日甲午战争。当时北洋水师正是在运送陆军抵达朝鲜后的返航途中，与日本海军发生近代历史上第一次大规模铁甲舰海战。这场战争的结果我们都知道，北洋水师几乎全军覆没，清政府更是同日本签订了丧权辱国的马关条约。日本占领朝鲜半岛后，曾对当地人进行了惨无人道的屠杀，正是从那个时候起，朝鲜开始笼罩在日军的统治阴影之下，而流亡国外的临时政府，不得不寄居在上海的法租界，继续开展抗日活动。影片中的金九和金元凤，在历史上都可以找到记录。上海虹口爆炸事件，其实就是这部电影的历史原型，影片中二金的合作促成了三人暗杀组的成立，故事由此开始。</p><h1 id="这个反派有点帅哦"><a href="#这个反派有点帅哦" class="headerlink" title="这个反派有点帅哦"></a>这个反派有点帅哦</h1><p>&emsp;&emsp;李政宰饰演的廉锡镇，在电影一开始是以革命志士的形象出现的，他刺杀日军大将的任务失败，直接导致他在被捕后遭受严酷的刑罚。与此同时，间接导致了女主安沃允的母亲被亲日派父亲康寅国派人杀死，安沃允与双胞胎姐姐美津子分离，直至多年后，来自东北抗日武装的安沃允，和自幼在日占区长大的美津子，终于在一个屋檐下相认，可转眼间，姐姐就被卖国贼康寅国给杀死了，电影中全女神亲眼目睹姐姐死亡的那一幕真的是令人心碎。可偏偏是这样一个人，亲手挑选了这三名暗杀组的成员，亲手将刺杀行动的情报泄露给日方人员，尤其是他从衣兜里取出假信件投入火堆，伪造出信件被毁的假象这一幕。面对金九的怀疑，在明知手枪里没有子弹的情况下“以死明志”。对昔日的同志毫不手软，两个被金九派去刺杀他的同志，均被他重伤甚至杀死。面对曾经刺杀过的日军大将，他可以厚颜无耻地邀功请赏，并接受日军授予的爵位。可恰恰是这样一个人，在喝醉酒以后，诉说朝鲜各种武装力量各自为政的现实，忏悔把暗杀三人组送去送死。在严刑拷打面前，他做了叛徒，一如暗杀组成员干革命要给钱，这些或许没有那么伟光正，可它是那么的真实。</p><h1 id="演技与颜值同时在线的全女神"><a href="#演技与颜值同时在线的全女神" class="headerlink" title="演技与颜值同时在线的全女神"></a>演技与颜值同时在线的全女神</h1><p>&emsp;&emsp;全女神饰演的安沃允，是一个来自东北抗日武装的狙击手，一出场就瞬间狙杀四名敌人，身手当真是是不凡啊，更不必说端着汤姆生冲锋枪窜房顶跨屋脊，在负伤的情况下趴在疾驶的卡车引擎盖上。据说全女神电影中的动作戏都没有使用替身，一个明明可以靠颜值的人，尚且可以如此努力地去拼搏，那么身为普通人的你我，又有什么理由不努力呢？野蛮女友时期的全女神，或许看起来只是漂亮而已，而现在看来则是实力派。可她同样是一个憧憬着喝咖啡谈恋爱的少女，是一个看到姐姐洁白的嫁会衣泣不成声的妹妹，是一个面对亲生父亲无论如何都下不去手的狙击手。在假扮姐姐美津子参加婚礼以前，她做好了最坏的打算，就像她脑海中浮现过的画面一样，在敌人乱枪扫射下，献血染红了她洁白的婚纱……这或许是“夏威夷手枪”脑补的画面？这里有一个细节，“夏威夷手枪”将全女神送到医院以后，“夏威夷手枪”讨论起他对于暗杀行动的看法，全女神说了这样一段话，大意是“杀掉日军司令和汉奸康寅国，到底能不能让国家独立，这一点没有人会知道，但她必须要让人们知道，她们一直在战斗”……</p><p>&emsp;&emsp;这一刻，这个娇弱而坚强的女性形象就立起来了。全女神在本片中分饰两角，即姐姐美津子和妹妹安沃允，不过这种差异基本都是通过眼神表现出来的，姐姐身上有那种从小生活安逸的娇气，而妹妹身上有那种内敛冷静的帅气。战争从来都是残酷的，康寅国为了依附日本人，将美津子误认为安若允并杀死。在我看来，即便没有认错，以康寅国的为人，知道女儿和独立军有关联，他还是会这样做，因为女儿的幸福他完全不在乎，和日本人联姻无非是为了拉拢日本人。正如全女神所言，他用那双杀死了母亲的手，杀死了自己的女儿。人类的情感有时候就是这样诡异，一个对自己从来没有养育之恩的父亲，对方叛国投敌助纣为虐，即使两者间唯一的联系，是那可有可无的血缘关系，可最终还是需要“夏威夷手枪”，这个曾经是“杀父联盟”一员的人，替她开出这一枪。</p><h1 id="一个超有力量感的故事结尾"><a href="#一个超有力量感的故事结尾" class="headerlink" title="一个超有力量感的故事结尾"></a>一个超有力量感的故事结尾</h1><p>&emsp;&emsp;故事从挟持人质这里开始，就突然变得敷衍起来，可能这里就需要感情戏来作为某种过渡，假如两个人真的去了米拉波，这就真的变成了爱情电影，可这部电影不就是，一部打着主旋律幌子的动作电影吗？这种类型电影为了增加娱乐性，是需要幽默和爱情的。真正将影片推向高潮的是结尾出的审判，证人在开庭前就被廉锡镇派人杀死，于是没有可以再证明，廉锡镇曾经投敌叛国、出卖同志的罪行。这个世界上永远有大量的无知的人，他们选择用暴力来面对一名“韩奸”，可当廉锡镇脱下衣服，义正言辞地讲述自己“支持”独立运动的事迹时，这些人突然开始宣布这名“韩奸”无罪，这是否说明大众都是愚蠢的，可正是这些人的想法，在左右着我们每一个人，这和那些努力制造“焦虑”的人没有区别，我们不愿意相信真相，宁愿相信自己早已固化地思维，或者是人云亦云，没有自己独立的判断，这实在是件可怕的事情。法官失落地宣布证据不足、廉锡镇无罪释放的时候，大概内心会有某种无可奈何或者是不甘心。</p><p>&emsp;&emsp;这让我想起Unnatural里高濑这个案件，因为没有办法证明对方杀人，而关键的信息又被久部泄露出去，所以，这个案件一度到了要修改鉴定报告的程度，这和身为法医的三橙心中的使命感不相符合，关键时候，是神仓所长坚持递交了原始的鉴定报告。当我们想要制裁一个人的时候，能不能依然客观地去证明对方有罪，不冤枉任何一个人固然值得赞赏，可为了让对方伏法而采用非正义的手段是否是正确的呢？如果身为法医的三橙，用修改鉴定报告的方式，给高濑这个罪犯定刑的话，我相信，我们所有人都会失望，因为她不愿意输给非正常死亡，不愿意正常的人被乱入非正常的事件，采用非正常的方法去伤害别人或者是自己。相比中堂使用逼供的方式查找真相，她更希望中堂医生以一名法医学者的身份去战斗。自然，故事的结尾，所谓善恶有报，16年前的暗杀任务，终于在韩国光复以后，有安沃允和明宇重新执行，结尾处被乱枪打死的廉锡镇，在被问到为什么要出卖同志时，说了一句“我没想到会解放啊”，一句听起来像开玩笑的话，其实说出了战争年代人们的无奈，如果没有战争，或许这些事情就真的不会发生，可当战争机器被发动时，又有谁会想到这些呢？被卷入战争里人们没有选择，而发动战争的人从来不考虑以后。</p><h1 id="写在战争结束以后"><a href="#写在战争结束以后" class="headerlink" title="写在战争结束以后"></a>写在战争结束以后</h1><p>&emsp;&emsp;旷日持久的战争终于结束了，当画面定格到全女神那张近乎素颜的脸上时，她突然想起那些曾经最为亲切的面孔，想起“炸弹专家”黄德三，想起“速射炮”邱尚沃，想起酒馆老板娘……战争带给我们的是永远的伤痛，今天我们对于日本这个国家，可能有时候还会充满抵触情绪，但我想说的是，这场战争并没有结束，金九认为日本人已经投降，不再需要可依靠捐助维持，以光明正大地回到国内搞建设，可事实上像廉锡镇这样投日派，并没有完全得到清算，所以，金九在回国后不久就被韩国激进分子刺杀，廉锡镇所说的独立运动派系之争，在历史上是真实存在着的，金九就是被卷入到这场政治斗争中的牺牲品，所以，金元凤最终选择了朝鲜，而这种派系之争，更是加剧了整个朝鲜半岛的分裂，在这片土地上，曾经一起战斗过的兄弟、朋友，最终变成兵戎相向的敌人。</p><p>&emsp;&emsp;可这真的是和平吗？战争真的结束了吗？被38线分割开的这两个国家，一个通过韩剧、料理和科技为世界所知，一个更像是改革开放初期的中国，不知道还说神秘还是落后。何况，这条38线是停战线，并非某种和平的象征，而直至今天，这种刺杀的阴影一直笼罩在韩国政坛上，韩国现任总统朴槿惠的父亲和母亲先后都死于刺杀，所以，即使战争结束了，就能换回和平吗？就能抚平人们心中的伤痛吗？朝鲜与韩国，也许在我们有生之年里，都难以看到他们真正地握手言和，就像苏联解体以后不会再联合在一起，欧盟并非想象中的牢不可破，爱尔兰和北爱尔兰原本就是一家，印度和巴基斯坦是殖民战争的遗留问题……战争，带来的坏处，永远比好处要多。我们向往铸剑为犁的和平生活，可战争结束以后，是否真的能带来和平，人心中的伤痛需要多久可以愈合，人与人的相争逐利之心需要多久可以平息。</p><p>&emsp;&emsp;2018年的儿童节，同往年不同，因为许嵩为炮火中的叙利亚孩子们，创作了一首新歌《大千世界》，这首歌以2017年4月15日叙利亚炸弹袭击事件为背景，呼唤爱与和平，控诉那些肆意发动战争，而将无辜孩童卷入战火的人们。大千世界里的大人们，不要忘了你们曾经都是孩子，当人们都在通过晒娃这种方式度过儿童节时，你是否会想到在世界的某个地方，有人在穿着捐助的衣服和玩具的同时，更是被迫享受着温柔的暴力，我们从小给小孩子的玩具枪，是否有一天会真的变成荷枪实弹呢？我们在盛世之年，我们在贫富之间，我们在虚实交错路口，不断找寻，任何形式的相遇。愿大千世界，再无战争，再无暴力，愿每个深爱的人，都能被温柔对待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="和平" scheme="http://qinyuanpei.github.io/tags/%E5%92%8C%E5%B9%B3/"/>
    
      <category term="全智贤" scheme="http://qinyuanpei.github.io/tags/%E5%85%A8%E6%99%BA%E8%B4%A4/"/>
    
  </entry>
  
  <entry>
    <title>爱情像一场霍乱</title>
    <link href="http://qinyuanpei.github.io/posts/3782208845/"/>
    <id>http://qinyuanpei.github.io/posts/3782208845/</id>
    <published>2018-05-22T09:05:34.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-lqwhAiOX" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="536622304" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><p>&emsp;&emsp;距离读完马尔克斯的《霍乱时期的爱情》这本书，差不多已经有一个月左右的时间啦。相比小说中错综复杂的人物关系，更加让人印象深刻的或许是“百年孤独”式的开头。不论是多年后面对行刑队的布恩迪亚上校，还是拍打鹦鹉结果从梯子上摔下来的乌尔比诺医生。在这一刻，因为人物的过去与现在层叠出的这种时空感，或许就是马尔克斯想要去描绘的魔幻现实主义。最近看了由小说改编的同名电影，感觉对这部小说的印象更为具体化，小说的时间跨度将近半个世纪，是选择乌尔比诺和费尔米纳这样稳定的婚姻关系，还是选择阿里萨和费尔米纳这样偏执的爱情故事。我想，这是一个值得去思考的问题吧。</p><p>&emsp;&emsp;当乌尔比诺从梯子上摔下来即将离开人世的时候，他拼尽最后一口气对费尔米纳说：“只有上帝才知道我有多爱你”。单单从这句话来看，他们两个人或许是相爱的。可明明不久前，两个人还在为了一块肥皂的事情而争吵。现在大家对出轨这个问题看得特别重，重要到不要说是肉体出轨，连精神出轨都是不能被原谅的。从去年至今，网络上各种出轨的舆论消息层出不穷，好像爱情越来越不值得期待。可你看乌尔比诺和费尔米纳的婚姻是什么样的呢？乌尔比诺在妻子外出期间出轨了一名黑人女子，虽然他选择主动向妻子承认出轨，及时回归家庭，可在我们这些外人看来，这样的婚姻是含有杂质的婚姻。从妻子费尔米纳的角度，她结婚以前是不吃茄子的，而结婚以后则适应了茄子，你可以说两个人在一起，一定会有一方选择妥协。可在一个动辄讲三观、讲兴趣、讲地位的年代，你是否会觉得两个人合适呢？</p><p>&emsp;&emsp;合适，是一个特别巧妙的词汇，巧妙之处在于它真正可以做到“以不变应万变”。乌尔比诺夫妇的婚姻，或许是大多数人的真实写照。两个人第一次见面，源于费尔米纳的一场疾病。当时外面正流行着霍乱疫病，费尔米纳因为怀疑被感染了霍乱不得不寻找医生治疗，恰好乌尔比诺正从巴黎旅行回来。在医学技术不发达的年代，医生是没有听诊器的，所以乌尔比诺必须贴着费尔米纳裸露的胸部听心跳。书作和电影中都详细地描绘了这个过程，两个青年男女在这种情况下发生了身体上的接触，费尔米纳更是被对方身上的男性气概所吸引。可这算是爱情吗？我更愿意相信，这是一种原始的欲望冲动，可你说这两个人间没有爱情，估计所有人都会反对，谁让我们都喜欢用海枯石烂表示爱情的忠贞，这两个人在一起生活50年，甚至作者都表示：一对恩爱的夫妻最重要的不是幸福，而是稳定的关系。</p><p>&emsp;&emsp;所以，不管你愿不愿意承认，爱情最终都会部分地转化为亲情，爱情本身是有瑕疵的、有缺陷的，争吵不可避免，犯错不可避免。诚然，我们都希望对方忠诚的对待自己，可人归根到底是一种对自我忠诚的动物，你说你不能接受对方变心，可人、时间和空间无时无刻不在发生着变化，喜欢或者不喜欢，不过是某一瞬间的状态，你必须相信，爱情本来就不完美、充满瑕疵，可这就是真实的爱情的样子啊，人们会记得你婚礼上的海誓山盟，唯独不会记得你每天柴米油盐的平平淡淡；人们会给他们愿意看到的表面现象去点赞，唯独不会关注你是不是真正的快乐。爱情里有人不厌其烦地寻找真爱，有人沉溺在回忆里不敢再触碰爱情，对我来说，这两种选择我都表示尊重，因为爱情本来就有它真实的样子。</p><p>&emsp;&emsp;我不知道，还会不会有人为了别人而苦等51年9个月零4天，一个人究竟有多大的勇气和执念，才能从一个朝气蓬勃的青年变成一个白发苍苍的老人。金庸先生的名篇《射雕英雄传》里，神算子瑛姑因为失去爱子而一夜白头，我想，这其中有对段皇爷见死不救的怨恨，有对周伯通求而不得的执念。可对阿里萨而言，从他遇见费尔米纳那天开始，他的生命就仿佛注定是属于她的，他坚持给她写信，在楼下为她拉小提琴，在长椅上刻下她的名字，甚至是喝花露水、吃玫瑰花。如果说爱情像一场霍乱，应该会没有怀疑，因为阿里萨的确像是生了一场霍乱，不然怎么会疯狂地爱直至偏执甚至有些荒唐。我完全可以理解阿里萨的举动，因为年轻时的我们都曾做出过类似的举动。我并不反对这样的爱情，可当你回头来看这两个人的爱情的时候，费尔米纳对阿里萨这个人几乎一无所知，除了知道对方的职业是报务员。</p><p>&emsp;&emsp;电影中费尔米纳甚至给阿里萨回了信，可就如同费尔米纳所言，“他们两个人之间只有虚幻，爱情蒙蔽了彼此的双眼”，大概所有一见钟情的人都没能考虑一个问题，那就是你真的了解对方这个人吗？非常不幸的是，即使亲近如父母、妻子和丈夫这样的关系，一个人也永远不可能了解另外一个人。一个人究竟要爱得多卑微，才会心心念念地等着对方的丈夫死掉，甚至怕对方比丈夫先死掉。假如阿里萨只是这样痴痴等待50年的话，我们最多只是替他感到惋惜而已，可偏偏阿里萨为了“报复”费尔米纳，缓解被她伤害的心，开始一次又一次地疯狂纵欲，在肉体的狂欢中不断强化精神层面上对费尔米纳的爱，据他自己记载，他和寡妇、少妇甚至少女都发生过关系，可当他终于等来费尔米纳的时候，他声称自己是一个处男。</p><p>&emsp;&emsp;人常常复杂到让你我怀疑人生，而阿里萨则是一个复杂到，让你觉得他还有点可怜的人。他视其它女性的肉体如无物，唯独将费尔米纳推上女神的圣坛。更微妙的是，费尔米纳居然是喜欢过阿里萨这个人的。她不过是在乌尔比诺和阿里萨间选择了更好的一个而已，可阿里萨这种病态的爱在我看来是极为自私的，因为无论两个人多么地爱彼此，一旦出现这种肉体的出轨，就意味着永远无法挽回。虽然费尔米纳选择嫁给了乌尔比诺，可假如有一个人在别人的身体上出轨无数次，在你的丈夫逝世以后告诉你，他等这一天已经等了51年9个月零4天，我不知道你会作何感想。我没有任何的封建思想残留，我尊重女性在丈夫死后改嫁的自由，可选择这样一个充满“缺点”的人，我觉得还是需要去认真想一想的。</p><p>&emsp;&emsp;两个人如果真心相爱，即便是满头白发的蹒跚老者，我认为结婚都是没有问题的，可当两个70多岁的老人坦诚相见时，当阿里萨看到费尔米纳干瘪下垂的胸部时，当各自看到对方充满皱纹和赘肉的身体时，我真的想知道，这50多年的等待真的值吗？或许是值的的，就像这两个人喜欢的都是有点幻想成分的对方一样，我向往永远靠精神慰藉彼此的帕拉图之恋，也不排斥男欢女爱的肉体之欢，可无论哪一种都必须建立在真实的现实中，一个虚幻的爱慕者，一个你并不真正了解的人，当幻想被打破的一瞬间，或许就是爱情破碎的时候，所以，我希望我们对待感情更慎重些，即使没有人爱你，学会自爱未尝不可。我们的生命原本就短暂，何苦要将这生命浪费在别人身上，况且我们有时候我们就像费尔米纳一样，分不清到底是爱还是孤独，人在经历枯燥和乏味以后是会变的，会变得对事物充满新鲜感，即使是曾经不喜欢的东西。</p><p>&emsp;&emsp;从某种角度而言，阿里萨是成功的，因为他用一生的时间得到了喜欢的女人。可我时常觉得人生有比这更重要的事情，就像你小时候看到喜欢的东西，却发现自己买不起的时候，你会怎么样做呢？我想大多数人都会选择不要了或者是等以后有机会再买。可人就是这样奇怪的动物，明明以前非常非常喜欢，可突然有一天发现咋再喜欢不起来。为什么我们对这件事情可以坦然接受，唯独在面对感情的时候常常无法自拔呢？你当初有没有得到这样一件喜欢的东西，或许会影响你在未来的人生轨迹，可在大多数情况下，我们的生命实在泛不起多少涟漪。有人说，人生下来的时候，结局就早已注定，我们唯一能做的事情，就是努力去填补和丰富这五六十年的时间。这样说来，人生实在是没有什么事情非做不可的，如果有，那只有一件事情，那就是努力地活下去。</p><p>&emsp;&emsp;《Unnatural》里中堂系一直对恋人的死无法释怀，整整八年时间一直都在调查恋人的死亡原因，直到真相被查明，得到恋人父亲的原谅。我不是说，人生不可以有执念，我只是希望大家明白，执念只会让你太关注结果而忽略过程，而我们的生命是需要一天天去度过的。就像阿里萨终于得到了费尔米纳，可两个70多岁的老人，在这个世界上还有多少时间可以挥霍呢？我倒情愿日子过得稍微慢一些，用一辈子的时间去了解对方，我们一直所希望看到的，不就是被人理解和认同吗？如果永远一个可以同你交流灵魂的人，那么就努力学习一个人去生活，人生没有那么多必须做的事情，只有你愿不愿意去做的事情。起风了，就当努力生存。活着不好吗？我实在不愿意再看到罗密欧与朱丽叶这样的悲剧，虽然我们都曾歌颂过这样的故事，可只要活着就会有新的机会啊。</p><p>&emsp;&emsp;有时候想想我们父母这一代人，几乎在毫无准备的情况下，被动地步入了婚姻的殿堂。时隔多年以后，或消融在柴米油盐的平淡里，或交织在子女亲情的羁绊中，或穿行在流水光阴的得失间……直至爱情彻底消亡最终变成亲情，像一滴松胶油慢慢变成一颗精美的琥珀。有人说，婚姻是爱情的坟墓，甚至结过婚的人会觉得婚姻非常无趣。那么，罗曼蒂克是否一定会消亡？如果是，是不是婚姻里有没有爱情都可以，因为总有一天它会枯竭，人生里充满太多无可奈何的事情，单单是爱情这一件事情就可以写满整个历史，爱情里有像童话一般美好的故事，同样有像悲剧一般哀伤的故事。</p><p>&emsp;&emsp;或许是我们这一代独生子女们，在接触到更广阔的网络世界后，极大地影响了我们对这个世界的认知，以至于我们觉得自己就是活得太明白了。可如果要这样稀里糊涂地度过余生中的五六十年，每个人突然间又不甘心接受这残酷的命运。当我发现，我要远离父母生活，甚至完全能力能力和精力照顾他们的时候，我很容易地想到我的未来，是不是会和他们一样。有人说，婚姻是为了找到一个人陪你一起往前走，可我们这些独生子女们，早就习惯了一个人去生活，生命里总是充满着无尽的变故，或许她曾经特别特别喜欢你，可突然有一天她就不再喜欢你了；或许你们曾经是特别特别友好的朋友，可突然有一天对方就突然离你远去；或许你们朝夕相处亲密无间，可到最后突然发现根本不了解彼此……</p><p>&emsp;&emsp;人明明都是会变的，可偏偏总爱把希望寄托在变化的事物上面。在一个周围一切都在变化的世界里，追求一成不变毫无疑问是贪心的，我们能追求的只有稳定，可难免会问一个不理智的问题：稳定可以理解为爱吗？这正是乌尔比诺和费尔米纳两个人的感情生活留给我们的谜题。年少时或许会憧憬阿里萨这样因爱成痴的故事，可正如村上春树所说，“哪里会有人喜欢孤独，不过是不喜欢失望罢了”。如果爱情是一场霍乱，我希望每个生病的人，都能尽早地从这场疾病中治愈。“起风了，当努力生存”，就像石原里美饰演的三橙说过的，“有时间绝望还不如去吃点好吃的呢”，比起找到心爱的人，学会如何爱自己不是更重要吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://qinyuanpei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="阅读" scheme="http://qinyuanpei.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="马尔克斯" scheme="http://qinyuanpei.github.io/tags/%E9%A9%AC%E5%B0%94%E5%85%8B%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用Jexus实现ASP.NET在Linux平台下的部署</title>
    <link href="http://qinyuanpei.github.io/posts/815861661/"/>
    <id>http://qinyuanpei.github.io/posts/815861661/</id>
    <published>2018-05-20T14:00:03.000Z</published>
    <updated>2018-06-04T06:11:50.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;Hello，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。今天想写一点关于Linux部署ASP.NET相关的话题，为什么突然想写这个话题呢？因为就在几天前，我被我所认识的一位前辈深深地鄙视了一番，原因是我依然在使用一个落后的IoC框架——Unity，在如今已然是公元2018年的今天。我突然想到，距离.NET Core 2.0发布已经有一段时间，而.NET Core 3.0的roadmap已经开始提上日程，可我好像还没来得及认真地去对待这个现状。我一直在关注跨平台和跨语言的技术，就像我在大学里的时候就开始接触Linux一样，未来我们要面对的是种类繁多的终端平台，从PC时代到移动互联网，再到VR、AR、IoT和AI，有太多太多的事情在悄然发生着变化。偶尔我的内心会泛起焦虑和迷茫，可在时光蹉跎直至褪色以前，我或许只是变回了曾经的自己。既然要如同涅槃一般重新开始，为什么不首先重新拾起曾经关注的领域呢？所以，在这今天这篇文章里，你将看到：<strong>如何使用Jexus实现ASP.NET在Linux平台下的部署</strong>。</p><h1 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h1><p>&emsp;&emsp;我们项目组在开发这样一种服务，它可以通过收集招聘网站的简历来提取相关信息，而这些信息将作为训练集供AI算法使用。考虑到Python在AI领域的优势，我们决定采用Python来开发自然语言处理相关的业务，而简历的收集则是通过.NET中的Web Service暴露给前端。整个开发相对顺利，可是在部署环节出现了问题。因为项目组以往的的项目都是部署在Linux Server上，所以在部署Web Service的问题上产生了分歧，负责运维的同事不愿意为这一个项目而单独配置一台Windows Server。这里需要说明的是，采用.NET来开发Web Service的一个重要原因是，这些简历中存在大量Word文档(.doc/.docx)，因此不得不采用Office提供的COM组件来支持文档的解析，虽然后来证明的确是这些COM组件拖了跨平台的后腿。所以，在这个时候，我们面临着两种选择，第一种方案是采用Windows Server来部署，我们的运维同事表示不开心；第二种方案是采用Linux Server来部署。我们知道.NET跨平台的一个关键技术是Mono，可Mono的问题是它的基础类库不大健全，相信微软收购Mono以后这个问题能够得到解决。目前官方主推的跨平台技术是.NET Core，考虑到迁移到.NET Core版本的成本，我们最终没有选择这个方案。事实上，即使采用.NET Core进行开发，最终我们的部署依然需要依赖<a href="https://www.jexus.org/" target="_blank" rel="noopener">Jexus</a>。综合考虑这些因素，我们决定采用<a href="https://www.jexus.org/" target="_blank" rel="noopener">Jexus</a>来将ASP.NET项目部署到Linux平台。</p><h1 id="关于Jexus"><a href="#关于Jexus" class="headerlink" title="关于Jexus"></a>关于Jexus</h1><p>&emsp;&emsp;Jexus是由<a href="http://www.cnblogs.com/yunei" target="_blank" rel="noopener">宇内流云</a>开发的一款Linux平台上的高性能Web服务器，它是一个可以免费使用、不开源的项目，最大的特色是可以支持ASP.NET、ASP.NET Core、PHP。通俗地来讲，我们可以认为它是Linux平台上的IIS，这并不为过，因为你可以注意到<a href="https://www.jexusmanager.com/en/latest/" target="_blank" rel="noopener">Jexus Manager</a>这个项目，它可以同时支持Jexus，IIS 和 IIS Express三种服务器的管理，并提供了各个平台下一致的使用体验，而Linux平台则主要是针对Jexus。Jexus提供了不亚于商用服务器的众多特性，比如多站点支持、使用应用程序池来调度管理工作进程、具有良好的稳定性和容错能力、支持 HTTPS 和 WebSockets、支持 FastCGI 协议和 OWIN 标准。除此以外，它同时支持 URL 重写、反向代理、压缩传输、入侵检测等重要功能。Jexus底层采用Linux中的epoll机制来处理网站请求，所以会比通常使用libuv实现的技术拥有更高的性能。作为一款跨平台软件，Jexus支持主流的Linux发行版本。目前，国内外已经有大量的网站采用Jexus作为它的服务器，我们可以在Jexus的官网上找到这些<a href="https://www.jexus.org/Examples.htm" target="_blank" rel="noopener">案例</a>。虽然微软官方正在全力推广.NET Core，但对于那些需要维护的旧项目而言，迁移到全新的.NET Core平台着实是个不小的挑战，而且目前支持.NET Core版本的类库并不丰富，虽然最终的趋势一定是.NET Core替代Mono，但对于Mono而言，在.NET宣布开源以后，从.NET Framework中吸收的基础类库，极大的改善了Mono基础类库不完善的状况，而Mono针对CLR的实现、C#编译器的实现、AOT环境等等特性，或许可以为.NET跨平台提供借鉴，这是一个相互促进的过程。在新时代到来以前，我们暂时需要使用Jexus来过渡。</p><h1 id="Hello-Linux"><a href="#Hello-Linux" class="headerlink" title="Hello Linux"></a>Hello Linux</h1><p>&emsp;&emsp;OK，下面我们来体验一下Jexus在Linux平台上的效果，这里我们以ASP.NET MVC4为例，我们直接通过Visual Studio创建一个项目即可，这里我们需要的是这个项目发布以后的所有文件。总之，这些文件需要通过某种方式放到Linux平台上，大家自己去想办法就好啦，这个不再说多余的话。</p><h2 id="安装Jexus"><a href="#安装Jexus" class="headerlink" title="安装Jexus"></a>安装Jexus</h2><p>&emsp;&emsp;Jexus安装起来是非常简单的，这里博主使用的是Elementary OS，基于Ubuntu14.0的衍生版本。在终端下执行如下命令：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http<span class="variable">s:</span>//jexus.org/release/x64/install.<span class="keyword">sh</span>|sudo <span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p><p>你没有看错，真的只需要一行命令。事实上，Jexus分为两个版本，即通用版和独立版。其差别是通用版不含Mono运行时，独立版含有Mono运行时。官方建议使用独立版，如果有朋友想尝试安装通用版，请在终端下执行如下命令：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:<span class="regexp">//</span>jexus.org<span class="regexp">/release/i</span>nstall|sudo sh</span><br></pre></td></tr></table></figure></p><p>无论采用哪一种方式安装，当你看到终端中显示：Jexus已经被成功安装到系统，就表示Jexus安装成功了。</p><h2 id="配置Jexus"><a href="#配置Jexus" class="headerlink" title="配置Jexus"></a>配置Jexus</h2><p>&emsp;&emsp;Jexus部署到网站，需要两个东西，一个是网站内容(废话)，一个是网站配置。假定我们这里将这两个东西打包在一起，压缩包的名字为app.tar。为什么这里选择了.tar格式的压缩文件呢？因为在Linux平台下这个格式更好用些，我们熟悉的.zip格式，可能会需要我们安装相应的扩展。此时，我们可以使用如下脚本来部署网站：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xf app.tar</span><br><span class="line">sudo mv  -f <span class="selector-class">.aspnetconf</span> usr/jexus/siteconf/aspnetconf</span><br><span class="line">sudo mv ./aspnet /var/www</span><br></pre></td></tr></table></figure></p><p>OK，现在来解释下这个脚本，这里我们需要部署一个名为“aspnet”的网站，所以，网站的内容被放置在“aspnet”这个目录里。该网站对应一个作用于Jexus的配置文件，配置文件的名字为aspnetconf。首先，我们将“aspnetconf”这个配置文件移动到了“usr/jexus/siteconf/”目录下，这是Jexus指定的配置路径，即<strong>每一个站点都有一个配置文件，且该配置文件被放置在“usr/jexus/siteconf/”目录下</strong>。然后，我们将“aspnet”这个文件夹移动到了“/var/www”目录下，这是Jexus指定的网站目录，即<strong>每一个站点都有一个文件夹，文件夹的名字可以理解为网站的名字</strong>。默认情况下，Jexus会在www目录里创建一个名为default的文件夹，即默认有一个名为default的站点，不过经过博主核实，最新版(v5.8.3)中是没有default站点。同理，Jexus会siteconf目录里创建一个名为default的配置文件。我们通常以这个配置文件为参照来编写我们自己的配置文件，例如下面是aspnetconf中的内容：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port</span>=<span class="number">4000</span>                  </span><br><span class="line"><span class="attr">root</span>=/ /var/www/aspnet          </span><br><span class="line"><span class="attr">hosts</span>=  </span><br><span class="line"><span class="attr">indexs</span>= </span><br><span class="line"><span class="attr">aspnet_exts</span>=</span><br></pre></td></tr></table></figure></p><p>其中，</p><ul><li>port表示Jexus Web服务器监听的端口(必填）</li><li>root表示网站虚拟目录与其对应的物理目录，中间使用空格分开(必填）</li><li>hosts表示网站域名(建议填写)，可以使用泛域名如<em>.yourdomain.com或者填写</em>表示默认网站，一个端口有且只有一个默认网站，选填</li><li>indexs表示网站首页文件名，如index.html、index.aspx等，多个文件名使用英文逗号分开，选填</li><li>aspnet_exts表示ASP.NET扩展名，不建议填写。如要填写，多个扩展名(不含.)使用英文逗号分开。</li></ul><p>最简单的配置只需要port和root即可，更多的配置项可以参考官方文档。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>&emsp;&emsp;Jexus的常用命令简单到只有3个，start、restart、stop。命令的基本格式为：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/jexus/jws start <span class="string">[站点名(可选，不指定时表示所有)]</span></span><br><span class="line">sudo /usr/jexus/jws restart <span class="string">[站点名(可选，不指定时表示所有)]</span></span><br><span class="line">sudo /usr/jexus/jws stop <span class="string">[站点名(可选，不指定时表示所有)]</span></span><br></pre></td></tr></table></figure></p><p>在这个例子里，我们执行如下命令来启动aspnet这个站点：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="regexp">/usr/</span>jexus<span class="regexp">/jws start aspnet</span></span><br></pre></td></tr></table></figure></p><p>当终端中返回OK时，就表示启动成功啦，此时，我们打开浏览器，输入<a href="http://localhost:4000就可以看到如下画面(这里的端口号为4000)：" target="_blank" rel="noopener">http://localhost:4000就可以看到如下画面(这里的端口号为4000)：</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Blog_Jexus_01.jpg" alt="运行在Linux上的ASP.NET" title="">                </div>                <div class="image-caption">运行在Linux上的ASP.NET</div>            </figure><br>你就说，这算不算惊喜。我们还可以输入<a href="http://localhost:4000/info来验证Jexus是否配置正确，当Jexus被正确配置以后，你就会看到一个显示着“Welcome" target="_blank" rel="noopener">http://localhost:4000/info来验证Jexus是否配置正确，当Jexus被正确配置以后，你就会看到一个显示着“Welcome</a> to Jexus”的页面。嗯嗯，好像是和Nginx挺像的哈！</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker+"></a>Docker+</h1><p>&emsp;&emsp;接下来，让我们考虑将这些Linux上的工作转移到Docker中来做，因为借助Docker的容器技术，它可以为我们提供一个足以自给自足的环境。通过这个环境编译测试通过的镜像可以批量地部署到生产环境中。如果你不想在每一台Linux Server上都覆盖本文的流程，那么Docker将是提高你部署效率的不二选择，而且从认知完整性的角度来看待Docker，你就会发现它和Jekins、TravisCI、VSTS工具一样，都可以非常完美地被接入到持续集成(CI)的流程里去，譬如我们项目组采用的是Jekins + Gitlib + Docker的方案，所以，如果你想要选择一个最适合你的持续集成(CI)方案，无论如何，Docker都是需要去了解的一个知识。关于Docker的背景知识大家可以自己去了解，这里我们通过编写Dockerfile来完成网站镜像的构建：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=<span class="string">"qinyuanpei@163.com"</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Prepare Environment</span></span></span><br><span class="line"><span class="bash">RUN sudo apt-get update </span></span><br><span class="line"><span class="bash">RUN sudo apt-get install -y</span></span><br><span class="line"><span class="bash">RUN sudo apt-get install -y curl</span></span><br><span class="line"><span class="bash">RUN sudo apt-get install -y wget</span></span><br><span class="line"><span class="bash">RUN sudo curl -sSL https://jexus.org/release/x64/install.sh|sudo sh</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Deploy Website</span></span></span><br><span class="line"><span class="bash">ADD dest/ /</span></span><br><span class="line"><span class="bash">RUN sudo mv -f aspnetconf /usr/jexus/siteconf/aspnetconf</span></span><br><span class="line"><span class="bash">RUN sudo mkdir -p /var/www</span></span><br><span class="line"><span class="bash">RUN sudo mv ./aspnet /var/www</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Start Jexus</span></span></span><br><span class="line"><span class="bash">EXPOSE 4000</span></span><br><span class="line"><span class="bash">WORKDIR /usr/jexus</span></span><br><span class="line"><span class="bash">CMD sudo ./jws start aspnet</span></span><br></pre></td></tr></table></figure></p><p>如果你熟悉Linux下的命令的话，你就会知道apt-get、curl、wget这些命令的含义，真正需要的解释的是ADD，它表示的是，将Dockerfile同级目录下的dest目录添加到Docker环境中，接下来的命令我们同样非常熟悉，因为这和Linux下操作是完全一样的。不过，这里的确有些坑需要踩，在博主构建镜像的过程中，发现容器环境和虚拟机环境还是有本质不同的，这里的mv命令在Docker下有时候会引发“hard link”的问题，从Stackoverflow上好像并没有找到太有价值的答案，总之，这个问题非常的玄学。接下来，我们会将Docker容器的4000端口暴露出来，为什么是4000端口呢？因为这个网站的配置中指向了4000端口，这一点在上文中我们已经提及。而入口处的命令，显然是启动Jexus服务，这个不再解释。</p><p>这里，我们通过如下命令来构建一个镜像版本：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t jexus-aspnet:<span class="built_in">v1</span>.<span class="number">0</span> .</span><br></pre></td></tr></table></figure></p><p>假如这个镜像被成功构建出来，我们就可以使用这个镜像来启动网站啦。如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Blog_Jexus_02.jpg" alt="使用Docker创建网站镜像" title="">                </div>                <div class="image-caption">使用Docker创建网站镜像</div>            </figure><br>具体地，我们可以使用docke image命令来管理所有的docker镜像。这里我们启动网站：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">-p</span> 4050<span class="selector-pseudo">:4000</span> <span class="selector-tag">-t</span> <span class="selector-tag">jexus-aspnet</span><span class="selector-pseudo">:v1.0</span></span><br></pre></td></tr></table></figure></p><p>这里，我们将Docker容器的4000端口映射到主机的4050端口，当我们在浏览器中输入：<a href="http://localhost:4050，就可以得到和Linux下一样的结果。不过，在写作这篇博客时，博主使用的是Windows下的Docker，如果大家遇到相关问题，欢迎在博客评论区留言。" target="_blank" rel="noopener">http://localhost:4050，就可以得到和Linux下一样的结果。不过，在写作这篇博客时，博主使用的是Windows下的Docker，如果大家遇到相关问题，欢迎在博客评论区留言。</a></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文从一个实际工作的场景切入，分析和阐述了如何使用Jexus实现ASP.NET项目在Linux下的部署。为了简化这篇文章的写作，我们使用了一个ASP.NET MVC4的示例项目，真实的项目通常会有数据库，所以情况会比本文所介绍的流程更为复杂，可这让我们看到了一种可能性不是吗？通过查阅相关资料，博主发现ASP.NET Core的部署不需要Jexus，它只需要一个dotnet run命令即可。然后，作为一次体验Docker的过程，我们通过编写Dockerfile的方式让Jexus和Docker发生了某种奇妙的关联。作为本文的一个延伸，我们需要考虑网站服务停止后可以自动重启，这就是所谓的守护进程机制啦，感兴趣的朋友可以继续深入研究，Jexus提供了大量的优秀特性，这篇文章中所看到的不过是冰山一角。最终，我们的项目还是没有使用Jexus，这其中有对Jexus性能的不信任，有因为COM组件而做出的妥协，有对Mono非官方方案的鄙夷……可以说，技术选型是一个受到多种因素制约的问题，谁拥有了话语权，就可以左右技术选型的走向，这是否又印证了，人类并非如自己所标榜的那般理性和正义？好了，以上就是这篇文章的全部内容啦，今天是5月20日，如果没有人对你说“我爱你”，请记得对自己说“我爱你”，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://qinyuanpei.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Jexus" scheme="http://qinyuanpei.github.io/tags/Jexus/"/>
    
      <category term="Docker" scheme="http://qinyuanpei.github.io/tags/Docker/"/>
    
      <category term="Linux" scheme="http://qinyuanpei.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用SonarCloud为.NET/.NET Core项目集成静态检查</title>
    <link href="http://qinyuanpei.github.io/posts/4891372/"/>
    <id>http://qinyuanpei.github.io/posts/4891372/</id>
    <published>2018-05-12T01:16:52.000Z</published>
    <updated>2018-06-04T06:11:50.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;Hi，朋友们，大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是<a href="http://qinyuanpei.github.io">http://qinyuanpei.github.io</a>。在不知不觉间，5月份已然度过大半，最近无论是读书还是写作均停滞不前，被拖延症支配的我深感有虚度时光之嫌。今天这篇文章，我将为大家介绍如何使用<a href="https://about.sonarcloud.io/" target="_blank" rel="noopener">SonarCloud</a>，来为.NET/.NET Core项目集成静态检查。如果大家使用过<a href="https://www.sonarqube.org/" target="_blank" rel="noopener">SonarCube</a>的话，对接下来我要讲的内容一定不会感到陌生，因为<a href="https://about.sonarcloud.io/" target="_blank" rel="noopener">SonarCloud</a>实际上就是<a href="https://www.sonarqube.org/" target="_blank" rel="noopener">SonarCube</a>的“云”版本。在云计算概念深入人心的今天，我们可以通过互联网来访问各种各样的服务。譬如，我曾经为大家介绍过的TravisCI就是一个在线的持续集成(CI)服务。这些云服务可以让我们不再关心基础设施如何去搭建，进而集中精力去解决最核心、最关键的问题。和持续集成关注“持续”不同，静态检查关注的是代码质量。目前，SonarCloud支持<strong>.NET Framework 4.6</strong>以上及<strong>.NET Core</strong>版本。通过这篇文章，你将了解到<strong>SonarCloud的基本使用</strong>、<strong>SonarCloud与TravisCI的服务集成</strong>这两方面的内容。</p><h1 id="SonarCloud"><a href="#SonarCloud" class="headerlink" title="SonarCloud"></a>SonarCloud</h1><p>&emsp;&emsp;静态检查，顾名思义就是通过扫描源代码来发现代码中隐藏的缺陷，譬如潜在的Bug、重复/复杂的代码等等，这些通常被称为代码中的“坏味道”，静态检查就是通过工具去扫描这些“坏味道”。Sonar是一个基于Java的代码质量管理工具，由Sonar和SonarScanner两个主要部分组成，前者是一个Web系统用以展示代码扫描结果，而后者是真正用以扫描代码的工具。Sonar具备良好的扩展性，众多的插件使得它可以和Jenkins等集成工具结合使用，同时可支持不同语言项目的扫描分析。在.NET中我们可以使用<a href="https://github.com/StyleCop" target="_blank" rel="noopener">Stylecop</a>来进行静态检查，无独有偶，<a href="http://www.jetbrains.com/resharper/" target="_blank" rel="noopener">ReShaper</a>中同样提供了静态检查的特性。在这篇文章中我们主要使用Sonar来作为.NET项目的静态检查工具。</p><p>&emsp;&emsp;通常使用Sonar来构建静态检查工具时，需要我们在本地搭建一套运行环境，而SonarCloud是针对Sonar推出的一个“云”版本。我们只需要执行脚本就可以完成代码分析，而分析的结果则可以直接在SonarCloud网站中看到。这就是“云计算”的魅力所在，我们无需关心Sonar是如何安装以及配置的，当我们需要使用这种服务的时候直接使用就好了。目前，SonarCloud对开源项目是免费提供的。因此，如果你不想亲自去搭建一个静态分析的环境，那么你可以选择使用SonarCloud来对代码进行静态分析。SonarCloud支持17种语言的扫描分析，支持和Travis、VSTS、AppVeyor等CI工具集成，甚至你可以在SonarCloud上找到大量实际的项目。</p><p>&emsp;&emsp;我对SonarCloud感兴趣的一个重要原因是，它可以和TravisCI完美地集成在一起，而且在此之前，我曾经使用过一段时间的Sonar。在使用SonarCloud前，我们需要注册一个账号，这里建议使用Github账号授权登录，因为我们需要授权给SonarCloud来拉取代码，尤其当你使用TravisCI来集成SonarCloud的时候。除此之外，我们需要准备好以下工具：</p><ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">JDK</a>，即Java SE Development Kit，运行SonarScanner时依赖Java环境。</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>，版本控制工具，如果身为一名程序员而没有安装Git，请面壁思过并自我检讨。</li><li><a href="https://msdn.microsoft.com/en-us/library/dd393574.aspx" target="_blank" rel="noopener">MSBuild</a>，.NET平台项目构建工具，推荐一个无脑安装的方法，安装全宇宙无敌的IDE：Visual Studio。</li><li><a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild" target="_blank" rel="noopener">SonarScanner</a>，即Sonar的代码扫描器，注意这里有两个版本：<a href="https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.2.0.1214/sonar-scanner-msbuild-4.2.0.1214-net46.zip" target="_blank" rel="noopener">.NET Framework 4.6 +</a> 和 <a href="https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.2.0.1214/sonar-scanner-msbuild-4.2.0.1214-netcoreapp2.0.zip" target="_blank" rel="noopener">.NET Core</a>，本文以.NET Framework 4.6 +为例。</li></ul><h1 id="第一个-NET项目"><a href="#第一个-NET项目" class="headerlink" title="第一个.NET项目"></a>第一个.NET项目</h1><p>&emsp;&emsp;好了，下面我们来使用SonarCloud对博主的一个项目<a href="https://github.com/qinyuanpei/HttpServer" target="_blank" rel="noopener">HttpServer</a>进行分析。首先，我们需要在SonarCloud中创建一个项目。如下图所示，我们首先选择Organization，默认情况下，通过Github授权登录以后，会生成一个格式为：${UserName}-github的组织名称，例如我这里是：qinyuanpei-github。这里我们选择默认组织，然后点击：Continue。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Wechat_20180511174948.png" alt="设置组织名称" title="">                </div>                <div class="image-caption">设置组织名称</div>            </figure><br>&emsp;&emsp;接下来，我们需要设置一个Token，其目的是通过这个Token登录SonarCloud，然后把SonarScanner在本地扫描的结果发送到SonarCloud。这里我们可以选择生成一个新的Token或者是使用一个已经存在的Token。建议使用一个Token来管理所有的项目，因为这个Token显示一次后就不再显示，同时维护多个Token实在是太痛苦啦，当然，如果你能管理好所有Token的Key的话。设置完Token点击下一步：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/SonarCloud02.png" alt="设置Token" title="">                </div>                <div class="image-caption">设置Token</div>            </figure><br>&emsp;&emsp;设置完Token以后需要选择项目类型以及设置项目名称，在这个例子中，博主的项目名称是HttpServer，建议使用Sonar-${Project Name}的形式来为项目命名，而项目类型显然应该选择“C# or VB.NET”。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/SonarCloud03.png" alt="设置项目名称" title="">                </div>                <div class="image-caption">设置项目名称</div>            </figure><br>&emsp;&emsp;接下来我们就得到最关键的信息，如图所示，这里有三条命令，我们将其复制下来，然后将其写到批处理(.bat)或者PowerShll脚本里。以后运行这三条命令，就可以对当前项目进行静态检查，是不是很简单啊？简单分析下，这三条命令，第一条命令根据我们设置的Token、项目名称、组织等信息“开始”对项目进行分析，注意到这里有一个“begin”；第二条命令是一个MSBuild命令，其目的是对整个项目重新构建；第三条命令是将静态分析的提交到SonarCloud，注意到这里有一个“end”。具体文档可以参考 <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild" target="_blank" rel="noopener">这里</a>  哦！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/SonarCloud04.png" alt="复制3条命令" title="">                </div>                <div class="image-caption">复制3条命令</div>            </figure><br>&emsp;&emsp;好了，现在我们在SonarCloud中就可以看到扫描结果啦，开心！如果执行命令出现问题，请确保正确安装了相关工具，并检查这些工具是否被添加到系统变量中，特别是Java需要设置JAVA_HOME。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Wechat_20180511183203.png" alt="扫描结果" title="">                </div>                <div class="image-caption">扫描结果</div>            </figure></p><h1 id="TravisCI与SonarCloud的集成"><a href="#TravisCI与SonarCloud的集成" class="headerlink" title="TravisCI与SonarCloud的集成"></a>TravisCI与SonarCloud的集成</h1><p>&emsp;&emsp;现在我们来回顾下整个过程，我们需要在本地安装SonarScanner，这是一个Java编写的应用程序，因此我们需要一个Java运行环境。每次都需要通过SonarCloud来创建项目，获得项目相关的信息以后，在命令中携带这些参数并执行命令，就可以在SonarCloud中获得本地的扫描结果。在整个过程中，我们依然需要一个本地的环境，这一点都不灵活。现实世界的复杂性，就在于我们无法为还原出完全一致的处境。<br>&emsp;&emsp;所以，托尔斯泰开宗明义地说道：“幸福的家庭都是相似的，不幸的家庭各有各的不幸”，况且作为一个执着于让重复的事情自动化的人，如果让我做这件事情，我保证第一次会意外地觉得好奇，而等到第二次、第三次的时候我就会感到厌烦，这就是人们所说的三分钟热度。诚然，我的确是一个花心的双子座。我们提到，SonarCloud支持TravisCI，所以，接下来我们来考虑如何让TravisCI帮助我们运行Sonar。<br>&emsp;&emsp;常规的思路是，下载SonarScanner并执行脚本。这种思路的问题在于TravisCI运行在Linux下，我们确定SonnarScanner是否可以支持Linux平台，尽管SonarScanner使用Java开发。通过阅读TravisCI的<a href="https://docs.travis-ci.com/user/sonarcloud/" target="_blank" rel="noopener">文档</a>，我们发现TravisCI本身是支持SonarCloud的插件的，由此我们就可以着手将这一切交给TravisCI来做啦！<br>&emsp;&emsp;关于如何使用TravisCI，这里不再赘述啦！大家可以参考我的这两篇博客，这两篇博客分别是：<a href="https://qinyuanpei.github.io/posts/3521618732/">持续集成在Hexo自动化部署上的实践</a>、<a href="https://qinyuanpei.github.io/posts/1113828794/">基于Travis CI实现 Hexo 在 Github 和 Coding 的同步部署</a>。当然第一手的资料必然是官方文档，我是不好意思随便对别人说RTFM的。按照文档说明，我们首先需要一个名为sonar-project.properties的配置文件，在该配置文件中配置了诸如项目名称、组织名称等关键信息，Sonar会自动读取这个配置文件里的信息并携带到命令中去，这个配置文件是在是太熟悉啦，假如你认真地读了这篇文章，并注意到了SonarCloud生成的三条命令。这个配置文件内容如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># must be unique in a given SonarQube instance</span></span><br><span class="line">sonar.<span class="attribute">projectKey</span>=Sonar-HttpServer</span><br><span class="line"><span class="comment"># this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1.</span></span><br><span class="line">sonar.<span class="attribute">projectName</span>=HttpServer</span><br><span class="line">sonar.<span class="attribute">projectVersion</span>=1.0</span><br><span class="line"><span class="comment"># Path is relative to the sonar-project.properties file. Replace "\" by "/" on Windows.</span></span><br><span class="line"><span class="comment"># This property is optional if sonar.modules is set.</span></span><br><span class="line">sonar.<span class="attribute">sources</span>=.</span><br><span class="line"><span class="comment"># Encoding of the source code. Default is default system encoding</span></span><br><span class="line"><span class="comment">#sonar.sourceEncoding=UTF-8</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;配置文件中有来自官方的注释，我就不再狗尾续貂的去做相应的解释了。我们发现，这个里面是没有token的，按照官方<a href="https://docs.travis-ci.com/user/sonarcloud/" target="_blank" rel="noopener">文档</a>中的说明，token应该配置在.travis.yml这个文件中，熟悉TravisCI的朋友就会知道，这个文件通常用来配置持续集成的流程。按照约定，SonarCloud属于TravisCI的一个插件，应该配置在addons节点下，我们注意到，在这里可以配置组织名称和token两个节点的信息。组织信息这个简单，直接按照前面的流程填写即可，需要注意的是这里的token。<br>&emsp;&emsp;因为token采用明文配置的话，难免会存在安全风险，所以官方的建议是：使用TravisCI的终端工具进行加密。这是一个基于Ruby的命令行工具，直接在命令行中对token进行加密即可。不过想起很多年前，第一次接触Jekyll时被Ruby支配的恐惧感，我决定寻找新的出路。官方文档说可以在TravisCI中配置<a href="https://docs.travis-ci.com/user/environment-variables/#Defining-Variables-in-Repository-Settings" target="_blank" rel="noopener">全局变量</a>，这种方式我们接入Coding Page 时曾使用过，不过经过博主尝试，这种方式一直无法获得权限，所以，我不得不在配置文件中写明文，大家不要学我啊：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">addons:</span></span><br><span class="line"><span class="symbol">  sonarcloud:</span></span><br><span class="line"><span class="symbol">    organization:</span> <span class="string">"在这里输入你的组织名称"</span> </span><br><span class="line"><span class="symbol">    token:</span> <span class="string">"在这里输入你的token"</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;原本走到这一步时，我就该和大家对本文进行小结啦！可偏偏我注意到了SonarCloud生成命令中有MSBuild的身影，于是我开始尝试在TravisCI脚本中编写.NET相关的命令，因为我从未在TravisCI中对.NET项目进行持续集成，所以我很好奇它如果跑起来会是什么样子的。同样参照官方<a href="https://docs.travis-ci.com/user/languages/csharp/" target="_blank" rel="noopener">文档</a>，发现目前TravisCI支持Mono和.NET Core的两个版本的构建工具，Mono我可以理解，因为TravisCI运行在Linux环境下，这和我们以前运行在Windows环境下是不一样的。而.NET Core原本就支持跨平台，目前官方释放出了2.0预览版，同时3.0的计划开始提上日程。无论或早或晚，我们面对的都将是一个多平台化的未来，永远不要固执地封闭在一个生态系统里，技术是如此，人生何尝不是如此呢？<br>&emsp;&emsp;好啦，言归正传，了解到这种可能性以后，我开始尝试编写TravisCI脚本，官方默认的构建系统是XBuild，实际使用中遇到些问题，开始考虑能不能替换成MSBuild，事实上MSBuild目前已经是跨平台的，Nuget同样跨平台。微软收购Mono以后，Visual Studio基本上算是跨平台了，况且我们还有一个编辑器中的黑马Visual Studio Code。IIS目前可以考虑用Jexus替换，而有了OWIN这个服务器接口以后，我们有更多的Host可以去选择，现在剩下的只有SQL Server啦，可想而知，除了WinForm/WPF/COM等这种系统依赖性强的东西，大多数的服务其实都可以跑在Linux上。经过反复尝试，最终我们实现了：<strong>在TravisCI下使用MSBuild构建项目</strong>、<strong>使用Nuget在线安装NUnit并运行单元测试</strong>、<strong>使用SonarCloud对代码进行静态检查</strong>。一起来看脚本怎么写：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">jdk:</span><br><span class="line">  -<span class="ruby"> oraclejdk8</span></span><br><span class="line"><span class="ruby"><span class="symbol">mono:</span> </span></span><br><span class="line"><span class="ruby">  - latest</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">language:</span> csharp</span></span><br><span class="line"><span class="ruby"><span class="symbol">solution:</span> ./HTTPServer/HTTPServer.sln</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">notifications:</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">email:</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">recipients:</span></span></span><br><span class="line"><span class="ruby">      - <span class="number">875974254</span>@qq.com <span class="comment">#请替换成你的邮箱，谢谢</span></span></span><br><span class="line"><span class="ruby">      - qinyuanpei@163.com <span class="comment">#请替换成你的邮箱，谢谢</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">on_success:</span> change <span class="comment"># default: change</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">on_failure:</span> always <span class="comment"># default: always</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">install:</span></span></span><br><span class="line"><span class="ruby">  - cd ./HTTPServer</span></span><br><span class="line"><span class="ruby">  - nuget restore ./HTTPServer.sln <span class="comment"># restore nuget</span></span></span><br><span class="line"><span class="ruby">  - nuget install NUnit.Runners -Version <span class="number">3.8</span>.<span class="number">0</span> -OutputDirectory ./TestRunner <span class="comment"># install nunit</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">script:</span></span></span><br><span class="line"><span class="ruby">  - msbuild /<span class="symbol">p:</span>Configuration=Release HTTPServer.sln</span></span><br><span class="line"><span class="ruby">  - mono ./TestRunner/NUnit.ConsoleRunner.<span class="number">3.8</span>.<span class="number">0</span>/tools/nunit3-console.exe ./HTTPServerLib.UnitTest/bin/Release/HttpServerLib.UnitTest.dll</span></span><br><span class="line"><span class="ruby">  - sonar-scanner -Dsonar.verbose=<span class="literal">true</span> -X</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">branches:</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">only:</span></span></span><br><span class="line"><span class="ruby">    - master</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="symbol">addons:</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">sonarcloud:</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">organization:</span> <span class="string">"在这里输入你的组织名称"</span> </span></span><br><span class="line"><span class="ruby">    <span class="symbol">token:</span> <span class="string">"在这里输入你的token"</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">    </span></span><br><span class="line"><span class="ruby"><span class="symbol">cache:</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">directories:</span></span></span><br><span class="line"><span class="ruby">    - <span class="string">'$HOME/.sonar/cache'</span></span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;好啦，感受技术的魅力吧！可以注意到，我这里有4个单元测试，其中2个通过、2个失败。虽然单元测试没有通过，可我代码没有Bug呀！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Wechat_20180512003928.png" alt="NUnit运行结果" title="">                </div>                <div class="image-caption">NUnit运行结果</div>            </figure></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文介绍了一个“云”服务：SonarCloud。SonarCloud是一个基于SonarCube的静态分析工具，通过SonarCloud我们无需搭建Sonar环境就可以对项目进行静态分析。为了验证和实现这个诉求，我们首先提供了通过SonarScanner来扫描代码的示例，其原理是在命令行参数中携带相关信息，通过token来验证和登录SonarCloud，在完成对代码的扫描以后，就可以在SonarCloud中查看整个项目的分析结果。<br>&emsp;&emsp;接下来，为了验证SonarCloud和TravisCI进行集成的可行性，我们尝试通过travisCI脚本的方式来调用SonarCloud，其原理是通过配置文件获得相关信息由TravisCI完成所有的分析工作，这里需要注意的是要对token进行加密。在编写TravisCI脚本的过程中，我们一同验证了MSBuild、Nuget、NUnit等.NET常规工具或者类库在Linux平台下使用的可能性，最终在TravisCI的帮助下完成了从项目构建、单元测试再到代码的分析的整个流程。<br>&emsp;&emsp;虽然静态分析并不能完全保证代码没有问题，可人类总是不情愿承认自己仅仅是一种高等动物而已，这个世界上有好多东西人们不一定会喜欢，因为它们要么是正确的要么是有益的。本文这个方案需要把代码暴露在Github，对于一般的服务集成，我们更推荐Jenkins + Sonar这样的组合，前者可以替换TravisCI提供持续集成服务，同Github、Gitlib等代码托管服务进行集成、同Stylecop、Sonar等静态检查工具进行集成，这方面的资料非常丰富，我们这里就不再多说啦，总而言之，让一切更好就是我们的目的，晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发工具" scheme="http://qinyuanpei.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mono" scheme="http://qinyuanpei.github.io/tags/Mono/"/>
    
      <category term="Travis" scheme="http://qinyuanpei.github.io/tags/Travis/"/>
    
      <category term="Sonar" scheme="http://qinyuanpei.github.io/tags/Sonar/"/>
    
  </entry>
  
  <entry>
    <title>罗马数字与阿拉伯数字的相互转换</title>
    <link href="http://qinyuanpei.github.io/posts/4158690468/"/>
    <id>http://qinyuanpei.github.io/posts/4158690468/</id>
    <published>2018-04-30T10:59:46.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;最近遇到一道非常有趣的题目，题目大意如下：有一个富翁在银河系里做生意，而银河系使用的是罗马数字，所以他需要一个精明能干的助手，帮助他完成罗马数字与阿拉伯数字的相互转换，题目在这个背景下衍生出交易场景，我们需要帮助他计算出相关商品的价格。对于这道题目，如果剥离开这个题目本身的交易场景，这道题目本质上就是一个纯粹的算法问题。说来惭愧，博主当时并未能快速地解决这个问题，事后通过研读别人的文章始能有所领悟。所以，今天想在这篇文章里，同大家一起来讨论下这个问题。今天，全世界都在使用0到9这10个阿拉伯数字，比阿拉伯数字早2000年的罗马数字。为什么没有流传下来为后世所用呢？我觉得这是一个非常有意思的问题，数学同计算机学科间那种千丝万缕的联系、技术演进过程中若有若无的某种必然性……这些都是令我觉得非常有意思的地方。那么，一起来看看这个问题可好？</p><h1 id="罗马数字起源"><a href="#罗马数字起源" class="headerlink" title="罗马数字起源"></a>罗马数字起源</h1><p>&emsp;&emsp;罗马数字，顾名思义，就是古罗马人使用的数字系统。在罗马数字中，共有7个基本数字，即I、V、X、L、C、D、M，它们分别表示1、5、10、50、100、500、1000。可以注意到，在这套数字系统中，0不被视作是一个整数。据说，曾经有一位罗马学者不顾教皇的反对，执意将与0相关的知识以及0在运算中的作用向民众传播，因此被教皇囚禁并投入监狱，理由是0是一个邪物，破坏了神圣的数。同样罗马数字无法表示小数(<strong>注：罗马数字有分数的表示方法，可仅仅能表示1/12的整数倍</strong>)，因此罗马数字常常用来表示纪年，在欧洲国家的古书籍、建筑和钟表中，我们都可以见到罗马数字的身影。我们熟悉的元素周期表，同样采用了罗马数字来表示元素所在的”族”。需要说明的是，罗马数字是一种计数规则，而非计算规则，这意味者罗马数字是没有进位和权重的概念的，所以一般罗马数字只用以计数而不用以演算。</p><p>&emsp;&emsp;既然罗马数字是一种计数规则，那么我们就不得不说一说它的组合规则，因为4000以内的数字，都可以用这7个基本数字组合表示。具体来讲，罗马数字的基本规则有以下4条：</p><ul><li>重复次数：<strong>一个数字重复多少次，所表示的数字就是这个罗马数字的多少倍；一个罗马数字最多重复三次。</strong>这条规则该怎么理解呢？第一点，I、II、III分别表示1、2、3；第二点，4必须被表示为IV，而不是IIII。关于4的表示方法，在历史上一直存在争议，一种观点认为IIII这种写法占用书写空间，IV可以达到简化书写的作用；而一种观点则认为IV有亵渎神灵朱庇特、含不敬侮辱之意。</li><li>左减原则：<strong>当一个较小的数字被放在一个较大数字的左边时，所表示的数字等于这个大数减去这个小数，且左边最多只能放一个较小的数字</strong>。联系第一条原则，IV表示的实际上是V-I，所以这个数值表示4；同理，9为了满足第一条原则，必须被表示成IX。</li><li>右加原则：<strong>当一个较小的数字被放在一个较大数字的右边时，所表示的数字等于这个大数加上这个小数，且右边最多只能放一个较小的数字</strong>。这一条原则和第二条原则相对应，例如11会被表示成XI、21会被表示为XXI，以此类推。</li><li>搭配原则：<strong>I只能被放在V和X的左边；X只能被放在L和C的左边；C只能被放在D和M的左边；V、L、D不能被放在左边</strong>。这一条可以看作对是第二条的总结，所以没有什么可说的。</li></ul><p>&emsp;&emsp;好了，通过这个这些规则我们就可以组合出不同的数字，我们可以注意到这些数字呈现出1、4、5、9的规律。什么是1、4、5、9的规律呢？我们可以注意到4和9是两个特殊的数字，4必须通过5左减来得到，9必须通过10左减来得到，这是因为罗马数字要满足最多重复三次的原则，而4和9相对1和5的偏移量恰好是4，所以它们的表示方法和其他数字不同。因为罗马数字没有进位和权重的概念，所以除了左减和右增这两种特殊情况以外，它的基本数字应该从左至右依次递减，即使在左减的情况下，左边的数字应该和右边的数字处在同一序列。这句话怎么理解呢？例如，90必须用100-10来表示；而99必须拆解为90和9，然后分别用100-10和10-1来表示，唯独不能通过100-1来表示，因为100和1分属两个不同的序列。</p><h1 id="数字转换实现"><a href="#数字转换实现" class="headerlink" title="数字转换实现"></a>数字转换实现</h1><p>&emsp;&emsp;了解完罗马数字的历史渊源，我们就对罗马数字有了一定的了解。现在来考虑一个问题，即罗马数字和阿拉伯数字间的相互转换。罗马数字的确是古罗马人发明的，可阿拉伯数字实际上却是古印度人发明的。今天全世界人都在使用阿拉伯数字，因此这两者间需要一个转换器，这正是我们一开始所讨论的问题：假如银河系里的人们都使用罗马数字来计数，当一个地球上的富翁来到银河系以后，他要如何去和这里的人们进行交易。显然，这种转换应该是双向的，我们下面分别来看如何实现相应的转换。</p><h2 id="阿拉伯转罗马"><a href="#阿拉伯转罗马" class="headerlink" title="阿拉伯转罗马"></a>阿拉伯转罗马</h2><p>&emsp;&emsp;首先来考虑阿拉伯数字转罗马数字，因为一个罗马数字必然是从左到右依次递减，所以我们只需要将这7个基本数字从大到小排列，找到第一个不小于指定数字的数位即可。例如1024显然超过了1000，而罗马数字中的1000对应M，因此1024的第一位应该是M。接下来24，显然超过10，因此1024的第二位数字应该是X。接下来14，显然超过10，因此1024的第三位数字同样是X。接下来4，这是一个特殊的数字，需要被表示为IV，这是1024的第四位数字。我们将整个过程串联起来，就可以得到1024的罗马数字形式MXXIV。我们注意的一点是，这里需要4和9这两个数字作为辅助数字，因为1到3、6到8的数字，我们总可以通过不断地重复1来得到，就像辗转相除法一样。如果没有这两个辅助数字会怎样呢？4会变成IIII，而9会变成VIIII，显然这是不符合我们预期的。整理下我们的思路，这段代码实现如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> ConvertToRoman(int <span class="built_in">number</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> output = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">var</span> digitMap = <span class="keyword">new</span> Dictionary&lt;int,<span class="built_in">string</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">      &#123;<span class="number">1</span>,<span class="string">"I"</span>&#125;,&#123;<span class="number">4</span>,<span class="string">"IV"</span>&#125;,&#123;<span class="number">5</span>,<span class="string">"V"</span>&#125;,&#123;<span class="number">9</span>,<span class="string">"IX"</span>&#125;,</span><br><span class="line">      &#123;<span class="number">10</span>,<span class="string">"X"</span>&#125;,&#123;<span class="number">40</span>,<span class="string">"XL"</span>&#125;,&#123;<span class="number">50</span>,<span class="string">"L"</span>&#125;,&#123;<span class="number">90</span>,<span class="string">"XC"</span>&#125;,</span><br><span class="line">      &#123;<span class="number">100</span>,<span class="string">"C"</span>&#125;,&#123;<span class="number">400</span>,<span class="string">"CD"</span>&#125;,&#123;<span class="number">500</span>,<span class="string">"D"</span>&#125;,&#123;<span class="number">900</span>,<span class="string">"CM"</span>&#125;,</span><br><span class="line">      &#123;<span class="number">1000</span>,<span class="string">"M"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> digits = digitMap.OrderByDescending(<span class="function"><span class="params">e</span> =&gt;</span> e.Key).ToList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; digits.Count &amp;&amp; <span class="built_in">number</span> &gt; <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">number</span> &lt; digits[i].Key) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">number</span> &gt;= digits[i].Key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">number</span> -= digits[i].Key;</span><br><span class="line">            output.Append(digits[i].Value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="罗马转阿拉伯"><a href="#罗马转阿拉伯" class="headerlink" title="罗马转阿拉伯"></a>罗马转阿拉伯</h2><p>&emsp;&emsp;接下来考虑罗马数字如何转换为阿拉伯数字，我们可以明确的一点是，罗马数字基本上是从左到右依次递减排列的，每一个数字的左侧和右侧出现的数字一定处于当前数字的同一序列。比如，I只能被放在V和X的左边；X只能被放在L和C的左边；C只能被放在D和M的左边。因此，我们从左到右依次遍历整个字符串，将每个字符转化为对应的阿拉伯数字然后累加即可，需要注意的是，当当前元素小于下一元素时，表示当前元素为负数；当当前元素大于下一元素时，表示当前元素为正数。显然，这里最后一位应该是正数，因为它没有下一个元素可以比较。至此，我们梳理出整个思路：从第一位到第n-1位依次循环，判断当前元素的正负然后累加，再加上最后一位元素的值即可。下面是代码实现：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ConvertToNumber</span>(<span class="params"><span class="keyword">string</span> romanNumber</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> length = romanNumber.Length;</span><br><span class="line">    <span class="keyword">var</span> digits = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>,<span class="keyword">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">      &#123;<span class="string">"I"</span>,<span class="number">1</span>&#125;,&#123;<span class="string">"V"</span>,<span class="number">5</span>&#125;,&#123;<span class="string">"X"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"L"</span>,<span class="number">50</span>&#125;,&#123;<span class="string">"C"</span>,<span class="number">100</span>&#125;,&#123;<span class="string">"D"</span>,<span class="number">500</span>&#125;,&#123;<span class="string">"M"</span>,<span class="number">1000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//前面 n-1 位数字通过左右比较决定正负 &amp; 第 n 位数字必然为正</span></span><br><span class="line">        <span class="keyword">if</span> ((digits[romanNumber[i].ToString()] &gt;= digits[romanNumber[i + <span class="number">1</span>].ToString()]) || i + <span class="number">1</span> &gt;= length)</span><br><span class="line">        &#123;</span><br><span class="line">            number += digits[romanNumber[i].ToString()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            number -= digits[romanNumber[i].ToString()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="为什么会溢出"><a href="#为什么会溢出" class="headerlink" title="为什么会溢出"></a>为什么会溢出</h1><p>&emsp;&emsp;相信上面这两段代码，大家都已然把玩过了。可我们仔细想想，就会觉得这事儿不靠谱。前段时间网络上一直流传着，我们这些佛系青年正在被同龄人抛弃。这个题目里我们所面对的，可是一个来自地球的的富翁啊！富翁的钱不都是按亿来计数的吗？我们没有一个亿这样的小目标，我们的目标是月入5万啊，这是一个社会上流行的说法。好了，回到这个题目中来，如果我们输入50000这个阿拉伯数字，它会输出什么呢？答案是50个M，这很罗马数字啊，当然更神奇的事情是什么呢？当我们尝试把这由50个M组成的罗马数字转换为阿拉伯数字时，会发现它不能像我们期望地输出50000，而会变成是一个负数。为什么这里是负数呢？答案是溢出啦！</p><p>&emsp;&emsp;过去，我们常常听到”溢出“这个词儿，最常见的是数据溢出。为什么会发生数据溢出呢？因为我们定义的数据超过了计算机所使用的数据的表示范围。这一点我们可能无法理解，一个相对粗浅的认识是，现代计算机的内存已经大到非常客观，甚至我们的硬盘都已经使用TB这样的容量单位，为什么还是会发生数据溢出呢？回到罗马数字这个问题，我们发现一个残酷的事实是，古罗马人并没有定义1000以上的数字表示，这或许和古罗马人发明数字的过程有关。古人最早都是使用手指、绳结、竹筹这样的工具来计数，在人们没有接触到相当大的数字以前，人们认为这些数的表示是足够的。同样的，我们的计算机经历了从8位、16位、32位到64位的发展。所以，这个世界上没有任何东西是一成不变的，一个技术方案势必要随着业务演化而扩展。</p><p>&emsp;&emsp;我们前面曾提到，这7个基本数字可以表示4000以内的数字，为什么是4000以内呢？因为根据罗马数字最多重复三次的规则，我们应该用5000-1000来表示4000，可问题是这7个基本数字中并没有5000的定义，这和计算机中的数据溢出是非常相似的，因为我们都无法通过现有的构造去描述一个新的东西。这和数学上的那些”扩充“有着极其相似的地方，当我们意识到所有的数不都是整数的时候，我们引入了分数/小数；当我们意识到所有的数不都是有理数的时候，我们引入了无理数； 当我们意识到所有的数不都是实数的时候，我们引入了虚数。在数学上，这叫做数的扩充；在计算机里，这叫做数据溢出。数学作为一本学科，可以通过完善理论来自圆其说；而编程语言里数据结构，是在一开始就定义好的一套规范，它无法更不应该经常去修改，关于如何去解决程序中数据溢出的问题，这已然是一个新的问题了，不过我们可以看看古罗马人是怎么做的。</p><p>&emsp;&emsp;聪明的罗马人自然想到了这个问题，他们提出的解决方案是这样的：在一个数字的上面加一条横线，表示这个数增值1000倍。所以，按照这个定义，4000应该由IV变化而来，9000应该由10000变化而来，而10000则可以看作是10的1000倍，即10000应该由X变化而来。我们在最初的规则中为什么没有说这一条呢？因为在数字上面增加一条横线，这更接近一个书写的行为，它增加了我们程序解析的难度，当一个数字的上面出现横线以后，我们就不能再按照原来的方式去转换。所以，考虑这个因素，实际上还是为了简化问题本身，这道题目中同样回避了这个问题。罗马人这个想法的确很好，可以解决眼下我们所面临的问题，可时间久了以后，罗马人发现这套计数规则书写了繁琐复杂，因而这套规则渐渐地就被人们放弃了。在2015年意大利官方宣布，国内街道编码、文件编码等全部废弃原有的罗马数字，改为使用阿拉伯数字。</p><h1 id="选择阿拉伯数字"><a href="#选择阿拉伯数字" class="headerlink" title="选择阿拉伯数字"></a>选择阿拉伯数字</h1><p>&emsp;&emsp;历史最终选择了阿拉伯数字，而不是罗马数字，这并不是一个巧合，尽管罗马数字要比阿拉伯数字早2000年。罗马数字的缺陷不仅仅在于其书写的繁杂，一个更重要的原因是，它不能更好地推动数学学科的发展。罗马人发明罗马数字的目的是为了计数，可一旦产生了数，就势必会产生计算。可我们发现罗马数字并不适合计算，因为它对数字的构造并不是正交的。一个最为直观的例子是，数字可能会用一个字母、两个字母或者三个字母来表示，如果两个数字要进行加减法，我们会发现它的数字是无法”对齐“的，你必须非常小心地分清楚不同的数位，而罗马数字恰好是没有数位的概念的。同样，当数字加减时会产生进位或者借位，罗马数字的构造会导致牵一发而动全身，因为任何一个中间步骤，我们都必须将其记录下来，记录的代价是将整个结果重写。反观阿拉伯数字，0到9共10个数字可以表示一切，形式上的统一让计算更加便捷，书写更为简洁，这套定义可以扩展到无限大的数上面去，可以扩展到小数、分数甚至无理数、虚数。这是否意味着，一个统一化的定义或者构造，更适合去做相关的运算流程或者逻辑流程呢？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文从一道有趣的题目作为引子，引出这篇文章的主题：罗马数字。我们首先为大家回顾了罗马数字的历史渊源。罗马数字是一种由古罗马人创造的数字系统，这套数字系统主要的用途是进行计数。罗马数字由I、V、X、L、C、D、M共7个基本数字组成，其基本规则是最多重复三次、左减右增。接下来，我们分析了罗马数字与阿拉伯数字相互转换的规律，并提供相关代码实现。在当前方案的基础上，我们引出了罗马数字中的”4000“问题，联系计算机中的数据溢出的相关概念，我们分析了为什么当罗马数字超过4000时会发生”溢出“，以及罗马人是如何解决这个问题的。虽然罗马数字比阿拉伯数字早2000年，可历史最终选择了阿拉伯数字，这里我们简要地分析了原因，因为罗马数字并不适合计算，而数字作为数学的基本要素，一个不能被运用到计算出的数字系统，最终免除不了被人们抛弃的命运。好了，这篇五一节前的文章 就是这样啦，4月再见！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="数学" scheme="http://qinyuanpei.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="算法" scheme="http://qinyuanpei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数字" scheme="http://qinyuanpei.github.io/tags/%E6%95%B0%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>邂逅AOP：说说JavaScript中的修饰器</title>
    <link href="http://qinyuanpei.github.io/posts/3668933172/"/>
    <id>http://qinyuanpei.github.io/posts/3668933172/</id>
    <published>2018-04-15T21:20:03.000Z</published>
    <updated>2018-06-04T06:11:50.632Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;Hi，各位朋友，大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。这个月基本上没怎么更新博客和公众号，所以今天想写一篇科普性质的文章，主题是JavaScript中的修饰器。 为什么使用了”邂逅”这样一个词汇呢？因为当你知道无法再邂逅爱情的时候，你只能去期待邂逅爱情以外的事物；当你意识到爱情不过是生命里的小插曲，你只能去努力弥补生命的完整性。在过往的博客中，我曾向大家介绍过譬如Spring.NET、Unity、AspectCore等AOP相关的框架，亦曾向大家介绍过譬如Python中的装饰器、.NET中的Attribute、Java中的注解等等。再我看来，这些都是非常相近的概念，所以今天这篇文章我们又双叒叕要说AOP啦！什么？你说JavaScript里居然AOP！这简直比任何特性都要开心好吗？而这就要从本文的主角——JavaScript中的修饰器说起。</p><h1 id="什么是修饰器？"><a href="#什么是修饰器？" class="headerlink" title="什么是修饰器？"></a>什么是修饰器？</h1><p>&emsp;&emsp;JavaScript中的修饰器(<strong>Decorator</strong>)，是ES7的一个提案。目前的浏览器版本均不支持这一特性，所以主流的技术方案是采用Babel进行转译，事实上前端的工具链有相当多的工具都是这样，当然这些都是我们以后的话题啦！修饰器的出现，主要解决了下面这两个问题：</p><ul><li>不同类间共享方法</li><li>在<strong>编译时</strong>期间对类及其方法进行修改</li></ul><p>&emsp;&emsp;这里第一点看起来意义并不显著啊，因为JavaScript里有了模块化以后，在不同间共享方法只需要将其按模块导出即可。当然，在模块化这个问题上，JavaScript社区发扬了一贯的混乱传统，CommonJS、AMD、CMD等等不同的规范层出不穷，幸运的是ES6中使用了import和export实现了模块功能，这是目前事实上的模块化标准。这里需要关注的第二点，在<strong>编译时</strong>期间对类及其方法进行修改，这可以对类及其方法进行修改，这就非常有趣了呀！再注意到这里的修饰器即<strong>Decorator</strong>，我们立刻想Python中的装饰器，想到装饰器模式，想到代理模式，所以相信到这里大家不难理解我所说的，我们又双叒叕要说AOP啦！</p><p>&emsp;&emsp;那么说了这么多，JavaScript中的修饰器到底长什么样子呢？其实，它没有什么好神秘的，我们在Python和Java中都曾见过它，前者称为<strong>装饰器</strong>，后者称为<strong>注解</strong>，即在类或者方法的上面增加一个@符号，联想一下Spring中的Controller，我们大概知道它长下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修饰类 */</span></span><br><span class="line">@bar</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修饰方法 */</span></span><br><span class="line">@bar</span><br><span class="line">foo()&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;OK，现在大家一定觉得，这TM简直就是抄袭了Python好吗？为了避免大家变成一个肤浅的人，我们一起来看看下面具体的例子：</p><h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@setProp</span><br><span class="line"><span class="keyword">class</span> User &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> setProp(<span class="keyword">target</span>) &#123;</span><br><span class="line">    <span class="keyword">target</span>.age = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(User.age)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个例子展示的是，我们如何通过修饰器函数setProp()来为User对象赋值，为什么叫做修饰器函数呢？因为这就是个函数啊，而且JavaScript和Python一样都是支持函数式编程的编程语言，所以大家看到这个大可不必感到吃惊，因为大道至简殊途同归。好了，注意到SetProp()方法有一个参数target，因为该方法修饰User类，所以它的参数就是User类，显然它为User类扩展了一个属性age，并给它赋值为30。相信有朋友一定会奇怪这个age是哪里定义的，我只能说JavaScript是个神奇的语言，一切都是对象，一切都是函数。现在，当我们执行到最后一句时，会输出30，这是因为修饰器对类进行修改。</p><p>&emsp;&emsp;现在我们尝试修改下这个方法，我们希望可以通过修饰器修改age属性的值，而不是让它成为一个固定数值30，这样就涉及到带参数的修饰器函数。修饰器函数本身会接收三个参数，第一个参数是被修饰的对象，因此为了增加一个新的参数，我们需要对原来的函数进行一层包装，你知道吗？此时我感到非常兴奋，因为这TM真的和Python一模一样啊。好了，遵从这个策略，我们修改原来的代码，并将其调整如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@setProp(<span class="number">20</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProp</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        target.age = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(User.age)</span><br></pre></td></tr></table></figure></p><p>此种差别，大家可以非常明显地看出来，我们在使用修饰器函数setProp()的时候，现在允许传入一个参数20，此时的结果是非常地显而易见的，这段代码将如你所愿地输出20。</p><h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>&emsp;&emsp;既然修饰器可以修饰类，那么可不可以修饰方法呢？答案自然是可以的。因为当修饰器修饰类的时候，修饰器函数的参数是一个对象，即target，而当修饰器修饰方法的时候，修饰器函数的参数是一个函数。可函数难道就不是对象吗？.NET里的委托最终不是同样会生成一个类吗？Python中不是有函数对象这一概念吗？那么，我们继续看一个例子 ：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readonly修饰函数，对方法进行只读操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.writable = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> u = <span class="keyword">new</span> User()</span><br><span class="line"><span class="comment">// 尝试修改函数，在控制台会报错</span></span><br><span class="line">u.getName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'I will override'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们通过修饰器函数readonly()对getName()方法进行修饰，使其变成一个readonly的方法。我们提到修饰器函数有三个参数，target指被修饰的对象，name指被修饰器对象的名称，descriptor指被修饰对象的defineProperty。因为设置descriptor的writable属性为false以后，这个函数就无法被覆盖重写，所以代码中尝试重写该方法时就会报错；同理，如果我们对descriptor的value属性进行修改，则可以对该函数进行重写。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;相信熟悉Python中的朋友，应该会知道在Python中内置了大量的装饰器，譬如@property可以让一个方法像属性一样被调用、@staticmethod可以让一个方法变成静态方法、@classmethod可以让一个方法变成类方法等。那么，作为Python的追随者，JavaSript中是否存在相类似的概念呢？答案还是肯定的啊！哈哈。具体大家可以参考这里：<a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">ES6  Decorator</a></p><h1 id="AOP与修饰器"><a href="#AOP与修饰器" class="headerlink" title="AOP与修饰器"></a>AOP与修饰器</h1><p>&emsp;&emsp;熟悉我写作风格的朋友，应该可以猜到我接下来要做什么了。的确，作为一个在某些方面有强迫症的人，我一直在不遗余力地向大家推广AOP，因为我相信AOP真的可以帮大家去做很多事情。比如最简单的记录日志，或许在前端项目中大家更习惯用console.log()来记录日志，甚至是使用alert()，毕竟这些东西不会在界面上展示出来，所以写一写这些东西好像无可厚非。可当你有了AOP以后，为什么还要做如此出力不讨好的事情呢？我写这篇文章的一个重要原因，正是我看到在前端同事的代码中，使用修饰器做了一个简单的AOP，这非常符合我的品味。具体怎么样去做呢？我们一起来看这段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bussiness</span> </span>&#123;</span><br><span class="line">    @log</span><br><span class="line">    step1() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @log</span><br><span class="line">    step2() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target,name,decriptor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Calling function "$&#123;name&#125;" with '</span>, argumants);</span><br><span class="line">      <span class="keyword">return</span> origin.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们刚刚提到通过修改descriptor的value属性可以达到重写方法的目的，那么这里就是利用这种方式对原来的方法进行了修改，在调用原来的方法前调用console.log()写了一行日志。的确，就是这样一行平淡无奇的代码，将我们从泥潭中解救出来。试想看到一段日志记录和业务流程掺杂的代码，谁会有心情去解读代码背后真实的含义，更不必说将来有一天要去删除这些日志有多么艰难啦。AOP的基本思想是在代码执行前后插入代码片段，因为根据JavaScript中的原型继承，我们可以非常容易地为Function类型扩展出before和after两个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefunc</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> outerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    beforefunc.apply(<span class="keyword">this</span>,innerArgs);</span><br><span class="line">    self.apply(<span class="keyword">this</span>,outerArgs)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfunc</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> outerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    self.apply(<span class="keyword">this</span>,outerArgs)</span><br><span class="line">    afterfunc.apply(<span class="keyword">this</span>,innerArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;想象一下，现在我们在重写descriptor的value属性的时候，可以同时指定它的before()方法和after()方法，所以最初的这段代码可以继续被改写为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Calling function "$&#123;name&#125;" with '</span>, argumants);</span><br><span class="line">    <span class="keyword">return</span> origin.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Start calling function $&#123;name&#125;'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">func.after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'End calling function $&#123;name&#125;'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;所以，所有让你觉得会增加风险的东西，都是源于你内心的恐惧，因为你不愿意去尝试改变，这是真正的复用，如果Ctrl + C和Ctrl + V可以被称为复用的话，我觉得每一个人都可以说自己是网红啦！这并不是一个笑话，还有什么比写一个@log更简单的吗？同样，我们可以使用修饰器去统计代码运行的时间，而不是在所有地方用两个Date()对象去相减。遵从简洁，从心开始：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">time</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target,name,decriptor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      <span class="keyword">let</span> result = origin.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">let</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      <span class="keyword">let</span> time = endTime.getTime() - beginTime.getTime();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Calling function '$&#123;name&#125;' used '$&#123;time&#125;' ms"</span>); </span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@time</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;再比如，我们的业务中要求：用户在访问相关资源或者是执行相关操作时，需要确保用户的状态是登录着的，因此，我们不可避免地在代码中，使用if语句去判断用户是否登录，试想如果所有的业务代码都这样写，两个模块间就存在了直接耦合，当然我们可以说这是最简单的做法，因为它照顾了大部分人的思维和情绪，可你看Angular/Redux/TypeScript等项目中无一不遍布着修饰器的身影，当一种框架逐渐流行并成为一种趋势的时候，好像大家立刻就忘记了一件事情：原本我们都是非常排斥这些奇技淫巧的，可因为框架的流行你就默认接受了这种设定。那么，这个逻辑如何使用修饰器来编写会怎么样呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    @checkLogin</span><br><span class="line">    getUserInfo() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'获取已登录用户的用户信息'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @checkLogin</span><br><span class="line">    sendMsg() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'发送消息'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查用户是否登录，如果没有登录，就跳转到登录页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkLogin</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> method = descriptor.value</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//假想的校验方法，假设这里可以获取到用户名/密码</span></span><br><span class="line">        <span class="keyword">if</span> (validate(args)) &#123;</span><br><span class="line">            method.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'没有登录，即将跳转到登录页面...'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> u = <span class="keyword">new</span> User()</span><br><span class="line">u.getUserInfo()</span><br><span class="line">u.sendMsg()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;显然，现在我们可以避免模块间的直接耦合，无需在每个业务方法中重复去写if语句，更重要的是通过JavaScript中的模块化规范，我们可以把checkLogin这个方法，扩展到更多的业务类及其方法中去，而唯一的代价就是在方法上增加@checkLogin修饰，你说，有这样优雅的策略，你为什么就不愿意去使用呢？在ASP.NET中我们通过Authorize特性就可以为API和页面授权，现在看来这是不是有点异曲同工之妙呢？你现在还觉得这样麻烦吗？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;这篇文章从一个前端项目中的日志拦截器(InterceptLog)为引子，引出了ES7提案中的一个特性：修饰器。修饰器的出现，解决了两个问题：第一、不同类间共享方法；第二、在<strong>编译时</strong>期间对类及其方法进行修改。虽然目前修饰器不能直接在浏览器中使用，可是通过Babel这样的转译工具，我们已经可以在项目中提前感受这一特性，这里表扬下前端组的同事们。JavaScript中的修饰器同Python中的修饰器类似，可以修饰类及其方法。JavaScript中的修饰器不建议修饰函数，因为存在一个函数提升的问题，如果一定要修饰函数，按照高阶函数的概念直接包装函数即可。通过修饰器可以简化我们的代码，在本文中我们例举了日志记录、运行时间记录、登录检查三个AOP相关的实例，希望大家可以从这篇文章中有所收获。</p><p>&emsp;&emsp;最后，请允许博主爆一个料，因为要写一个简单的修饰器，需要安装若干Babel甚至是Webpack插件，我这篇文章中的代码，截止到写这篇文章时都没能在实际环境中运行，这不能怪我啊，因为前端的工具链实在是太长太多啦，这当然不能和直接内置装饰器的Python相比啊，这真的不是吐槽诶，我需要一个开箱即用的特性就这么难吗？人生苦短，我用Python！(逃</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://segmentfault.com/a/1190000011479378" target="_blank" rel="noopener">读懂ES7中JavaScript修饰器 </a></li><li><a href="https://segmentfault.com/a/1190000010019412" target="_blank" rel="noopener">ES7 Decorator 入门解析</a></li><li><a href="http://web.jobbole.com/84247/" target="_blank" rel="noopener">ES7 Decorator 装饰者模式</a></li><li><a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">ECMAScript 6 入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="AOP" scheme="http://qinyuanpei.github.io/tags/AOP/"/>
    
      <category term="ES6" scheme="http://qinyuanpei.github.io/tags/ES6/"/>
    
      <category term="JS" scheme="http://qinyuanpei.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>一念执着，千山无阻</title>
    <link href="http://qinyuanpei.github.io/posts/2613006280/"/>
    <id>http://qinyuanpei.github.io/posts/2613006280/</id>
    <published>2018-04-03T09:08:04.000Z</published>
    <updated>2018-06-04T06:11:50.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;上周看了部印度电影《小萝莉的猴神大叔》，以一言敝之，这是一部被名字耽误的好电影，就像我们所熟知的《三傻大闹宝莱坞》、《偶滴个神呐》、《外星醉汉PK地球神》等等电影一样。不过作为一部由“印度三汗”之一萨尔曼·汗主演的电影，可能因为其在国内的知名度不及阿米尔·汗，所以早在这部2015年就上映的电影，并未在国内产生太显著的影响力。相反，同档电影《环太平洋2》票房热度居高不下，大概是因为景甜姐姐终于不负国人期望去拯救全人类啦。即使当时电影院里看这部电影的人寥寥无几，可我觉得还是有必要给大家说一说这部电影，一个即使你能猜对所有情节依然会喜欢的电影。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2311758198.jpg" alt="小萝莉与猴神大叔" title="">                </div>                <div class="image-caption">小萝莉与猴神大叔</div>            </figure><p>&emsp;&emsp;影片一开始，讲述的是来自巴基斯坦穆斯林家庭的小女孩沙希达的故事。沙希达到6岁还不会说话，她的父母对此感到焦虑不已。祖父建议带她到神庙里去向神祈祷，可这座神庙在印度境内，并且两国间互相仇视达半个世纪之久。因为沙希达的父亲曾在巴基斯坦军方服过5年兵役，因此他没有办法申请前往印度的签证。无奈之下，沙希达的母亲独自带领女儿前往印度，不想在返回巴基斯坦的途中，沙希达在列车停靠期间，为下车救一只小羊羔而和母亲走散，并被一节载满粮食的火车带到印度。沙希达在那里遇到了“猴神”帕万，面对印度警方的无动于衷，大使馆因为印巴冲突而关门，黑中介拐卖幼童等等一系列的变故，帕万不得不走上亲自送沙希达回家的旅程……</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2322605677.jpg" alt="沙希达与小羊羔" title="">                </div>                <div class="image-caption">沙希达与小羊羔</div>            </figure><p>&emsp;&emsp;电影的主线是非常清晰的，不同的是，整个电影被放在一个充斥着宗教矛盾、种姓歧视、印巴冲突的大背景里，所以导演试图去表达的内涵，就不再单纯地是为了讲这样一个故事，一如“三傻”抨击印度教育制度、OMG/偶滴个神/PK探讨宗教和神一样，这部电影里有许多值得去探讨的东西。电影两条相互交叉的线索构成，男主帕夫是一个虔诚的宗教信徒，他信奉的是印度猴神哈奴曼，并努力将宗教的教义落实到言行中去，甚至在生活中显得憨厚而木讷，导演在刻画这个人物时明显夸大了这一点，印象最深的是男主考高中就考了10次，最终父亲居然因为这个“惊喜”而去世。男主寄身在父亲身前的好友家中，并邂逅了一份“坎坷”的爱情。男主的确是一个普世价值中的失败者，没有稳定的工作，岳父要求他在六个月内买一套婚房，甚至从被黑中介欺骗这里可以看出，他并不是一个社会经验丰富的人。善良的男主在猴神节上给沙希达买了薄饼和饮料，沙希达就认定他是一个值得信赖的人，两个人的故事就此展开。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2319317555.jpg" alt="小孩子都懂得说谎" title="">                </div>                <div class="image-caption">小孩子都懂得说谎</div>            </figure><p>&emsp;&emsp;帕夫最初希望向印度警方寻求帮助，可警方认为警察局并不是孤儿院，拒绝为沙希达提供相关帮助。无奈之下，帕夫将小女孩带回岳父家中，起初人们见到这个可爱的小女孩，一度认为这是这个小女孩来自印度的某个高贵种姓。种姓制度是一种以血统论为基础的等级制度，广泛存在于印度社会运作与生活中，虽然印度早在1947年就脱离了英国殖民者的统治，可这种在殖民时期被固定和僵化的制度，在今天依旧影响深远。无独有偶，印巴冲突正是英国殖民统治者将印度划分为两个地区统治的结果，电影中印度的印地语和巴基斯坦的乌尔都语，其实是非常相似的两门语言。曾经有两个自命不凡的民族，一个是德意志雅丽安族，一个是扶桑国大和民族，一起发动第二次世界大战，为了所谓的种族优越性，大肆迫害犹太人和中国人，一个6岁的孩子因为可爱就被迫贴上这种种族的标签，人类繁衍至今，这种病态的虚荣心不觉得可悲吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2311757793.jpg" alt="有什么区别？" title="">                </div>                <div class="image-caption">有什么区别？</div>            </figure><p>&emsp;&emsp;如果说这种自带歧视的贴标签行为，仅仅是人类的一厢情愿的话，那么接下来沙希达所到的一切事情更像是一种本能。男主的岳父家是一个典型的印度佛教徒家庭，沙希达因为受到肉食的诱惑而到领居家吃鸡肉，当她遇到清真寺就会像母亲一样裹上头巾上前参拜……男主起初不愿意或者说不敢去清真寺内，或许是因为两种截然不同的宗教信仰，让他习惯性地去排斥一种新的文化。这何尝不是我们呢？一旦长大三观就特别难更改，面对三观不合这样的问题，大家都出奇地相信分手就能解决问题。可人类不曾见过一颗恒星的诞生和消亡，可我们就固执地相信这短短几十年里的所见所闻。其实我们大可不必去接受什么，就像这世间有千万种书千万句话，渐渐地丰富了我们原本枯竭的生命。男主纠结于该不该到清真寺里招人，他的女朋友则告诉他，沙希达只是一个6岁的孩子，宗教对她来说有什么意义呢？是啊，我们简简单单地来到这个世界上，等离开时突然发现平添了无数个毫无意义的身份，我承认，沙希达从背后抱住男主的时候，我一个大男人心里像是被温暖到了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2273740173.jpg" alt="沙希达像母亲一样参拜" title="">                </div>                <div class="image-caption">沙希达像母亲一样参拜</div>            </figure><p>&emsp;&emsp;真正揭开小女孩身份的是一场球赛，一场特殊的球赛，一场发生在印度和巴基斯坦间的球赛。这里有一个细节，小女孩的母亲怀孕期间就是在看一场板球比赛。在这场比赛中，印度输掉了比赛，当所有人都一脸失落时，唯独沙希达高兴地手舞足蹈，甚至冲到电视机面前，亲吻巴基斯坦国旗。男主小心翼翼地问小女孩，“巴基斯坦？”。小女孩的确认让男主悲喜交加，喜的是终于知道小女孩的身世，悲的是两国积怨久矣为岳父所不容。事实上两国曾因为流民而引发流血事件，电影中男主岳父仇视巴基斯坦人的原因恰在于此。这让我想到，阿米尔·汗主演的电影PK中，女主嘉谷爱上了一个穆斯林男孩，父母对穆斯林的偏见以及宗教对这段感情的干涉，差点让两个真心相爱的人分开。男主再次遭遇无奈，他前往领事馆希望寻求领事馆的帮助，领事馆以沙希达没有护照为由，拒绝为男主提供帮助，这里导演让我们了解了两国间的冲突到底有多严重，一场动乱导致领事馆暂停营业一个月。男主通过岳父介绍，找到一家旅游中介公司，对方声称需要12万卢比(约合人民币10000多元)，男主的女朋友甚至拿出了准备买房子的钱，可黑心中介转手就把沙希达卖到了妓院，一个6岁的小女孩啊，妓院是什么地方？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2284899606.png" alt="安全感十足的大叔" title="">                </div>                <div class="image-caption">安全感十足的大叔</div>            </figure><p>&emsp;&emsp;电影开始介绍男主时说他学习不好，更不擅长体育运动(摔跤)。妓院里男主一个房间一个房间的找小女孩，当找到小女孩的时候，这个电影突然燃了起来，虽然按照角色设定，男主不应该有这样的身手，可事实上这名印度演员萨尔曼·汗，就是以健身达人的称号闻名于世的，据说他参与演出的电影都会安排裸露上身的戏份，这一次我们就当做主角光环好啦，甚至当看到黑中介在电线上荡秋千时，小女孩那纯真的笑脸，我能想到的只有一句话，“愿你被世界温柔对待”，这样一个可爱的小女孩，我愿意她一直都长不大，因为这个世界并没有那么好，幸运的是，她遇到了善良的猴神大叔。我很想知道，为什么人长大以后，反而更加不惮于勇险恶的用心去猜度别人，这到底是一种成熟，还是一种倒退。你大概不会想到，一个印度人，为了帮助一个萍水相逢的巴基斯坦人，在没有签证的情况下，冒着被当做间谍的风险，偷偷穿过两国边界的防线，只为了送这个小女孩回家，你说他不为博眼球出名，不为做好事谋利，他到底是为了什么？原谅我说句俗气的话，这就是爱啊！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2513104611.jpg" alt="公交车司机的神助攻" title="">                </div>                <div class="image-caption">公交车司机的神助攻</div>            </figure><p>&emsp;&emsp;在穿越巴基斯坦边防线的时候，男主坚持要得到边防战士的批准后再入境，虽然这是一个讲述诚实和信念的励志故事，可我还是想说，遵从某种信念，并不是教条地照本宣科，而是在道德和法律允许的条件下适当变通。为什么要强调道德和法律呢？因为万物皆虚，万事皆座啊，《刺客信条》里刺客的信仰是每一代刺客都在追求的东西，以阿泰尔为例，他年轻时因为所罗门神殿任务的失败，而被降级为新手刺客，在完成刺杀9个圣殿骑士的任务中，他开始变得冷静而沉着，“万物皆虚，万事皆允”的理念开始变得越来越清晰。帕夫常常说他向哈奴曼神保证永远不偷偷摸摸，可他先后躲在清真寺里、车顶逃避警察搜捕，反而是那位伊斯兰教阿訇令人印象深刻，男主说自己不能进清真寺，阿訇说清真寺从来不锁门，所以任何人都可以进去。阿訇送男主一行三人离开后，以伊斯兰教礼仪祝福男主，并询问在印度教中如何表达祝福，随后以印度教礼仪向男主行礼，并煞有介事地问，“哈奴曼神在这里还管用？”。是啊，两个信仰不同的国家，素来相互仇视，可到了人家的地方，居然还要祈求本国的神灵护佑，这是不是有点讽刺呢？其实，宗教并不是要教会我们去排斥什么，而是要学会拥有一颗包容的心，只要一件事情的出发点是善良的，我相信这不会违背任何宗教的教义，佛家讲因果，道家讲无为，儒家讲修身，本质上都是劝人向善，大概爱是人类共同的语言，同样是神共同的语言。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2513104142.jpg" alt="阿訇以印度教礼仪祝福众人" title="">                </div>                <div class="image-caption">阿訇以印度教礼仪祝福众人</div>            </figure><p>&emsp;&emsp;一旦明白了这一点，你就会理解男主接下来所做的事情，比如在电话里向警察撒谎以躲避警察追捕、身为一个印度教徒参拜伊斯兰教神殿、在身上蒙上黑色衣袍伪装成伊斯兰教女子、以伊斯兰教礼仪向帮助他的人表示感谢……所谓“大道至简“，我希望我们相互去借鉴和学习不同领域里的东西，而不是相互对立和排斥彼此。《笑傲江湖》里的五岳剑派，一心想成为能和少林武当抗衡的江湖势力，其实像左冷禅这样的“宗师”级人物，如果可以以华山石壁上魔教长老破除各派剑法的图形为基础，集结各派所长，创造一门新的武功并不是不可能，奈何江湖人物一样逃不过权势的诱惑，想要扫除魔教势力，先破武当，再灭少林，再加上狭隘的门户之见，五岳剑派的辉煌不过是转眼云烟。想想《碧血剑》里大反派玉真子，一人一剑就敢上华山挑战，华山派的衰落可见一斑。如今全世界都被互联网连接在一起，文化间的相互影响越来越深，宗教如是，文化如是，不要以狭隘的民族观去审视我们不懂的文化，就如同不要觉得朋友圈里你不懂的东西Low一样，心态要开放，眼光要长远。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2504182255.jpg" alt="突然觉得生活美好起来" title="">                </div>                <div class="image-caption">突然觉得生活美好起来</div>            </figure><p>&emsp;&emsp;这部电影有太多的意料之中，同样有太多的意料之外。我知道小女孩会和母亲重逢，可我不知道真正打动我的是那一声叔叔；我知道男主会被警方逮捕，可我不知道巴方会想到屈打成招，理由仅仅是因为对方是一个印度人；我知道小女孩并不是哑巴，可我不知道原来说出一句话需要莫大的勇气……这里感谢那个电视台记者，这是一个媒体人的自我修养；感谢那个正直的警官，他没有给他的国家丢脸；感谢那些冲开边防线的巴基斯坦人民，有一种力量叫做民心所向。我希望两个国家可以像电影一样美好，不再有冲突，不再有流血，即使我知道现实中的困难远比电影中的多……可这的确是一群成年人的童话，就像电影最终定格在沙希达和她的猴神大叔拥抱在一起一样，有些美好值得我们去期待，有些东西值得我们去追寻，它们或许是爱，或许是正义，或许是善良，或许是信念，或许是和平，或许是勇敢……我猜中了故事的结尾，依然为这个故事而热泪盈眶，这一切并非是因为我矫情，而是因为我简单，简单到有些东西不必理解得那么深刻，就像我单纯地喜欢着你却不知道为什么一样。好了，这篇影评终于写完啦，晚安！<em>^_^</em></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/p2272195568.jpg" alt="永恒的瞬间" title="">                </div>                <div class="image-caption">永恒的瞬间</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="印度" scheme="http://qinyuanpei.github.io/tags/%E5%8D%B0%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>漫谈应用程序重试策略及其实现</title>
    <link href="http://qinyuanpei.github.io/posts/115524443/"/>
    <id>http://qinyuanpei.github.io/posts/115524443/</id>
    <published>2018-03-31T19:20:54.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;最近随项目组对整个项目进行联调，在联调过程中暴露出各种问题，让我不得不开始反思，怎么样更好地去做好一件事情，譬如说在开发过程中如何保证Web服务的稳定性，在敏捷开发中如何降低文档维护的成本，以及如何提高多环境服务部署的效率等等。我为什么会考虑这些问题呢？通常我们都是在约定好接口后并行开发的，因此在全部接口完成以前，所有的服务都是以渐进的形式进行集成的，那么如何保证服务在集成过程中的稳定性呢？尤其当我们面对开发/测试/生产三套环境时，如何提高服务部署的效率呢？当接口发生变更的时候，如何让每一个人都知悉变化的细节，同时降低人员维护文档的成本呢？这些问题或许和你我无关，甚至这不是一个技术问题，可恰恰这是我们时常忽视的问题，我是我想要写这篇文章的一个重要原因。</p><h1 id="代码越来越复杂"><a href="#代码越来越复杂" class="headerlink" title="代码越来越复杂"></a>代码越来越复杂</h1><p>&emsp;&emsp;面对这种问题，尤其是当你发现，它并不是一个纯粹的技术问题的时候。选择一件你喜欢的事情的去做，固然可以令你开心；而选择一件你不喜欢的事情去做，则可以令你成长。我们每一个人都不是人类学家，可生命中80%的时间都在研究人类。当你接收到一条别人的讯息时，不管这个讯息本身或对或错，在生而为人的角色预设中，你都必须去提供一个响应，甚至是比对方期望更高的一个响应。可是服务器会返回403、404或者500甚至更多的状态码，人生有时候并没有机会去选择Plan B或者Plan C。所以，即使所面临境地再艰难，能不能勇敢地再去尝试一次，说服对方或者选择妥协，就像一段代码被修改得面目全非，可人类本来就是喜欢皆大欢喜的动物，总希望别人都认认真真，而自己则马马虎虎，因为“认真你就输了”，有谁喜欢输呢？</p><p>&emsp;&emsp;好了，现在假设我们有这样一个业务场景，我们需要调用一个WebAPI来获取数据，然后对这些数据做相关处理。这个API接口被设计为返回JSON数据，因此，这个“简单”的业务场景通过以下代码来实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></span><br><span class="line">    text = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    json_data = json.loads(text)</span><br><span class="line">    data = json_data[<span class="string">'raw_data'</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个代码非常简单吧！可是过了十天半个月，每次解析JSON数据的时候随机出现异常，经验丰富的同事建议增加try…except，并在捕获到异常以后返回None。于是，extract()方法被修改为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></span><br><span class="line">    text = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        json_data = json.loads(text)</span><br><span class="line">        data = json_data[<span class="string">'raw_data'</span>]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(<span class="string">"JSON数据无效，重试！"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;修改后的代码，果然比修改前稳定啦，可是负责后续流程的同事开始抱怨，现在代码中出现大量判断返回值是否为None的代码片段，甚至在Web API返回正确结果的情况下，依然会返回None，为此，机智的同事再次修改代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></span><br><span class="line">text = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        json_data = json.loads(text)</span><br><span class="line">        data = json_data[<span class="string">'raw_data'</span>]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(<span class="string">"JSON数据无效，重试！"</span>)</span><br><span class="line">        <span class="keyword">return</span> extract(url)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以预见的是，使用递归可能会导致递归的深度问题，假如调用者传入一个错误的URL，将导致这里无限递归下去，于是考虑限制重试的次数；增加重试次数的限制以后，发现每次重试需要有一个时间间隔……更不必说要在这里增加日志记录，以及在特定场景下需要将异常抛出，由此可见这段简单的代码会变得越来越复杂，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></span><br><span class="line">    text = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        json_data = json.loads(text)</span><br><span class="line">        data = json_data[<span class="string">'raw_data'</span>]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            print(<span class="string">'正在进行第&#123;0&#125;次重试'</span>.format(str(i))</span><br><span class="line">            result = extract(url)</span><br><span class="line">            <span class="keyword">if</span>(result!=<span class="keyword">None</span>):</span><br><span class="line">                <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以注意到，这是一个非常合理的代码演进过程。在这个演进过程中，一段非常简单的代码变得越来越复杂。在我写下这篇文章前，我亲眼目睹了这种复杂的代码，是如何难以复用以及集成的，日志记录、异常处理等流程和正常流程“混合”在一起，甚至你不得不通过函数的返回值来判断是否异常，我一直在想怎么样去解决这些“corner”问题，就像人们一致认为：王垠博士擅长解决的是理想状态下的纯问题。而现实世界中存在着各种各样的“corner”问题，这或许就是学术界与工业界的区别，那么怎么样去更好地解决这一切问题呢？</p><h1 id="应用程序重试策略"><a href="#应用程序重试策略" class="headerlink" title="应用程序重试策略"></a>应用程序重试策略</h1><p>&emsp;&emsp;既然我们可以预见到这些问题的存在，那么，现在让我们正式切入今天这篇博客的主题，即应用程序重试策略。我们在这里以一种渐进式的方式，向大家展示了一个简单的应用程序，是如何因为异常处理变得越来越复杂的，这里我们选择重试，是因为现实世界本身存在不稳定性，即使我们现在有各种自动化工具来替代传统运维。就像有时候你怀疑是代码出现Bug，实际上则是服务器在某一段时间内宕机，当这种事情就发生在你身边的时候，你不得不去着手解决这些“corner”问题，而这恰好是人生的无奈之处。</p><h2 id="Try-Catch-Redo策略"><a href="#Try-Catch-Redo策略" class="headerlink" title="Try-Catch-Redo策略"></a>Try-Catch-Redo策略</h2><p>&emsp;&emsp;这应该是我们最容易想到的一种重试策略了，其思路是对函数的返回值和异常进行处理，其缺点是无法解决重试无效的问题。这里我们将问题简化为对异常进行处理，其基本的代码实现如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Retry</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> result = DoWork();</span><br><span class="line">    <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">      <span class="comment">//重试一次</span></span><br><span class="line">      Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">      DoWork();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(Exception e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//重试一次</span></span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    DoWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以注意到，这种策略最多可以重试一次，因此如果重试后无效，这个策略就变得毫无意义起来，我们需要寻找一种更好的方式。</p><h2 id="Try-Catch-Redo-Retry策略"><a href="#Try-Catch-Redo-Retry策略" class="headerlink" title="Try-Catch-Redo-Retry策略"></a>Try-Catch-Redo-Retry策略</h2><p>&emsp;&emsp;考虑到第一种策略无法解决重试无效的问题，我们在此基础上增加对重试次数以及重试间隔的控制，这就是Try-Catch-Redo-Retry策略，其基本实现如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Retry</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//最大重试次数为5次</span></span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//重试间隔为10秒</span></span><br><span class="line">    <span class="keyword">int</span> interval = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//存储异常的列表</span></span><br><span class="line">    <span class="keyword">var</span> exceptions = <span class="keyword">new</span> List&lt;Exception&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = DoWrok();</span><br><span class="line">            <span class="keyword">if</span>(result) <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--times&lt;=<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AggregateException(exceptions);</span><br><span class="line">            exceptions.Add(ex);</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(interval));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以注意到，通过while(true)结构的确可以增加重试的次数。问题在于：如果不设置合理的循环跳出条件，就有可能造成逻辑上的死循环。尤其当循环体内的逻辑执行时间较长时，会增加用户的等待时间，这看起来亦非良策啊！</p><h2 id="Retry-Builder策略"><a href="#Retry-Builder策略" class="headerlink" title="Retry-Builder策略"></a>Retry-Builder策略</h2><p>&emsp;&emsp;Try-Catch-Redo和Try-Catch-Redo-Retry这两种策略理解起来非常容易，可这两种策略都有一个致命的缺陷，即正常逻辑和重试逻辑重度耦合。我们希望采用一种更优雅的方法，以一种非侵入式的方式给正常逻辑增加重试重试逻辑。需要考虑的是，在确保重试次数和重试间隔可配置的前提下，支持自定义重试源，即可以捕捉一个或多个异常以及对返回值进行处理。在这里推荐三个框架，分别是Java中的<a href="https://docs.spring.io/spring-batch/trunk/reference/html/retry.html" target="_blank" rel="noopener">Spring-Retry</a>和<a href="https://github.com/rholder/guava-retrying" target="_blank" rel="noopener">Guava-Retrying</a>、.NET中的<a href="https://github.com/App-vNext/Polly" target="_blank" rel="noopener">Polly</a>。其中Spring-Retry是基于Throwable类型的重试机制，即针对可捕获异常执行重试策略，并提供相应的回滚策略；而Guava-Retrying提供了更为丰富的重试源定义，譬如多个异常或者多个返回值；而Polly则提供了除重试以外的断路器、超时、隔板隔离、缓存、回退等多种策略。这三者的相似之处在于，通过一个Factory来创建满足不同重试策略的Retryer，然后由Retryer来通过回调来执行重试逻辑，我不喜欢Java中回调函数写法，所以这里以Polly为例：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> retryTwoTimesPolicy = Policy</span><br><span class="line">        .Handle&lt;DivideByZeroException&gt;()</span><br><span class="line">        .Retry(<span class="number">3</span>, (ex, count) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"执行失败! 重试次数 &#123;0&#125;"</span>, count);</span><br><span class="line">            Console.WriteLine(<span class="string">"异常来自 &#123;0&#125;"</span>, ex.GetType().Name);</span><br><span class="line">        &#125;);</span><br><span class="line">    retryTwoTimesPolicy.Execute(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">1</span>/a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (DivideByZeroException e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$"Excuted Failed,Message: (<span class="subst">&#123;e.Message&#125;</span>)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看到，写出一段语义化的代码是多么的重要，因为我相信大家都看懂了。这里的Policy承担了RetryBuilder的角色，它定义了这样一种策略：当程序引发DivideByZeroException时进行重试，重试次数为3次，并且以匿名函数的方式指定了重试时的回调函数；而创建的retryTowTimesPolicy承担了Retryer的角色，它通过Execute()方法来定义要执行的重试逻辑。当3次都重试失败时就会引发DivideByZeroException并在最外层函数中被捕捉到。我经常听到有人说设计模式没有用，我想说因为你从来都不知道什么叫做大道至简，引入无数个中间层是无法让你直接看到代码定义，可计算机领域里有一句名言，“任何一个问题都可以通过引入一个中间层来得到解决”。</p><h2 id="装饰器-AOP策略"><a href="#装饰器-AOP策略" class="headerlink" title="装饰器/AOP策略"></a>装饰器/AOP策略</h2><p>&emsp;&emsp;我从来不惮于将各种重复的工作自动化，这并不是我喜欢在别人面前炫技，而是因为在现实生活中我是一个懒惰的人，甚至是每天早上10点开站会这样的事情，我都愿意让计算机程序去提前通知我做好准备。我并不是一个不懂得自律的人，仅仅是因为我觉得我们可以用这个时间去做些别的事情。AOP是一种可以在运行时期间动态修改代码的技术，我们自然可以想到给所有的函数都加上异常处理和重试的特性，幸运的是Python中的有这样一个第三方库：<a href="http://tenacity.readthedocs.io/en/latest/" target="_blank" rel="noopener">Tenacity</a>，它可以帮助我们优雅地实现重试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry</span><br><span class="line"><span class="keyword">from</span> json.decoder <span class="keyword">import</span> JSONDecodeError</span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(retry=retry_if_exception_type(JSONDecodeError), wait=wait_fixed(5), stop=stop_after_attempt(3))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></span><br><span class="line">    text = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    json_data = json.loads(text)</span><br><span class="line">    data = json_data[<span class="string">'raw_data'</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过@retry这个装饰器函数，我们就可以知道，这里设计的重试策略是：当引发JSONDecodeError这个异常时，每隔5秒中重试一次，最大重试次数为3次。Python中的装饰器，本质上就是高阶函数的概念，修饰器函数对被修饰函数进行“操作”后返回一个新的函数，这个特性在.NET中可以通过委托/匿名方法/lambda来实现，结合Unity、AspectCore等AOP框架，相信大家完全可以将这个特性移植到.NET中来，当语言的差别变得微乎其微的时候，原理的重要性不言而喻。</p><h2 id="重试策略核心理念"><a href="#重试策略核心理念" class="headerlink" title="重试策略核心理念"></a>重试策略核心理念</h2><p>&emsp;&emsp;好了，截止到目前，我们分析了四种不同的重试策略，并且这四种重试策略是随着我们认知的加深而逐渐递进的。那么，通过这四种不同的重试策略，我们能否梳理出一个相对完整的应用程序重试策略呢？换言之，当为应用程序增加重试相关的功能时，我们都需要考虑哪些因素，因为使用这些框架会是非常简单的过程，而更重要的则是我们逐步演进的思考过程。当我们所依赖的是一个不稳定的场景，譬如远程调用、数据加载、数据上传等场景时，或者是在异常场景中需要重试以满足业务稳定性的要求等等，就可以考虑使用重试策略。这里简单地做一下梳理：</p><ul><li>重试逻辑与正常逻辑解耦，整个设计是非侵入式的。</li><li>支持自定义策略，譬如重试次数、重试间隔、重试源、重试超时时间等。</li><li>支持自定义断言，即可以使用Predict<t>或者类似表达式来定义返回值满足的条件。</t></li><li>支持多种异常，即可以针对特定的Exception或者自定义的Exception进行拦截。</li><li>断言实例和异常实例，作为正常逻辑和重试逻辑两者间的媒介进行交互。</li><li>通过命令模式，由Retryer对象完成对正常逻辑的调用，同时在内部封装重试逻辑。</li></ul><h1 id="一个简单的Retry实现"><a href="#一个简单的Retry实现" class="headerlink" title="一个简单的Retry实现"></a>一个简单的Retry实现</h1><p>&emsp;&emsp;好了，熟悉我写作风格的朋友，一定知道我不喜欢空泛地讲一套理论，我更喜欢通过“造轮子”的这种方式，以加深对一个事物或者原理的认识。对于今天这篇文章，我的初衷是想告诉大家如何优雅地去实现Retry，因为在现实中我们总会遇到各种各样的枷锁，这些枷锁约束着你写出糟糕的代码，我们比别人用心甚至更努力，反而常常被认为是有代码洁癖或者是炫技，可不管怎么样，人生是我们自己的，如果没有办法说服别人在项目中使用这些技术，那我们就在项目以外的地方去使用，或者是告诉别人我们有一种相对优雅的设计，如果这个设计恰好对别人有用，对我们来说就是一种莫大的幸福。参考Polly的API风格，这个Retry被我设计成了下面的样子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result = Retry.Default</span><br><span class="line">    .Times(<span class="number">3</span>)</span><br><span class="line">    .Interval(<span class="number">2</span>)</span><br><span class="line">    .Catch&lt;DivideByZeroException&gt;()</span><br><span class="line">    .Reject((count,ex)=&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> message = <span class="keyword">string</span>.format(<span class="string">"第&#123;0&#125;次重试，异常来自:&#123;1&#125;"</span>, count, ex.Message);</span><br><span class="line">        Trace.WriteLine(message);</span><br><span class="line">    &#125;)</span><br><span class="line">    .Execute&lt;<span class="keyword">int</span>&gt;(()=&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> / m;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exeption ex)</span><br><span class="line">&#123;</span><br><span class="line">    Trace.WriteLine(ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我承认它和Polly非常地像，不过我并没有去看Polly是如何实现的，目前它的实现完全来自这篇文章中我们提到的这些策略。我在为它增加了针对返回值的断言支持，通过Return方法来实现，而对异常的支持则是通过Catch方法来实现，除此以外，它支持异步方法调用，我们熟悉的Task/async/await这些API都可以使用。目前它还是一个玩具儿，因为我发现最难的部分，其实是断言或者说自定义表达式的设计，对于线程安全相关的问题，我会在慢慢地去完善它，如果你对它感兴趣的话，可以通过这里访问：<a href="https://github.com/qinyuanpei/RetryIt" target="_blank" rel="noopener">RetryIt</a>。好了，感谢大家关注我的博客，今天这篇先写到这里啦，欢迎大家在博客中留言！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="异常" scheme="http://qinyuanpei.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="重试" scheme="http://qinyuanpei.github.io/tags/%E9%87%8D%E8%AF%95/"/>
    
      <category term="想法" scheme="http://qinyuanpei.github.io/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Unity框架简化应用程序异常处理及日志记录流程</title>
    <link href="http://qinyuanpei.github.io/posts/3291578070/"/>
    <id>http://qinyuanpei.github.io/posts/3291578070/</id>
    <published>2018-03-21T19:35:40.000Z</published>
    <updated>2018-06-04T06:11:50.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;最近公司安排学习项目代码，前后花了一周左右的时间，基本熟悉了项目中的各个模块，感觉项目难度上整体偏中等。这是一个具备完整前端和后端流程的项目，在学习这个项目的过程中，我逐渐发现某些非常有趣的东西，比如在Web API的设计中采用严谨而完善的错误码、使用OAuth和JWT对API资源进行访问控制，在JavaScript中使用修饰器特性来实现日志记录等等，这些东西我会在后续的博客逐步去整理，今天想说的是如何通过Unity框架来简化应用程序异常处理和日志记录流程，而之所以关注这个问题，是因为我发现项目中接近滥用的异常处理，以及我不能忍受的大量重复代码。</p><h1 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h1><p>&emsp;&emsp;由于业务场景上的需要，我们在产品中集成了大量第三方硬件厂商的SDK，这些SDK主要都是由C/C++编写的动态链接库，因此在使用这些SDK的过程中，通常频繁地使用返回值来判断一个方法是否成功被调用，虽然项目上制定了严格的错误码规范，可当我看到大量的Log()方法和业务逻辑混合在一起时，我内心依然是表示拒绝的，甚至我看到在捕获异常以后记录日志然后继续throw异常，这都是些什么鬼操作啊，考虑到我的语言描述得可能不太准确，大家可以从下面两段代码来感受下整体画风：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">LoginTerminal</span>(<span class="params"><span class="keyword">string</span> uid,<span class="keyword">string</span> pwd</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">    Log.BeginLog()</span><br><span class="line">    <span class="keyword">return</span> SDK.Login(uid,pwd)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    log.LogError(ErrorCode.E2301,ex)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TerminalException(ex.Message);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    Log.EndLog()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这是一段相对完整的业务逻辑代码，当然这里都是伪代码实现，这里我比较反感的两个地方是：第一，从头出现到尾的BeginLog()/EndLog()这对方法；第二，在Catch块中记录完日志然后将异常再次抛出。经过我对项目的一番了解，BeginLog()/EndLog()这对方法会在日志中记录某个方法开始执行和结束执行的位置。在方法执行前后插入代码片段，这不就是面向切面编程(AOP)的思想吗？这里记录完日志然后再抛出异常的做法，我个人是不大认同的，因为我觉得拦截异常应该有一个统一的入口，因为异常会继续向上传递，既然如此，为什么我们不能统一地去处理异常和记录日志呢？难道就一定要让Log这个静态类无处不在吗？同样地，我们注意到项目还会有下面这样的代码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessTerminal</span>(<span class="params"><span class="keyword">object</span> sender,ProcessEventArgs args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Log.BeginLog();</span><br><span class="line">        <span class="keyword">var</span> terminal = (Termainal)sender;</span><br><span class="line">        <span class="keyword">var</span> result = terminal.Process(args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        Log.EndLog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这种代码看起来不再关注异常，可和第一段一样，从头出现到尾的BeginLog()/EndLog()简直不能忍，而且这里的try…finally结构难免让人想起using的语法糖，那么这样是不是可以考虑让这个Log拥有类似的结构，换言之，我们总不能一直都在每一个方法里，重复写BeginLog()/EndLog()这两个方法吧，既然EndLog()方法总是在finally块里被执行，那为什么不考虑把它放到Dispose()方法里(前提是有一个结构实现IDispose接口)。你问我是不是有代码洁癖啊？我真的没有，我就是懒，不喜欢重复做一件事情。所谓”管中窥豹，可见一斑”，大家可以想象整个项目会是什么样子。</p><p>&emsp;&emsp;好了，为了避免让自己写这种糟糕的代码，我决心使用Unity框架来简化下这里的异常处理和日志记录流程，一个有追求的程序，如果可以交给自动化工具去做的事情，为什么要一次又一次地重复去写呢？我们可以吐槽一段代码写得有多糟糕，可我们所做的任何努力，都是为了让自己不变成这个样子。Unity框架提供的AOP，即面向切面编程，不就可以做这样的事情吗？所以，能动手的就直接动手，君子有所为有所不为，不要重复自己，</p><h1 id="Unity框架与AOP"><a href="#Unity框架与AOP" class="headerlink" title="Unity框架与AOP"></a>Unity框架与AOP</h1><p>&emsp;&emsp;好啦，交待完故事背景，今天的主角终于可以登场啦！经常关注我博客的朋友，一定知道我个人比较喜欢IoC/AOP这类所谓的”奇技淫巧”，就在今天我还在和一位同事在讨论Ioc，这位同事认为Ioc增加了代码的复杂性，不认为Ioc会为项目带来明显的便利性。其实我相信大道至简，任何框架对我们而言都是高度抽象的，可正是因为有了这些抽象的层次，我们渐渐学会了关注核心的东西。这里提到了Ioc，即控制反转，或者我们可以称之为依赖注入，那么Unity框架就是.NET下众多依赖注入框架之一，这里称之为Unity框架，主要是避免和跨平台游戏引擎Unity产生混淆，以下全部称之为Unity框架。Unity框架中提供了核心的依赖注入相关的接口，而微软的企业最佳实践库中为Unity扩展出了AOP相关的功能。除此以外，Spring.NET、Aspect.Core、AspectF等都是.NET下的AOP方案。那么在今天的故事中，我们遇到了的一个场景是在指定方法执行前、后插入代码片段，这是面向切面编程(AOP)的基本思想，为此，我们考虑使用Unity框架来简化应用程序中异常处理及日志记录流程。</p><h2 id="Unity中的三种拦截器"><a href="#Unity中的三种拦截器" class="headerlink" title="Unity中的三种拦截器"></a>Unity中的三种拦截器</h2><p>&emsp;&emsp;Unity中提供了三种典型的拦截器，为了选择一种合适的拦截器来实现我们的功能，我们首先来了解下这三种不同的拦截器各自的应用场景：</p><ul><li>TransparentProxyInterceptor：即透明代理拦截器，基于.NET Remoting 技术实现代理，它可以拦截对象的所有函数，缺点是被拦截对象必须继承自MarshalByRefObject。</li><li>InterfaceInterceptor：顾名思义，即接口拦截器，仅拦截指定接口，显然只要目标类型实现了指定接口就可以拦截。C#不支持多继承，选择这种方式对代码的影响最小。</li><li>VirtualMethodInterceptor：顾名思义，即虚方法拦截器，仅拦截虚方法，这个对目标类型的要求就非常高啦，一般我们不会考虑这种方式。</li></ul><p>对Unity框架而言，不管我们使用哪一种拦截器，我们都需要通过UnityContainer这个容器来为目标类型注入拦截器，这样Unity框架会帮助我们生成代理对象，我们只要在使用代理对象的时候，这些拦截器才会真正工作。博主曾经以为定义好下面这些Handler就可以了，简直是图样图森破。好了，一个基本的代码流程如下，请不要问我配置文件怎么配，我真的不喜欢配置文件，搞得跟某配置狂魔语言似的，反正这些配置文件这次记住了下次还是会忘的，可下面这几行代码是不会轻易忘记的啊：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="keyword">new</span> UnityContainer().AddNewExtension&lt;Interception&gt;().RegisterType&lt;IBussiness, Bussiness&gt;();</span><br><span class="line">container.Configure&lt;Interception&gt;().SetInterceptorFor&lt;IBussiness&gt;(<span class="keyword">new</span> InterfaceInterceptor());</span><br><span class="line"><span class="keyword">var</span> bussiness = container.Resolve&lt;IBussiness&gt;();</span><br></pre></td></tr></table></figure></p><p>注意，这里不要直接从Github或者Nuget上下载Unity框架，因为最新版的Unity我实在是不会用啊！:joy: 我喜欢开箱即用的产品，我愿意钻研啊，可DeadLine永远会有终点！<br>我们需要从微软企业最佳实践库中<a href="https://www.microsoft.com/en-us/download/details.aspx?id=38789" target="_blank" rel="noopener">下载</a>以下动态链接库：</p><ul><li>CommonServiceLocator.dll</li><li>Microsoft.Practices.Unity.Configuration.dll</li><li>Microsoft.Practices.Unity.dll</li><li>Microsoft.Practices.Unity.Interception.Configuration.dll</li><li>Microsoft.Practices.Unity.Interception.dll<br>考虑到我们这里需要实现两种功能，针对异常的异常处理流程，以及正常的日志记录流程，为此我们将实现ExceptionHandler和LogHandler两个组件。下面我们来一起了解这两个组件的实现过程，这里博主选择了最简单的ICallHandler接口，而非更一般的IInterceptionBehavior接口，主要希望让这个过程更简单些，同时实现在方法粒度上的可控，即我们可以选择性的去拦截某一个方法，而非全部的方法，因为在实际业务中并非所有的方法都需要拦截。</li></ul><h2 id="LogHandler的实现"><a href="#LogHandler的实现" class="headerlink" title="LogHandler的实现"></a>LogHandler的实现</h2><p>&emsp;&emsp;LogHandler主要用于记录日志，所以我们需要记录方法的名字，方法的参数以及方法执行的结果，甚至是是否引发异常，这些功能在AOP中是相对基础的功能，Unity框架为我们提供了这些基础设施，我们只要就可以获取到这些信息，然后将其记录到日志中即可。这里的代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogHandler</span> : <span class="title">ICallHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ICallHandler.Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    IMethodReturn ICallHandler.Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> methodInfo = input.MethodBase;</span><br><span class="line">        <span class="keyword">var</span> methodName = methodInfo.Name;</span><br><span class="line">        Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"----------开始调用&#123;0&#125;----------"</span>, methodName));</span><br><span class="line">        <span class="keyword">var</span> parameters = methodInfo.GetParameters();</span><br><span class="line">        <span class="keyword">var</span> arguments = input.Arguments;</span><br><span class="line">        <span class="keyword">var</span> logInfo = parameters.Select(e =&gt; <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;:&#123;1&#125;"</span>, e.Name, arguments[e.Position]));</span><br><span class="line">        Logger.Log(<span class="string">"传入的参数为:"</span> + <span class="keyword">string</span>.Join(<span class="string">","</span>, logInfo.ToArray()));</span><br><span class="line">        <span class="keyword">var</span> result = getNext()(input, getNext);</span><br><span class="line">        <span class="keyword">if</span> (result.Exception != <span class="literal">null</span>)</span><br><span class="line">            Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"调用异常:&#123;0&#125;-&#123;1&#125;"</span>, result.Exception.Message, result.Exception.StackTrace));</span><br><span class="line">        Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"调用&#123;0&#125;的结果为：&#123;1&#125;"</span>, methodName, result.ReturnValue));</span><br><span class="line">        Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"----------结束调用&#123;0&#125;----------"</span>, methodName));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了让这个Handler更好用一些，我们希望它可以以Attribute的方式出现在方法上面，这样被标记过的方法就会被Unity框架拦截，所以我们需要一个继承自Attribute类的东西，知道我为什么不喜欢配置文件吗？因为我有Attribute啊！幸运的是Unity框架为我们提供了这样一个基类：HandlerAttribute，由此下面的代码可以这样写：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method,AllowMultiple = true)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">LogHandlerAttribute</span> : <span class="title">HandlerAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ICallHandler <span class="title">CreateHandler</span>(<span class="params">IUnityContainer container</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ExceptionHandler的实现"><a href="#ExceptionHandler的实现" class="headerlink" title="ExceptionHandler的实现"></a>ExceptionHandler的实现</h2><p>&emsp;&emsp;对于ExceptionHandler来说，它相比LogHandler增加的功能在于，它需要处理异常，按照目前项目的异常处理习惯，这种和硬件相关的方法都会被定义为一个ErrorCode，为此我们的ExceptionHandler类中需要增加一个ErrorCode类型的成员，这是一个枚举类型。这里的代码实现如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExceptionHandler</span> : <span class="title">ICallHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ICallHandler.Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ErrorCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    IMethodReturn ICallHandler.Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> methodInfo = input.MethodBase;</span><br><span class="line">        <span class="keyword">var</span> methodName = methodInfo.Name;</span><br><span class="line">        Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"--------------方法&#123;0&#125;执行开始--------------"</span>, methodName));</span><br><span class="line">        <span class="keyword">var</span> parameters = methodInfo.GetParameters();</span><br><span class="line">        <span class="keyword">var</span> arguments = input.Arguments;</span><br><span class="line">        <span class="keyword">var</span> logInfo = parameters.Select(e =&gt; <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;:&#123;1&#125;"</span>, e.Name, arguments[e.Position]));</span><br><span class="line">        Logger.Log(<span class="string">"传入的参数为:"</span> + <span class="keyword">string</span>.Join(<span class="string">","</span>, logInfo.ToArray()));</span><br><span class="line">        <span class="keyword">var</span> result = getNext()(input, getNext);</span><br><span class="line">        <span class="keyword">if</span> (result.Exception != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"Error Code is &#123;0&#125;"</span>, ErrorCode));</span><br><span class="line">            result.Exception = <span class="literal">null</span>;</span><br><span class="line">            Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"--------------方法&#123;0&#125;执行结束--------------"</span>, methodName));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(ErrorCode);</span><br><span class="line">        &#125;</span><br><span class="line">        Logger.Log(<span class="keyword">string</span>.Format(<span class="string">"--------------方法&#123;0&#125;执行结束--------------"</span>, methodName));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以注意到ExceptionHandler相比LogHandler的变化，主要发生在异常处理这部分，如你所愿，我在拦截到异常以后抛出了一个对应ErrorCode的异常，虽然我不赞同这种做法，但为了尊重现有项目的编程风格，我只能写有这样一行看起来非常拙劣的代码，我真的没有代码洁癖，我仅仅是觉得它还不够好，就像我觉得自己还不够好一样，同样，它需要定义一个对应的Attribute类，这样我们可以更加自由地使用这些特性：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method,AllowMultiple = true)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">LogHandlerAttribute</span> : <span class="title">HandlerAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ICallHandler <span class="title">CreateHandler</span>(<span class="params">IUnityContainer container</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;好了，现在我们可以来看，如何使用这篇文章中定义的两个组件：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="keyword">new</span> UnityContainer().AddNewExtension&lt;Interception&gt;().RegisterType&lt;IBussiness, Bussiness&gt;();</span><br><span class="line">container.Configure&lt;Interception&gt;().SetInterceptorFor&lt;IBussiness&gt;(<span class="keyword">new</span> InterfaceInterceptor());</span><br><span class="line"><span class="keyword">var</span> bussiness = container.Resolve&lt;IBussiness&gt;();</span><br><span class="line"><span class="keyword">var</span> sum = bussiness.Add(<span class="number">12</span>,<span class="number">23</span>);</span><br><span class="line">Console.WriteLine(sum);</span><br><span class="line"><span class="keyword">var</span> div = bussiness.Divide(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">Console.WriteLine(div)</span><br></pre></td></tr></table></figure></p><p>IBussiness接口及其实现类Bussiness定义如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBussiness</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Divide</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Bussiness : MarshalByRefObject, IBussiness</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">LogHandler</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ExceptionHandler(ErrorCode = <span class="meta-string">"E2303"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Divide</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，现在我们来看一下结果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img-blog.csdn.net/20180320235018714" alt="使用AOP简化后的异常处理和日志记录流程" title="">                </div>                <div class="image-caption">使用AOP简化后的异常处理和日志记录流程</div>            </figure></p><p>&emsp;&emsp;我们为此付出的代价是什么？第一，要有一个接口，写接口难道还有疑问吗？第二，要添加Attribute到指定方法上面，我保证这点时间足够你写好几遍重复代码了。第三，需要依赖注入机制，这个可能是到目前为止最大的影响，因为有了依赖注入以后，对象的实例化都交给了Unity框架，看起来我们好像被束缚了手脚，不能再任性地new一个对象实例出来，可这不正是依赖注入的精髓所在吗？我们就是需要Unity框架，来帮助我们管理这些模块间的依赖关系及其生命周期，如果你觉得这点代码不能接受，抱歉，任何依赖注入框架拯救不了你！</p><p>&emsp;&emsp;今天这篇文章，我们从一个实际项目的背景出发，引出使用Unity框架来简化异常处理和日志记录流程这一想法，在正式实践这一想法前，我们首先了解了Unity框架中提供的三种拦截器及其各自优劣，在此基础上我们实现了LogHandler和ExceptionHandler两个组件，并展示了如何使用这两个组件，探讨使用整个AOP机制对现有项目的影响有多大，以及为什么我们需要Unity框架等问题，框架固然重要，了解为什么使用框架则更重要！好啦，这就是今天这篇文章的内容啦，再次谢谢大家关注我的博客，各位晚安！:smile:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="AOP" scheme="http://qinyuanpei.github.io/tags/AOP/"/>
    
      <category term="异常" scheme="http://qinyuanpei.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="日志" scheme="http://qinyuanpei.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>基于新浪微博的男女性择偶观数据分析(下)</title>
    <link href="http://qinyuanpei.github.io/posts/3083474169/"/>
    <id>http://qinyuanpei.github.io/posts/3083474169/</id>
    <published>2018-03-17T15:28:40.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客。我的博客地址是：<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。对于今天这篇文章的主题，相信经常关注我博客的朋友一定不会陌生。因为在2017年年底的时候，我曾以此为题写作了一篇文章：<a href="https://qinyuanpei.github.io/posts/1386017461/">基于新浪微博的男女择偶观数据分析(上)</a>。这篇文章记录了我当时脑海中闪烁着的细微想法，即当你发现一件事物背后是由哲学或者心理学这类玄奥的科学在驱动的时候，不妨考虑使用数学的思维来让一切因素数量化，我想这是最初数据分析让我感兴趣的一个原因。因为当时对文本的处理了解得非常粗浅，所以在第一次写作这篇文章的时候，实际的工作不过是在分词后绘制词云而已。等到我完成对微信好友信息的数据分析以后，我意识到微博这里其实可以继续发掘。关于微信好友信息的数据分析，可以参考这篇文章：<a href="https://qinyuanpei.github.io/posts/2805694118/">基于Python实现的微信好友数据分析</a>。在这样的想法促使下，便有了今天这篇文章，因为工作关系一直没有时间及时整理出来，希望这篇文章可以带给大家一点启示，尤其是在短文本分类方面，这样我就会非常开心啦！:slightly_smiling_face:</p><h1 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h1><p>&emsp;&emsp;关于故事背景，我在 <a href="https://qinyuanpei.github.io/posts/1386017461/">基于新浪微博的男女择偶观数据分析(上)</a> 这篇文章中说得非常清楚啦。起因就是我想知道，男性和女性在选择伴侣的时候，到底更为关注哪些因素？在对微信好友信息进行数据分析的时候，我们可以非常直接地确定，譬如性别、签名、头像、位置这四个不同的维度，这是因为我们处理的是结构化的数据。什么是结构化的数据呢？一个非常直观的认识是，这些数据可以按照二维表的方式组织起来。可对于微博这样一个无结构的文本数据类型，我们除了对词频、词性等因素做常规统计分析以外，好像完全找不到一个合理有效的方案，因为我们很容易就明白一件事情，即：<strong>在短短的140个字符中，人类语言的多样性被放大到淋漓尽致</strong> 。为了将种种离散的信息收敛在一个统一的结构里，我们必须为这些文本构建一种模型，并努力使这种模型可以量化和计算。我们通过词云对微博进行可视化分析，更多是针对词频的一种分析方法，这种方法虽然可以帮助我们找出关键字，可是因为最初写作这篇文章时，对数据分析领域相关知识知之甚少，而且在分析的过程中没有考虑停用词，所以我认为在文本分类或者是主题提取层面上，我们都需要一种更好的方法。</p><h1 id="常见的技术方法"><a href="#常见的技术方法" class="headerlink" title="常见的技术方法"></a>常见的技术方法</h1><p>&emsp;&emsp;这篇文章涉及的领域称为<strong>文本分类</strong>或者<strong>主题提取</strong>，而针对微博、短信、评论等这类短文本的分类，则被称为<strong>短文本分类</strong>。为什么要进行文本分类呢？第一，<strong>提取出潜在主题以后可以帮助我们做进一步的分析</strong>。譬如博主这里想要从相亲类微博中分析男性和女性的择偶观，首先要解决的就是主题建模问题，因为在择偶过程中要考虑的因素会非常多，我们到底要选取哪些因素来分析呢？这些因素在特定领域中被称为特征，所以文本分类的过程伴随着特征提取。第二，<strong>短文本数据通常只有一个主题，看起来这是在简化我们的分析过程，实则传统的基于文档的主题模型算法在这里难以适用。</strong>因为这类主题模型算法都假定一篇文档中含有多个主题，而我们分析的是群体现象，这种个体上的差异必须设法将其统一于一体，比如美元和$属于同一个主题，我们需要一种策略来对其进行整合。</p><p>&emsp;&emsp;传统主题提取模型通常由<strong>文本预处理</strong>、<strong>文本向量化</strong>、<strong>主题挖掘</strong>和<strong>主题表示</strong>等多个流程组成，每个流程都会有多种处理方法，不同的组合方法会产生不同的建模结果。目前，人们在传统主题提取模型的基础上，发展起了以<strong>CNN</strong>和<strong>RNN</strong>为代表的深度学习方法，在这里我们依然关注传统主题提取模型，因为这个领域对博主而言是个陌生的领域，这里我们更多的是关注传统主题提取模型。按照传统主题提取模型，文本分类问题被拆分为<strong>特征工程</strong>和<strong>分类器</strong>两个部分，其中，<strong>特征工程的作用是将文本转化为计算机可以理解的格式，并提供强特征表达能力，即特征信息可以用以分类，而分类器基本上是统计学相关的内容，其作用是根据特征对数据进行分类</strong>。下面来简单介绍下常见的技术方法。</p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>&emsp;&emsp;特征工程覆盖了<strong>文本预处理</strong>、<strong>特征提取</strong>和<strong>文本表示</strong>三个流程。文本预处理通常指<strong>分词</strong>和<strong>去除停用词</strong>这两个过程，可以说分词是自然语言处理的基本前提。特征提取实际上囊括两个部分，即特征项的选择和特征项权重的计算。选择特征项的基本思路是：根据某个评价指标对原始数据进行排序，然后从中选择分数最高的评价指标，同时过滤掉其余的评价指标。通常可以选择的评价指标有<strong>文档频率</strong>、<strong>互信息</strong>、<strong>信息增益</strong>等，而特征权重的计算主要是经典的<strong>TF-IDF</strong>算法及其扩展算法。文本表示是指将文本预处理后转化为计算机可以理解的格式，是决定分类效果最重要的部分。传统做法是使用<strong>词袋模型(BOW)</strong>或者<strong>向量空间模型(VSM)</strong>，比如<strong>Word2Vec</strong>就是一个将词语转化为向量的相关项目。因为向量模型完全忽视文本的上下文，所以为了弥补这种技术上的不足，业界同时使用基于语义的文本表示方法，比如常见的<strong>LDA</strong>语义模型。</p><h2 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h2><p>&emsp;&emsp;分类器主要是统计学里的分类方法，基本上大部分的机器学习方法都在文本分类领域有所应用，比如最常见的<strong>朴素贝叶斯算法(Naive Bayes)</strong>、<strong>KNN</strong>、<strong>支持向量机(SVM)</strong>、<strong>最大熵(MaxEnt)</strong>、<strong>决策树</strong>和<strong>神经网络</strong>等等。简单来说，假设我们所有的数据样本可以划分为训练集和测试集。首先，分类器可以在训练集上执行分类算法以生成分类模型；其次，分类器可以通过分类模型对测试集进行预测以生成预测结果；最后，分类器可以计算出相关的评价指标以评估分类的效果。这里最常用的两个评价指标是<strong>准确率</strong>和<strong>召回率</strong>，前者关注的是数据的准确性，后者关注的是数据的全面性。</p><h1 id="TF-IDF与朴素贝叶斯"><a href="#TF-IDF与朴素贝叶斯" class="headerlink" title="TF-IDF与朴素贝叶斯"></a>TF-IDF与朴素贝叶斯</h1><p>&emsp;&emsp;<strong>TF-IDF</strong>(term frequency–inverse document frequency)是一种被用于信息检索与数据挖掘的统计学方法，常常被用来评估某个字词对于一个文件集或者是一个语料库中的一份文档的重要程度。在特征工程这里我们提到，特征工程中主要通过特征权重来对数据进行排序和分类，因此<strong>TF-IDF</strong>本质上是一种加权技术。<strong>TF-IDF</strong>的主要思想是：字词的重要性与它在文件中出现的次数成正比上升，与此同时与它在语料库中出现的频率成反比下降。这句话是什么意思呢？如果某个词或者短语在一篇文章中出现的频率(即<strong>TF</strong>)较高，并且在其它文章中出现的频率(即<strong>IDF</strong>)较低，那么就可以人为这个词或者短语可以作为一个特征，具备较好的类别区分能力，因此适合用来作为分类的标准。<strong>TF-IDF</strong>实际上是TF * IDF，即TF(term frequency，词频)与IDF(inverse document frequency，逆文档频率)的乘积，具体我们通过下面的公式来理解：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180321003843372-tf.png" alt="term frequency，词频" title="">                </div>                <div class="image-caption">term frequency，词频</div>            </figure><br>&emsp;&emsp;显然，这里的TF表示某一词条在文档中出现的频率。再看IDF:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/2018032100393444-idf.png" alt="inverse document frequency，逆文档频率" title="">                </div>                <div class="image-caption">inverse document frequency，逆文档频率</div>            </figure><br>&emsp;&emsp;这里的D表示语料库中文档的数目，而分母表示的是含有指定词的文档的数目，这里两者求商后取对数即可得到IDF。需要注意的是，当该词语不在语料库中时，理论上分母会变成0，这将导致计算无法继续下去，因此为了修正这一错误，我们在分母上加1，这样就可以得到IDF更为一般的计算公式。按照这样的思路，我们将两段文本分完词以后，分别计算每一个词的tf-idf并按照tf-idf对其进行排序，然后选取前N个元素作为其关键字，这样我们就获得了两个N维向量，按照向量理论的相关知识，两个向量间的夹角越小，其相关性越显著，这就是文本相似度判断的常规做法，在这个过程中，我们覆盖到了<strong>文本预处理</strong>、<strong>特征提取</strong>和<strong>文本表示</strong>三个过程，相信大家会对这个过程有更好的理解。</p><p>&emsp;&emsp;好了，那么什么是特征呢？这里计算出来的tf-idf实际上就是一组特征，这个特征是上下文无关、完全基于频率分析的结果，现在这些结果都是计算机可以处理的数值类型，所以特征工程要做的事情，就是从这些数值中分析出某一种规律出来。譬如，我们通过分析大量的气象资料，认为明天有80%的概率会下雨，那么此时下雨的概率0.8就可以作为一个特征值，在排除干扰因素的影响以后，我们可以做一个简单的分类，如果下雨的概率超过0.8即认为明天会下雨，反之则不会下雨。这是一个接近理想的二值化模型，在数学中我们有一种概率分布模型称为0-1分布，即一件事情只有两个可能，如果该事件会发生的概率为p，则该事件不会发生的概率为1-p。如果所有的问题都可以简化到这种程度，我相信我们会觉得这个世界枯燥无比，因为一切非黑即白、非此即彼，这会是我们所希望的世界的样子吗？<br>&emsp;&emsp;为什么在这里我要提到概率呢？因为这和我们下面要提到的朴素贝叶斯有关。事实上，朴素贝叶斯的理论基础，正是我们所熟悉的条件概率。根据概率的相关知识，我们有以下公式，即全概率公式：P(A|B) = P(AB)/P(B)。我们对A和B进行交换，同理可得：P(B|A) = P(A/B)/P(A)。由此我们即得到了贝叶斯公式：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180323235155564.png" alt="贝叶斯公式" title="">                </div>                <div class="image-caption">贝叶斯公式</div>            </figure><br>&emsp;&emsp;所以，朴素贝叶斯本质上是一种基于概率理论的分类算法。我们知道条件概率成立的前提是各个事件都是独立的，因此在朴素贝叶斯算法中假设所有特征间都是独立的，可当我们逐渐地了解这个世界，就会明白这个世界并不是非黑即白、非此即彼的，甚至一件事情会受到来自方方面面的因素影响，就像我们从前学习物理的时候喜欢用控制变量法一样，总有一天你会明白当时的想法太天真。朴素贝叶斯算法中的“朴素”，通常被翻译为Naive，而这个词就是表示天真的意思，这正是朴素贝叶斯的名称由来，它简单粗暴地认为各个特征间是相互独立的，有人认为这种假设是相当不严谨的，所以相当排斥这种分类的理论，所幸朴素贝叶斯在实际应用中分类效果良好，尤其是在解决垃圾邮件过滤这类问题上，所以到今天为止，朴素贝叶斯依然是一个相当经典的分类算法，它是一个根据给定特性/属性，基于条件概率为样本赋予某个类别标签的模型。</p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>&emsp;&emsp;好了，讲述这些理论知识实在是一件苦差事，因为让读者了解一套新的知识，远远比让自己了解一套新的知识容易，所以在描述这些理论的时候，我努力地避免给大家留下晦涩深奥地印象，可这样难免会让读者觉得我不太专业。可是，谁让我们生活在一个被无数前辈开垦过地世界里呢？作为一个资深的“调包侠”，这些理论我们能理解多少算多少，最终我们需要的只是一个库而已，所以在正式进入下面的内容时，我们首先来梳理侠整体数据分析的思路，这样我们就能对整个过程有一个相对感性的认识了。关于如何从新浪微博抓取数据，这个我们在<a href="https://qinyuanpei.github.io/posts/1386017461/">上篇</a>有详细的介绍，这里不再重复阐述，所有数据我们都存储在数据库里，下面的图示不再展示关于数据库的细节：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180324005637219.png" alt="特征分析流程图" title="">                </div>                <div class="image-caption">特征分析流程图</div>            </figure><br>&emsp;&emsp;简单来讲，这是一个有监督的、使用二元分类的特征提取过程。这里的语料库是由人工进行编制的文本资料，语料库的好坏将直接影响到分类的效果。比如说，我们希望提取的特征是陕西省的地理信息，那么我们就需要准备一个，由陕西省所辖的所有地级市组成的文本文件，这里为了方便后续处理，我们建议每行存放一个短文本信息。</p><p>&emsp;&emsp;接下来，我们会从数据库中读取所有的数据，然后进行预处理操作，这里的预处理是指分词和去除停用词，停用词表是从网络上下载的，然后根据我们自己的需要再在基础上进行添加，我们会选取前20个词语作为关键词，这里使用了结巴分词的相关接口，其算法原理正是tf-idf。我们会使用这20个关键词，和语料库中每一个主题下的内容进行比较，这里的相似度由SnowNLP提供支持，其计算结果是一个20维的向量，我们对向量进行归一化后，如果其向量中所有维度的值的最大值&gt;=0.95，则认为该文本和这一主题相关，因此该主题的权重会增加1，否则会继续计算下一个文本的相似度。</p><p>&emsp;&emsp;我们汇总所有主题的权重，即可统计出各个主题出现的频率。比如我们这里关注A、B、C三个主题，而经过计算这三个主题各自出现的频率为0.1、0.8和0.1，所以我们这里可以理解为：这里有80%的把握认为文本和B主题有关，由此我们选取出了分类的特征，这里我们使用一个元组来表示特征，其表示为([0.1,0.8,0.1],”B”)。依次类推，我们就获得了全部的特征信息。接下来，我们使用nltk中提供的朴素贝叶斯分类器对内容进行分类，训练集和测试集合各占50%，最终通过准确度来评估整个分类的效果。</p><h2 id="特征分析"><a href="#特征分析" class="headerlink" title="特征分析"></a>特征分析</h2><p>&emsp;&emsp;特征分析的难点主要在特征的提取，在这里我们通过不同主题的频率来选取特征：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildFeatures</span><span class="params">(sentence,document)</span>:</span></span><br><span class="line">    tokens = jieba.analyse.extract_tags(sentence)</span><br><span class="line">    tokens = list(filter(<span class="keyword">lambda</span> x:x.strip() <span class="keyword">not</span> <span class="keyword">in</span> stopwords, tokens))</span><br><span class="line">    features = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (subject,contents) <span class="keyword">in</span> document.items():</span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">            <span class="keyword">if</span>(similarText(tokens,content)):</span><br><span class="line">                <span class="keyword">if</span>(subject <span class="keyword">in</span> features):</span><br><span class="line">                    features[subject]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    features[subject]=<span class="number">1</span></span><br><span class="line">    total = sum(features.values())</span><br><span class="line">    <span class="keyword">for</span> subject <span class="keyword">in</span> features.keys():</span><br><span class="line">        features[subject] = features[subject] / total</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 特征归一化</span></span><br><span class="line">    <span class="keyword">for</span> subject <span class="keyword">in</span> subjects:</span><br><span class="line">        <span class="keyword">if</span>(subject <span class="keyword">not</span> <span class="keyword">in</span> features.keys()):</span><br><span class="line">            features[subject] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测结果</span></span><br><span class="line">    max_value = max(features.values())</span><br><span class="line">    suggest_subject = <span class="string">' '</span></span><br><span class="line">    <span class="keyword">for</span> (key,value) <span class="keyword">in</span> features.items():</span><br><span class="line">        <span class="keyword">if</span>(value == max_value):</span><br><span class="line">            suggest_subject = key</span><br><span class="line">    <span class="keyword">return</span> features, suggest_subject</span><br></pre></td></tr></table></figure></p><p>其中，stopwords我们从一个指定文件中读取：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopwords = open(<span class="string">'stopwords.txt'</span>,<span class="string">'rt'</span>,encoding=<span class="string">'utf-8'</span>).readlines()</span><br></pre></td></tr></table></figure></p><p>这里有一个计算句子和主题相似度的方法similarText()，其定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本相似度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">similarText</span><span class="params">(tokens,content)</span>:</span></span><br><span class="line">    snow = SnowNLP(tokens)</span><br><span class="line">    similar = snow.sim(content)</span><br><span class="line">    norm = math.sqrt(sum(map(<span class="keyword">lambda</span> x:x*x,similar)))</span><br><span class="line">    <span class="keyword">if</span>(norm == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    similar = map(<span class="keyword">lambda</span> x:x/norm,similar)</span><br><span class="line">    <span class="keyword">return</span> max(similar)&gt;=<span class="number">0.95</span></span><br></pre></td></tr></table></figure></p><p>我们通过下面的代码来构建特征，以及使用朴素贝叶斯分类器进行分类，核心代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseFeatures</span><span class="params">()</span>:</span></span><br><span class="line">    rows = loadData()</span><br><span class="line">    document = loadDocument(subjects)</span><br><span class="line">    features = [buildFeatures(row[<span class="number">0</span>],document) <span class="keyword">for</span> row <span class="keyword">in</span> rows]</span><br><span class="line">    length = len(features)</span><br><span class="line">    print(<span class="string">'数据集: '</span> + str(length))</span><br><span class="line">    cut_length = int(length * <span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">'训练集: '</span> + str(cut_length))</span><br><span class="line">    train_set = features[<span class="number">0</span>:cut_length]</span><br><span class="line">    print(<span class="string">'测试集: '</span> + str(length - cut_length))</span><br><span class="line">    test_set = features[cut_length:]</span><br><span class="line">    classifier = nltk.NaiveBayesClassifier.train(train_set)</span><br><span class="line">    train_accuracy = nltk.classify.accuracy(classifier,train_set)</span><br><span class="line">    print(<span class="string">'准确度: '</span> + str(train_accuracy))</span><br><span class="line"></span><br><span class="line">    counts = Counter(map(<span class="keyword">lambda</span> x: x[<span class="number">1</span>],test_set))</span><br><span class="line">    <span class="keyword">for</span> key, count <span class="keyword">in</span> counts.items():</span><br><span class="line">        freq = count/len(test_set)</span><br><span class="line">        print(<span class="string">"主题&lt;&#123;0&#125;&gt;: &#123;1&#125;"</span>.format(key,freq))</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;下面是特征提取相关的结果，因为最近对语料库进行了调整，所以准确度只有92%，用一位前辈的话说，数据分析就像炼丹，在结果没有出来以前，没有人知道答案会是什么。这里使用的是nltk内置的朴素贝叶斯分类器，而nltk是一个自然语言处理相关的库，感兴趣的朋友可以自行了解，这里推荐一本书：<a href="https://book.douban.com/subject/27057666/" target="_blank" rel="noopener">《NLTK基础教程(用NLTK和Python库构建机器学习应用)》</a>。下图中展示了各个主题在整个微博文本中所占的比重：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/20180324205251158.jpg" alt="特征提取及其分类效果" title="">                </div>                <div class="image-caption">特征提取及其分类效果</div>            </figure><h2 id="年龄分布"><a href="#年龄分布" class="headerlink" title="年龄分布"></a>年龄分布</h2><p>&emsp;&emsp;对于男女性的年龄分布，我们通过正则来提取微博中年龄相关的数值，然后统计不同年龄出现的频数，并将其绘制为柱形统计图，相关代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseAge</span><span class="params">()</span>:</span> </span><br><span class="line">    ages = []</span><br><span class="line">    rows = loadData()</span><br><span class="line">    pattern = re.compile(<span class="string">r'\d&#123;2&#125;\年|\d&#123;2&#125;\岁'</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        matches = pattern.findall(text)</span><br><span class="line">        <span class="keyword">if</span>(len(matches)&gt;<span class="number">0</span>):</span><br><span class="line">            match = matches[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">u'年'</span> <span class="keyword">in</span> match):</span><br><span class="line">                now = datetime.datetime.now().year</span><br><span class="line">                birth = int(<span class="string">''</span>.join(re.findall(<span class="string">r'\d'</span>,match)))</span><br><span class="line">                ages.append(now - <span class="number">1900</span> - birth)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ages.append(int(<span class="string">''</span>.join(re.findall(<span class="string">r'\d'</span>,match))))</span><br><span class="line">    ages = list(filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">10</span> <span class="keyword">and</span> x&lt;<span class="number">40</span>, ages))</span><br><span class="line">    freqs = Counter(ages).items()</span><br><span class="line">    freqs = sorted(freqs,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="keyword">False</span>)</span><br><span class="line">    freqs = dict(freqs)</span><br><span class="line">    drawing.bar(<span class="string">'男女性择偶观数据分析:年龄分布'</span>,freqs,<span class="string">'年龄'</span>,<span class="string">'人数'</span>,<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过图表，我们可以发现：择偶年龄重点集中在24~28岁之间，并且整个年龄区间符合正态分布。每年过年的时候，我们都会听到年轻人被催婚的声音，甚至作为一个单身的人，每一个节日都像是我们的忌日，因为无论在哪里，你都可以被秀恩爱或者被撒狗粮。“哪有人会喜欢孤独呢？不过是不喜欢失望”，当这句话出现在我的Kindle屏幕上，出现在村上春树的《挪威的森林》里，我突然有种扎心的感觉。有一天，当我不在视爱情为必需品时，我突然意识到生命里有太多比感情重要的事情。我不希望我们因为一句年龄到了就去结婚，如果人生的一切都有期限都要按部就班，那么为什么我们不能平静地面对衰老和死亡呢？人天生起点就是不一样的，所以你不必努力去迎合别人定制的标准，就像学生时代大家面对的是同一张考卷，有的人交卷交得早，有的人交卷交得晚，有的人考试成绩好，有的人考试成绩差，可这不过是一场考试而已，不是吗？如果我的时间不能浪费在我喜欢的人身上，我宁愿永远将时间浪费在自己的身上，除了生与死以外，结婚和繁衍并不是必答题，我可以不结婚啊，一如我可以交白卷啊！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-1.png" alt="男女性择偶观数据分析:年龄分布" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:年龄分布</div>            </figure></p><h2 id="性别组成"><a href="#性别组成" class="headerlink" title="性别组成"></a>性别组成</h2><p>&emsp;&emsp;性别组成，我们主要从微博中的关键字入手，因为这些微博明确了择偶的是男嘉宾还是女嘉宾，我们通过这些特征就可以分析出男女性别比例。相关代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseSex</span><span class="params">()</span>:</span></span><br><span class="line">    rows = loadData()</span><br><span class="line">    sexs = &#123;<span class="string">'male'</span>:<span class="number">0</span>, <span class="string">"female"</span>:<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">u'男嘉宾[向右]'</span> <span class="keyword">in</span> text:</span><br><span class="line">            sexs[<span class="string">'male'</span>]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">u'女嘉宾[向右]'</span> <span class="keyword">in</span> text:</span><br><span class="line">            sexs[<span class="string">'female'</span>]+=<span class="number">1</span></span><br><span class="line">    drawing.pie(<span class="string">'男女性择偶观数据分析:男女性别比例'</span>,sexs,<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过下面的图表，我们可以非常直观地看到，男性数量是超过女性数量的，两者比例接近1.38:1。这和目前中国的实际基本相符，考虑到人们有更多的相亲渠道可以选择，我认为实际的比例应该会更大，媒体称适婚男性比女性多出3000万，性别比例的失衡难免会让男生找不到对象。可找不着对象有什么关系呢？人生短短一世，活着时候能见到最多不过四世同堂，血缘关系并不能让后辈替你完成未竟之事，当一个离开了这个世界，它与世界的关联就变得微乎其微，时间会让记忆逐渐模糊直至遗忘，你无法将这点微弱的安全感寄托在某一个人身上，人生而有涯，而知无涯，能在这个世界里流传下去的只有思想，我不想和任何人去攀比，因为生而为人，我很抱歉。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-2.png" alt="男女性择偶观数据分析:男女性别比例" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:男女性别比例</div>            </figure></p><h2 id="身高分布"><a href="#身高分布" class="headerlink" title="身高分布"></a>身高分布</h2><p>&emsp;&emsp;身高分布，同样采用关键字匹配的方式实现，不同的是，择偶者通常会在微博中给出自己的身高以及对伴侣期望的身高，由此我们对微博中的身高进行了提取，分别获得了男性、女性身高分布及其身高差分布。这是我最开始研究这个问题的初衷，现在的结果印证了当时的想法，我内心其实是特别开心的，这正是为什么要花时间和精力写这篇文章的原因所在。这里，相关的代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 身高分布</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseHeight</span><span class="params">()</span>:</span></span><br><span class="line">    heights = []</span><br><span class="line">    rows = loadData()</span><br><span class="line">    pattern = re.compile(<span class="string">r'1\d&#123;2&#125;|\d&#123;1&#125;\.\d&#123;1,2&#125;|\d&#123;1&#125;\米\d&#123;2&#125;'</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        matches = pattern.findall(text)</span><br><span class="line">        <span class="keyword">if</span>(len(matches)&gt;<span class="number">1</span>):</span><br><span class="line">            matches = map(<span class="keyword">lambda</span> x:int(<span class="string">''</span>.join(re.findall(<span class="string">r'\d'</span>,x))),matches)</span><br><span class="line">            matches = list(filter(<span class="keyword">lambda</span> x: x&lt;<span class="number">190</span> <span class="keyword">and</span> x&gt;<span class="number">150</span>, matches))</span><br><span class="line">            <span class="keyword">if</span>(len(matches)&gt;<span class="number">1</span>):</span><br><span class="line">                height = &#123;&#125; </span><br><span class="line">                height[<span class="string">'male'</span>] = max(matches)</span><br><span class="line">                height[<span class="string">'female'</span>] = min(matches)</span><br><span class="line">                heights.append(height)</span><br><span class="line">    <span class="comment"># 男性身高分布</span></span><br><span class="line">    male_heights = list(map(<span class="keyword">lambda</span> x:x[<span class="string">'male'</span>],heights))</span><br><span class="line">    male_heights = Counter(male_heights).items()</span><br><span class="line">    male_heights = dict(sorted(male_heights,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse = <span class="keyword">False</span>))</span><br><span class="line">    drawing.bar(<span class="string">'男女性择偶观数据分析:男性身高分布'</span>,male_heights,<span class="string">'身高'</span>,<span class="string">'人数'</span>,<span class="keyword">None</span>)</span><br><span class="line">    <span class="comment"># 女性身高分布</span></span><br><span class="line">    female_heights = list(map(<span class="keyword">lambda</span> x:x[<span class="string">'female'</span>],heights))</span><br><span class="line">    female_heights = Counter(female_heights).items()</span><br><span class="line">    female_heights = dict(sorted(female_heights,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse = <span class="keyword">False</span>))</span><br><span class="line">    drawing.bar(<span class="string">'男女性择偶观数据分析:女性身高分布'</span>,female_heights,<span class="string">'身高'</span>,<span class="string">'人数'</span>,<span class="keyword">None</span>)</span><br><span class="line">    <span class="comment"># 男女身高差分布</span></span><br><span class="line">    substract_heights = list(map(<span class="keyword">lambda</span> x:x[<span class="string">'male'</span>]-x[<span class="string">'female'</span>],heights))</span><br><span class="line">    substract_heights = Counter(substract_heights).items()</span><br><span class="line">    substract_heights = dict(sorted(substract_heights,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse = <span class="keyword">False</span>))</span><br><span class="line">    drawing.bar(<span class="string">'男女性择偶观数据分析:男女身高差分布'</span>,substract_heights,<span class="string">'身高差'</span>,<span class="string">'人数'</span>,<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;虽然女生都希望男生180以上，据说这样可以举高高、有安全感，可是作为一个成年人，我们必须勇敢地打破这种不切实际的幻想，因为身高和外貌都是父母给我们的，那些基因里决定的东西，往往是我们无法通过后天努力来弥补的。如果可以的话，我希望自己再长高5厘米，可如果我再无法长高，我希望你能接受现在的我，接受一个人身高上的缺陷，和接受一个人人性中的缺点，在我看来是一模一样的。可人类最大的问题， 就在于愿意相信自己眼睛看到的，耳朵听到的，并且这是两个人建立联系的前提，人家愿意了解你有趣的灵魂，前提是你有一副好看的皮囊，人类啊，说到底是一种比较高级的动物而已，就像动物用皮毛、肤色去吸引同类一样，如你所见，男生平均身高其实只有175而已！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-4.png" alt="男女性择偶观数据分析:男性身高分布" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:男性身高分布</div>            </figure></p><p>&emsp;&emsp;女性的身高通常不会被作为筛选条件，正如社会群体通常都是对男性提出各种要求一样，两个同等条件下的男、女性，人们理所当然地对男性提出了更高的要求，可其实大家都是母亲十月怀胎而来，同样地都在这个世界里生活了20多年。所以这个世界上有太多地问题，其实都是人们自己造成的。比如女性一定要找一个穿高跟鞋后还要比她高的男性，而男性一定要找一个身高上和他相差不大的女性，男性的身高不足175，同女性的身高不足165一样，都是人们眼中比较尴尬的身高，可你看这图表中女性的平均身高是160，那么，就让大家一起尴尬吧，不知道当年小平爷爷和拿破仑将军的夫人心里是怎么想的啦！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-5.png" alt="男女性择偶观数据分析:女性身高分布" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:女性身高分布</div>            </figure></p><p>&emsp;&emsp;最初我研究这个问题的时候，我发现微博上有好多身高不足160的女性，要求伴侣期望身高都是175以上，作为一个身高只有170的男生，我感到绝望和悲伤啊，后来和一位朋友聊天，他说他觉得我连170都没有，我想说人类为什么要这般奇怪，譬如体重一定要说得比实际轻、身高一定要说得比实际高、年龄一定要说得比实际小……难道这样不感觉累吗？那么到底有多少人希望两个人的身高差超过20厘米呢？网络上流传的所谓最萌身高差到底萌不萌呢？你看孟德尔通过豌豆杂交试验来研究遗传问题，两个身高差超过20厘米的人的后代，平均下来难道不是只有170吗？图表表明，男女性之间最佳的身高差是15厘米。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-6.png" alt="男女性择偶观数据分析:男女身高差分布" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:男女身高差分布</div>            </figure></p><h2 id="地理分布"><a href="#地理分布" class="headerlink" title="地理分布"></a>地理分布</h2><p>&emsp;&emsp;因为在这些微博中会出现相亲者的地理信息，所以我们整理了陕西省各县市的名称作为关键字，试图分析出这些相亲者的地理分布，这里我们简单绘制了一个柱形图，相关代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地区分析</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">anslyseLocation</span><span class="params">()</span>:</span></span><br><span class="line">    freqs = &#123; &#125;</span><br><span class="line">    citys = [<span class="string">u'西安'</span>,<span class="string">u'铜川'</span>,<span class="string">u'宝鸡'</span>,<span class="string">u'咸阳'</span>,<span class="string">u'渭南'</span>,<span class="string">u'延安'</span>,<span class="string">u'汉中'</span>,<span class="string">u'榆林'</span>,<span class="string">u'安康'</span>,<span class="string">u'商洛'</span>]</span><br><span class="line">    rows = loadData()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">for</span> city <span class="keyword">in</span> citys:</span><br><span class="line">            <span class="keyword">if</span>(city <span class="keyword">in</span> text):</span><br><span class="line">                <span class="keyword">if</span>(city <span class="keyword">in</span> freqs.keys()):</span><br><span class="line">                    freqs[city]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    freqs[city]=<span class="number">1</span></span><br><span class="line">    drawing.bar(<span class="string">'地区分布图'</span>,freqs,<span class="string">'地区'</span>,<span class="string">'人数'</span>,<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里的结果令人出戏，因为西安作为陕西省的省会城市，在所有地区中一骑绝尘。考虑到在这些微博中”西安”存在干扰，所以这个结果并不是非常严谨，不能作为一个有效的分析指标，而且这里存在同义词，比如”本地”和”土著”其实都表示西安，而我们统计的时候并没有考虑这种情况，所以这里绘制的地区分布图表，大家看看就好啦！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-7.png" alt="男女性择偶观数据分析:地区分布图" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:地区分布图</div>            </figure></p><h2 id="星座分布"><a href="#星座分布" class="headerlink" title="星座分布"></a>星座分布</h2><p>&emsp;&emsp;这里为什么要分析星座呢？理论上来讲，我是不大相信这些东西的，可当你经历的事情多了以后，你就会下意识地认为这些东西说得很对，我想古代的占卜算卦基本上是同样的东西，其实世间好多事情之间应该是没有直接的联系的，无非是在千百年的历史积淀中，逐渐地形成了一套建立在经验上的理论体系，这就像我们今天所追捧的机器学习，我们有千百年的历史长河去收集数据，每一个相信这些理论的人都是一个数据样本，这些理论体系通过不断地训练和模拟，逐渐可以正确地预测某些事情，让我们相信万事万物间存在某种联系。可即便如此，人类依旧免不了对各种事物存在偏见，比如星座中经常无辜躺枪的处女座、双子座和天蝎座，人类最擅长的认知方式，就是用一个群体现象来预测个人现象，可讽刺的是朴素贝叶斯就是这样的思想，所以这里我们简单地统计了下各种星座的频数分布：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 星座分析</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseStar</span><span class="params">()</span>:</span></span><br><span class="line">    stars = [<span class="string">'白羊'</span>,<span class="string">'金牛'</span>,<span class="string">'双子'</span>,<span class="string">'巨蟹'</span>,<span class="string">'狮子'</span>,<span class="string">'处女'</span>,<span class="string">'天秤'</span>,<span class="string">'天蝎'</span>,<span class="string">'射手'</span>,<span class="string">'摩羯'</span>,<span class="string">'水瓶'</span>,<span class="string">'双鱼'</span>]</span><br><span class="line">    freqs = &#123;&#125;</span><br><span class="line">    rows = loadData()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">for</span> star <span class="keyword">in</span> stars:</span><br><span class="line">            <span class="keyword">if</span>(star <span class="keyword">in</span> text):</span><br><span class="line">                <span class="keyword">if</span>(star <span class="keyword">in</span> freqs.keys()):</span><br><span class="line">                    freqs[star]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    freqs[star]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> star <span class="keyword">in</span> stars:</span><br><span class="line">        <span class="keyword">if</span>(star <span class="keyword">not</span> <span class="keyword">in</span> freqs.keys()):</span><br><span class="line">            freqs[star] = <span class="number">0</span></span><br><span class="line">    freqs = Counter(freqs).items()</span><br><span class="line">    freqs = dict(freqs)</span><br><span class="line">    drawing.pie(<span class="string">'男女性择偶观数据分析:星座分布'</span>,freqs,<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个结果相对客观些，因为12个星座基本上平分秋色啦，并不存在某种星座独领风骚的情况，简直是人与自然的大和谐了呢？<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7wy477.com1.z0.glb.clouddn.com/Figure_1-3.png" alt="男女性择偶观数据分析:星座分布" title="">                </div>                <div class="image-caption">男女性择偶观数据分析:星座分布</div>            </figure></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;这篇文章写到这里，我其实已经非常疲惫啦，因为这篇文章的<a href="https://qinyuanpei.github.io/posts/1386017461/">上篇</a>与下篇中间相隔了差不多三个月，而且我写作上篇的时候，并没有打算写这一篇文章出来，再者两篇文章写作时的心境完全不同，所以现在写完这篇文章，终于有种如释重负的感觉，一来没有因拖延症而放弃这篇文章，二来为了了解相关的理论以及训练数据花费大量精力，我必须对自己的过去有一个总结，这是我今年年初给自己制定的目标，不管有没有喜欢我，我总要去做这些事情，不是因为我想要证明什么或者做给谁看，而是我认为这件事情比某些事情有趣而且重要。这篇文章首先承接上文，交待故事的背景，即为什么要做这样的数据分析；然后我们简单介绍了文本分类的常用的技术方法，主要以特征工程和分类器为主；接下来我们介绍了两个经典的理论：tf-idf和朴素贝叶斯，这是本文文本分类的理论基础；在数据分析这部分，我们对特征、年龄、性别、身高、地区和星座等进行了分析，并借助Python中的图表模块完成了数据的可视化工作。好啦，以上就是这篇文章的全部内容啦，欢迎大家积极留言和评论，晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据分析" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="微博" scheme="http://qinyuanpei.github.io/tags/%E5%BE%AE%E5%8D%9A/"/>
    
      <category term="朴素贝叶斯" scheme="http://qinyuanpei.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
      <category term="文本分类" scheme="http://qinyuanpei.github.io/tags/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>行走在消逝中</title>
    <link href="http://qinyuanpei.github.io/posts/2809571715/"/>
    <id>http://qinyuanpei.github.io/posts/2809571715/</id>
    <published>2018-03-15T21:29:47.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-wduMprTR" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="523845740" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><p>&emsp;&emsp;从昨天到今天，关于霍金逝世的消息，一直在朋友圈里刷屏。昨天同事告诉我这个消息的时候，我心底先是一片恍惚，而后习惯性地打开微信，发现朋友圈和公众号里都在讨论这件事情。而等到我吃饭的时候，居然听到临桌的一名男生，在向同伴讲述霍金辐射的理论，堪称我在这一天所见过的一股清流。不知道从什么时候开始，一个人物的突然离去，总是会让人们在短时间内亢奋起来，仿佛一场集体缅怀的狂欢。回顾最近这些年来已故的名人，例如杨绛先生、杨洁导演、词作家闫肃、作家黄易等等，每每提及不禁令人一阵唏嘘，正所谓“逝者已矣，生者如斯”。可我想说的是，不要总是等到离开的时候，才会想起一个人的存在。</p><p>&emsp;&emsp;印象中第一次有这种感觉是在2011年，那时我刚刚考上大学，我只记得那时站在太阳底下的我，突然大声地向周围人宣布乔布斯逝世的消息。我清晰地记着父母惊愕的表情，因为在他们的人生字典里，全然不知道乔布斯是谁，可在19岁的我看来，那就像是某种重大的事情发生，至少从今天的角度来看，在我出生的1992年里，苏联正式解体，我们的生命总是不可避免地和某种历史进程关联起来。因为从中学时候就开始住校，印象中每次回家都既陌生而熟悉，偶尔会听到妈妈讲，家族里某一位长辈突然过世。这种事情听得多了，居然不会再觉得惊讶。可是想起这些人里，有人曾经出过数学题考问过我，有人你曾经帮过他们做过什么事情……刹那间觉察到时光的残忍——所谓的物是人非，大概就是你还在此处，而别人早已暗自走远。</p><p>&emsp;&emsp;坦白地讲，我对霍金的认知永远都停留在《时间简史》这本书上，记得16年买了Kindle以后，的确买了这本书来读，大概读了十来页便读不下去。霍金和海伦·凯勒一样，是被我划定到身残志坚这类写作素材的范畴里。当时，语文老师让我们关注每年的感动中国人物评选，其初衷便是为了丰富我们的写作素材。回想那些年里，遭受无数次宫刑而忍辱负重的司马迁、实验了3000多种材料终于制造出灯泡的爱迪生、披发行吟泪洒汨罗而心系家国的屈原……这些在学生时代频频被消费的历史人物，在今天看来是否有些相似呢？据说知乎上一天内产生了700多个霍金相关的问题，一个曾经活在我们作文里的人物，在他离开这个世界以后，再次成为我们热议的话题，好像他从来没有在这个世界上存在过一样，这是一件可怕的事情。</p><p>&emsp;&emsp;我认为尊重一名物理学家的基本要求是相信科学。伴随着霍金变成人们关注的热点，网络上开始流传伽利略、爱因斯坦和霍金三个人之间巧合的时间线问题，仿佛我们面对的不是一名为宇宙物理学做出巨大贡献的科学家，而是一个被神化的“活佛”转世。有人说，人类都是一群戏精。集体缅怀一个伟人吧，立马有人跳出来说，伟人的著作都没读过一本，蹭什么热度；大家都不关注这件事情吧，立马有人跳出说，“将军坟前无人问，戏子家事天下知”，根本没有人关心科技工作者。可你看关注的时候，大家都在关注什么，譬如定要给物理学领域内的专家学者们排出个优劣来，定要将一个人的私事深挖出来品判人品。杨绛先生说，“我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容。我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系。“，这是最浅显不过的道理，可惜想要做到实在太难。</p><p>&emsp;&emsp;我一直相信“人生而孤独”，除了亲情血缘以外，人与人间的联系，有时脆弱得像一只挂在风筝上的线，随时都会有断开的危险。有些人不知不觉就渐渐走远了，我们一路踟蹰而雁行，在相遇中失散，在失散中相遇，可当两个人再次相遇时，已然不是当初的彼此。我是一个不太会维护亲密关系的人，不知道是我自己走得太快，还是别人走得太快，无数的人在我这里出现然后离开，仿佛是在追逐风中的花瓣，等到风停了的时候，花瓣已不见，花香已飘远。有时候会突然问自己，想把别人留在我的生命里，是不是一件自私的事情。游戏制作人陈星汉有一款游戏叫做《风之旅人》，在广阔无垠的沙漠场景中，最多只有两个玩家出现，出现的时间和地点随机，对方可能来自任何一个国家，你对他/她的的身份信息一无所知，两个人唯一的互动方式是“共鸣”。两个靠在一起的人，可以通过“共鸣”来为对方的围巾补充能量，最重要的一点是，一旦两个人走失，就永远不会再相遇，这是这款游戏超现实意义的一个体现。</p><p>&emsp;&emsp;我不知道，两个人从无话不说到无话可说需要多久；我只知道，真正想要离开的人，从来都是不动声色的。自那以后，我不知道对方会在哪里，会变成什么样子，每天都会做哪些事情。我承认，别人的世界和你毫无关联，可你终究不愿意让自己成为孤岛，所以你会感到痛苦和挣扎，会想要找一个能永远陪伴你的人。可生老病死是人生里无可避免的结果，我们终其一生所寻找的灵魂伴侣，是否真的可以陪伴彼此到生命尽头。如果一切注定都要失去，我宁愿一直这样下去，我从来没有把生育看做是我生命的一种延续，因为每一个人的生命都注定独一无二，你不能想当然地认为，血缘关系会替你继承什么东西。从你死亡的那一刻起，一切都变成新的东西。</p><p>&emsp;&emsp;人的一生会死亡三次，第一次是医生宣布你的死亡，这是肉体上的死亡；第二次是人们来参加你的葬礼，这是社会学意义上的死亡；第三次是这个世界没有人再记得你，这是哲学意义上的死亡。或许这个世界再无霍金，可他的思想和著作一直就在那里，时间会记录着人类的过去和未来，而他是搭乘时光列车满世界旅行的自由灵魂。一个人可以不结婚，可以不生孩子，因为这是你生而为人的选择，世俗的力量是如此的强大，以至于我们都以为，人生就是一个跳一跳游戏，每一个年龄就应该跳到相应的位置。我的人生目标里没有结婚生子，如果我注定留不下任何人，如果我注定永远要被这个世界所遗忘，我宁愿在我还活着的时候，努力去写字去发出声音，即使在这空荡荡的宇宙里听不到回声，可声音不是一直都在传播着吗？</p><p>&emsp;&emsp;有时候，想想人生难免会觉得失望。我们明明知道世界是自己，和他人毫无关联，可我们还在努力地和这个世界发生着关联；我们明明不愿意让别人了解自己的生活，可我们对这个世界的表达欲从来没有衰减过。从镌刻在龟壳上甲骨文到以丝帛作为书写材料，再到造纸术的产生，再到今天的各种芯片，甚至内容的形式从文本演变为图片再演变为视频……可我们怎么就变成了一堆“亡灵”，从前QQ好友列表一片隐身，如今朋友圈剩下一条横线。如果一定要别人不再想起你，等你真正离开这个世界的时候，才会突然间被想起，我会很心疼一条鱼的记忆，因为一条鱼的记忆只有8秒。</p><p>&emsp;&emsp;如果下一刻失去记忆的，是你和我这般普通人，我们没有机会像霍金一样，被大家集体缅怀，你希望被那一个人记着，记多长时间呢？就像我总和朋友们说，回家以后找时间相聚，可在家时会觉得家人最为重要，在某一瞬间发现自己并没有那么多时间；就像我总计划着找机会去看望语文老师，可和朋友约不到一起时便无从谈起……我突然间想到，高中的第一堂语文课上，老师安排大家写一篇作文，题目好像叫做《回首向来》亦或者是《行走在消逝中》，那时我的作文没有写完，反而被老师叫起来当众朗读，我说“回首向来萧瑟处，也无风雨也无晴”，记忆明明是有的，可我突然叫不出来有些人的名字，甚至在某一个清晨惊醒，梦到过往的某一天考试迟到，或者是快要交卷发现作文没有写……我稍稍一定神，考试那好像是很多年前的事情了吧……</p><p>&emsp;&emsp;我其实很想留下来陪你或者陪Ta呀，可时光列车从来不会留给我思考的时间，有时候我走得快，有时候你走得快，像无法逃离黑洞的光一样，拼命地往前走往前走。在广阔无垠的宇宙中，我们生活在彼此平行的世界里，有时看得见彼此，有时看不见彼此，靠着彼此间微弱的万有引力，不至于失散得太远，在成为一颗孤独的白矮星之前，请记住我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="霍金" scheme="http://qinyuanpei.github.io/tags/%E9%9C%8D%E9%87%91/"/>
    
      <category term="时间" scheme="http://qinyuanpei.github.io/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="请记住我" scheme="http://qinyuanpei.github.io/tags/%E8%AF%B7%E8%AE%B0%E4%BD%8F%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>我是猫，一只特立独行的猫</title>
    <link href="http://qinyuanpei.github.io/posts/352037321/"/>
    <id>http://qinyuanpei.github.io/posts/352037321/</id>
    <published>2018-03-06T08:57:48.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;终于在除夕夜到来前，在Kindle上读完了2017年的最后一本书，来自夏目漱石先生的《我是猫》。起初买这本书的动机说起来非常滑稽，一来以为这会是一本诙谐幽默的书，二来对夏目这个名字莫名地充满好感。我读的是曹曼翻译的中文译本，读时觉得这位作者的文字清新素雅，即使全书行文节奏堪称缓慢到极点，想来应该是我们这个时代的人物。及至翻阅作者生平，始知这位被誉为“国民大作家”的日本作家，早在100年前就在日本文学史上享有盛名。这种感觉如何去形容呢？大概就是杨过从剑冢石刻的寥寥数语中，遥想独孤求败”生平求一敌手而不可得”的寂寥难堪。这位老先生的文字可以说非常”摩登“了，因为在100年后的今天再次读来，竟完全读不出违和感来，所谓”嬉笑怒骂皆成文章“，讽刺与幽默杂然相陈，这是我喜欢这本书的理由。</p><p>&emsp;&emsp;对于《我是猫》这本书，按照作者的话说，它是一部没有什么情节的小说，因为它完全是以一只猫的视角来行文，这只生活在一个教师家庭里的猫，每天都会接触到形形色色的文人，譬如：不食人间烟火，空有一番理论而不去实践的独仙；整天磨玻璃球，做事一丝不苟甚至古板木呐的寒月；表面上每天都很乐观，实则唯恐天下不乱的米亭；做事三分钟热情，自命清高的苦沙弥……等等。在猫的眼睛这里，这些人整天聚在一起讨论没有意义的事情，对现实世界心怀不满，不思进取就会怨天尤人，甚至金田及其夫人的”拜金主义“，为金钱而陷害苦沙弥的邻居，唯利是图、虚伪圆滑的铃木，这些人在猫的眼睛里都是丑陋而黑暗的。这只猫平静地叙述着它的见闻，仿佛它早已经整个人类和社会看穿看透，或许带着些嘲讽，或许带着些同情。</p><p>&emsp;&emsp;每年的2月22日是日本的猫节，这是我在读完这本书以后知道的。而猫在日本的文化形象中是非常神圣的，据说这是因为猫最早由遣唐使带来日本，首先作为宫廷宠物出现，直至江户时代进入”寻常百姓家“。除此之外，日本作为重度渔业国度，对稻米的珍惜使其在捕鼠护粮方面极为重视，猫作为老鼠的天敌自然而然地受到喜爱。相传招财猫起源于东京世田谷的豪德寺，因此猫在日本被人们当作神明供奉。再比如日本动漫中的机器猫、龙猫和Hello Kitty都是猫在日本文化中的经典形象，日本的文学作品比如《草枕子》、《源氏物语》等里面都有关于猫的故事。时至今日，依然有大量德川家族与猫的故事流传。因此，猫在日本人眼中有一种浓厚的贵族气息。陈凯歌导演的《妖猫传》，改编自日本作家梦枕貘的小说《沙门空海》，猫在其中的重要性不言自明。</p><p>&emsp;&emsp;这是一本“猫眼看世界”的书，这是一个怎样的世界呢？1871年，日本历史上最为大刀阔斧的一次改革——明治维新，开始在全国范围内推行。改革带来经济飞速发展的同时，带来了各种矛盾日益突出的社会问题。36年的1905年，时年38岁的夏目漱石，以猫的视角，如初入人类社会一般，探讨当时知识分子的心理状态和对社会变迁的感慨，并因此一举成名，获得社会广泛关注，被认为是日本批判现实主义文学的丰碑。每一个时代都有它的无奈，或许我们今天难以想象老先生当时的心境，不过从这些猫的口吻里，从这些辛辣的讽刺和戏谑中，我们总能读出作者当时内心的苦闷。猫眼里那些荒诞不经的行为，恰恰就是你我每天的生活，我们总说人类和猫是好朋友，可那仅仅是我们以为的，在猫的眼睛里，我们就像一群神经病。</p><p>&emsp;&emsp;猫是如何看待人类的呢？猫说：世间的奢侈往往是无能的表现。猫一年到头都穿着同一件衣服，而人类好像不把尽可能多的东西往身上照顾就难受，人类给羊添麻烦，受蚕照顾，承蒙棉花的恩泽，你看吧，我们的所作所为连只猫都看不下去。人类羡慕猫的悠闲，故而感慨道：什么时候能像猫一样轻松就好了。可明明是人类自己制造出一堆乱七八糟的事情给自己，到头来还抱怨真痛苦真痛苦，就像自己生起一堆火，到头来嚷着热死了热死了。这一切在猫看来都是庸庸碌碌的。猫甚至断言道：人类不可能永远繁荣昌盛下去。嗯，我愿静候属于猫族时代的到来。从前是“人类一思考，上帝就发笑”，而现在是“人类一思考，猫君就发笑”。猫觉得人类模仿它们的声音时是愚蠢的，尤其是在抚摸它们的时候，因为根本不存在撒娇声，只有被撒娇声，因为我们期待的是，猫向我们撒娇，可难道不是我们在向猫撒娇？</p><p>&emsp;&emsp;个体的荒谬，在人类的个性面前根本不值一提，就如同人类的个性得到完全解放以后，永远像一锅众口难调的羹汤。小说中苦沙弥、迷亭、寒月、东风和独仙时常在一起聊天，话题涉及哲学、艺术，爱情、生活等多个方面，这只“毒舌”的猫，就在无意识地引导和放大这些观点，“我认为这个世界上，没有比爱和美更受人尊重的了”，所以这本书里的观点，其实并不是完全的消极的，就像这只猫平静地看着这个世界，它对人类有过嘲讽，有过同情，它甚至没有自己的名字，当它失足淹死在水缸里的时候，对这个世界更多的是种悲天悯人吧！我们这个世界上有五种毒药，佛家所谓的“贪嗔痴慢疑”，作者提到“可没有任何一个人，能够全然抛开自己去研究外界，如果人类能够把自己疏离出来，那么疏离的瞬间，也就没有了自己”，人类常常不愿放过自己，更不愿放过别人，因为所有无解的问题，都可以制造一个意义出来，而我们早已习惯这一切。</p><p>&emsp;&emsp;曾经有朋友问我，为什么喜欢猫这种动物，我回答说，因为我就像一只猫，一只特立独行的猫，对所有人都很友善和蔼，却喜欢独来独往。因为维护这种若即若离的关系，对我来说比任何事情都要困难。人类以为猫都是傲娇的动物，其实这是人类的一厢情愿，因为从智力上来说，猫的智力是不及狗的。猫自然对人是有感情的，不过在人类驯养动物的历程中，狗更聪明、更懂得如何向人类索取，我们所认定的感情，在狗的世界里或许并不是。人类难以理解的事物，所谓阳春白雪，所谓曲高和寡，不自然地背负上高冷的名声，对一只猫而已，到底是我们不了解猫，还是不了解我们自己。人总在试图驯化猫这种动物，可猫无非是人类的一种折射而已，它就像那些独立潇洒的人一样，不藉由粘人和撒娇来获取安全感，在这个世上没有谁会离不开谁。你走，我不必送你；你来，不管多大风多大雨，我都去接你。这是我——一只猫的自白。</p><p>&emsp;&emsp;有时候，难免会觉得人类自作聪明，喜欢给世间的事物贴上不同的标签，譬如二哈、喵星人、汪星人、猫主子……可你知道猫如何评价人类的吗？作者说，“这些人虽然看起来快活，但是如果叩问他们的心底，却可以听见悲凉的回响”。为什么会听见悲凉的回响呢？大概是人类丰富而有趣的个性，不断地尝试挑战世俗的眼光，结果被世俗打败而变得世俗，这听起来简直就像是，英雄杀死魔王又变成魔王的故事的翻版。“每个人地位都提高，等同于每个人的地位都下降。人类不再做让自己委屈的事情，正是个人力量变强的证明；几乎不再插手别人的事情，反而是群体力量变弱的证明”。一点亏都不愿意吃，一点小便宜就要占，无一不是为了证明个人意志的强化，可人与人间的空间越来越狭窄，日益窘迫，为了扩充自己膨胀到近乎爆炸。人与人之间那点空间，是一切痛苦的根源，你说这还不算作悲凉吗？没有谁可以完全了解一个人，不完全认知是人类关系的反应剂，痛苦、误会、偏见……等等纷至沓来，你以为你模仿猫叫，猫就真的听懂了吗？</p><p>&emsp;&emsp;夏目先生在后记里写道，“世事变迁就像猫的眼珠一样变幻莫测，短短几个月世间，就可以去那极乐世界，或者可以把薪水花光光。年底过去了，正月过去了，花朵凋谢，新叶又生。以后世界将如何变化，我不了解，只不过水缸中猫的瞳孔，应该可以凝成永恒”。我想，世界会一如既往地这样无奈下去，时间会一如既往地这样消逝下去，而你和我会一如既往地平庸且烦恼下去。假如有这样一只猫，通过瞳孔记下了我的生平，不知道它会如何评价我呢？就像在某一个下雨天，突然想到某一个人，单单是因为怕这世界里，从此再没了对方的音讯。可单单是想到又有什么意义呢？《笑傲江湖》里令狐冲率领江湖群雄，前往少林寺解救被困的圣姑，这个将来会成为他妻子的人，而眼下更是生死未知、前途未明，可在一片寂静中听到雪花簌簌落下时，他想到的却是：小师妹不知这时候不知在干甚么。及至岳林珊为林平之所杀，临死托付令狐冲替她照顾小林子，内心却又不知做何感想了吧……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://qinyuanpei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="夏目漱石" scheme="http://qinyuanpei.github.io/tags/%E5%A4%8F%E7%9B%AE%E6%BC%B1%E7%9F%B3/"/>
    
      <category term="日本文学" scheme="http://qinyuanpei.github.io/tags/%E6%97%A5%E6%9C%AC%E6%96%87%E5%AD%A6/"/>
    
      <category term="我是猫" scheme="http://qinyuanpei.github.io/tags/%E6%88%91%E6%98%AF%E7%8C%AB/"/>
    
  </entry>
  
  <entry>
    <title>基于Travis CI实现 Hexo 在 Github 和 Coding 的同步部署</title>
    <link href="http://qinyuanpei.github.io/posts/1113828794/"/>
    <id>http://qinyuanpei.github.io/posts/1113828794/</id>
    <published>2018-02-27T10:45:04.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是 <a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a> .在曾经的一篇博客：<a href="https://qinyuanpei.github.io/posts/3521618732/">《持续集成在Hexo自动化部署上的实践》</a>中，我为大家分享了在线持续集成服务  <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 的相关内容，在这篇文章中我们通过  <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 为 Hexo 提供了自动部署的支持。其原理是Github为 <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 分配一个token，当我们向 Github 推送新的代码以后，Travis 就会从代码仓库中拉取代码，并通过 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> 安装依赖生成静态页面，我们将这些静态页面推送到 master 分支，即可完成对Hexo的部署操作。这个流程从去年10月份建立以来，一直运行得非常稳定，对我个人而言，随着博客里得内容越来越多，在本地生成静态页面需要<br>20多秒得时间，而有了持续集成服务以后，我可以用这个时间去做更多的事情，当持续集成流程发生异常的时候，微信上会收到 Travis 发送的邮件，整个过程简直令人心情愉悦。</p><p>&emsp;&emsp;今天想继续写点这个话题相关的内容，即如何通过 Travis CI 实现 Hexo 在 Github 和 Coding 的同步部署。显然，部署 Hexo 到 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 我们已经实现，今天我们着重来说 <a href="https://coding.net/pages/" target="_blank" rel="noopener">Coding Pages</a>。为什么我们需要 <a href="https://coding.net/pages/" target="_blank" rel="noopener">Coding Pages</a> 呢？主要从两个方面考虑，首先，因为 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 屏蔽了百度的爬虫，所以我们托管在 Github 上的博客，无法被搜索引擎正常收录；其次，由于 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 的服务器在国外，所以在国内博客的速度会受到影响，而且<strong>“防火墙”</strong>的国情决定了 <a href="https://github.com" target="_blank" rel="noopener">Github</a> 是一个不稳定的网站。曾经经历过短时间内无法使用 Github 的情形，故而，为了保证博客可以更加稳定地运行，我们必须为博客提供一个备份镜像，这就是我们今天要提到的 <a href="https://coding.net/pages/" target="_blank" rel="noopener">Coding Pages</a> 服务啦。在正式使用这个服务前，我们首先简单介绍下这个服务。</p><p>&emsp;&emsp;我们知道 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 是 Github 提供的静态页面托管服务，其初衷是为个人项目或者组织项目创建演示或者文档站点，而 <a href="https://coding.net/pages/" target="_blank" rel="noopener">Coding Pages</a> 则是国内的代码托管平台 <a href="https://coding.net/git" target="_blank" rel="noopener">Coding</a> 提供的类似服务，国内类似的代码托管平台还有<a href="https://gitee.com/login" target="_blank" rel="noopener">码云</a>、<a href="https://about.gitlab.com/" target="_blank" rel="noopener">Gitlab</a> 等。<a href="https://coding.net/pages/" target="_blank" rel="noopener">Coding Pages</a> 支持自定义域名、SSL 等基本特性，随着官方不断对这一服务进行升级，目前该服务除支持静态页面部署以外，同时支持 PHP 和 MySQL这类动态页面部署的特性。对 Hexo 来说，静态页面部署的特性完全可以支撑我们这个想法。我的想法是以 <a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener">Github</a> 作为代码的主仓库，其上面的 <strong>blog</strong> 分支存放博客的源代码， <strong>master</strong> 分支存放博客的静态页面，在此基础上，我们同时推送静态页面到 Github 和 Coding 的代码仓库，这样就可以实现两个平台的同步部署，这里的部署自然是指由 Travis 完成的自动化部署。整体的流程设想如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/2018022714101472" alt="博客同步部署流程图" title="">                </div>                <div class="image-caption">博客同步部署流程图</div>            </figure><p>&emsp;&emsp;通过这个流程图，我们可以注意到，新增加的工作量，主要体现在 Travis 向 Coding 的代码仓库推送静态页面，因此我们首先要有一个 Coding 的代码仓库。关于如何注册 Coding 及在 Coding 上创建代码仓库，这里不再详细赘述啦，大家可以自行百度、Google 或者阅读官方文档。Travis CI 的行为主要由 <strong>.travis.yml</strong> 这个文件来决定，要推送静态页面到 Coding 的代码仓库，Travis CI 需要有代码仓库的读写权限。顺着这个思路，尝试让 Coding 授权 给 Travis CI，结果从文档中发现Travis CI 并不支持 Coding，而 Coding 官方支持的持续集成 flow.ci 需要使用者从 Docker 创建镜像，所以看起来这条路无法走通。从搜索引擎中检索相关问题，从 Git 工作机制的角度入手，可以想到三种常见思路，即 SSH Key、Hexo 的 deploy 插件和 HTTPS协议。</p><p>&emsp;&emsp;第一种思路是考虑让 Travis CI 的远程服务器共享本机的SSH Key，通过 <strong>ssh-copy-id</strong> 命令即可实现，可问题是 Travis CI 每次创建虚拟机环境是变化的，因此我们无法确定目标主机的 IP 或者计算机名称等信息，这种思路不适合 Travis CI。而 Travis CI 官方同样提供了命令行工具来完成这个工作，因为 Travis CI 是基于 Ruby 开发而来，所以需要 Ruby 的环境支持，作为一个为逃避 Jekyll 而选择 Hexo 的人，我是不会让自己再受到 Ruby 的摧残的，所以这种思路基本放弃。第二种思路是使用 Hexo 提供的 deploy 插件，例如 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deploy-git</a> 这个插件支持通过 git 部署，而 Coding 和 Github 都支持 Git 相关的协议，所以可以考虑使用这个插件来完成这个操作，目前网络上可以检索到的资料，都是使用这个插件来完成同步部署。可是经过我一位使用过这个插件的朋友确定，该插件需要再执行 git 命令行期间输入用户名和密码，Travis CI 是不会给你机会输入用户名和密码的，所以这种思路再次放弃。第三种 HTTPS 协议，这个想都不用想是需要输入密码的，所以果断直接放弃。</p><p>&emsp;&emsp;正所谓”行至水穷处，坐看云起时”，山重水复之间，柳暗花明之际，我意外发现 Coding 提供了和 Github 类似的”访问令牌”，我们在使用 Travis CI 的时候，实际上做了两步授权操作，第一次是授权 Travis CI 读取我们在 Github 上的仓库列表，这是一个通过 OAuth 授权的过程；第二次授权是授权 Travis CI 向指定仓库推送或者拉取内容，这是一个通过 Token 授权的过程。我们会在 Travis CI 的后台设置中将 Token 作为全局变量导出，这样我们就可以在 .travis.yml 文件中引用这些全局变量。我意识到这是一个值得一试的想法，首先我们在 Coding 的<strong>”个人设置”</strong>页面中找到<strong>访问令牌</strong>，新建一个新的访问令牌，这里我们选第一个权限即可，因为我们只需要为 Travis 提供基本的读写权限，这样我们会生成一个 Token，这里注意保存 Token，因为它在这里只显示这一次，我们将 Token 填写到 Travis CI 的后台，取名为 CO_Token 即可，依次如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180227150043442" alt="在Coding中新建访问令牌" title="">                </div>                <div class="image-caption">在Coding中新建访问令牌</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180227150136197" alt="在Coding中保存访问令牌" title="">                </div>                <div class="image-caption">在Coding中保存访问令牌</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180227150209635" alt="在Travis中新建全局变量" title="">                </div>                <div class="image-caption">在Travis中新建全局变量</div>            </figure><p>&emsp;&emsp;好了，现在有了Token，就意味着 Travis CI 有权限向 Coding 推送或者拉取内容了，那么怎么让它工作起来呢？我们记得 Travis CI 有一个叫做 .travis.yml 的配置文件对吧？这里我们需要简单修改下这个文件，让 Travis CI 在生成静态页面以后同时推送静态页面到 Coding。修改后的关键配置如下，我已经写好了详细注释，关于这个文件配置可以参考<a href="https://docs.travis-ci.com/" target="_blank" rel="noopener">这里</a>，这里不再详细说明：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"qinyuanpei"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"qinyuanpei@163.com"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER"</span></span><br><span class="line">  <span class="comment"># Github Pages</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:master</span> </span><br><span class="line">  <span class="comment"># Coding Pages</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://qinyuanpei:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;"</span> <span class="attr">master:master</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">tag</span> <span class="string">v0.0.$TRAVIS_BUILD_NUMBER</span> <span class="bullet">-a</span> <span class="bullet">-m</span> <span class="string">"Auto Taged By TravisCI With Build $TRAVIS_BUILD_NUMBER"</span></span><br><span class="line">  <span class="comment"># Github Pages</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:master</span> <span class="bullet">--tags</span></span><br><span class="line">  <span class="comment"># Coding Pages</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--quiet</span> <span class="string">"https://qinyuanpei:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;"</span> <span class="attr">master:master</span> <span class="bullet">--tags</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr"> global:</span></span><br><span class="line">   <span class="comment"># Github Pages</span></span><br><span class="line"><span class="attr">   - GH_REF:</span> <span class="string">github.com/qinyuanpei/qinyuanpei.github.io</span></span><br><span class="line">   <span class="comment"># Coding Pages</span></span><br><span class="line"><span class="attr">   - CO_REF:</span> <span class="string">git.coding.net/qinyuanpei/qinyuanpei.coding.me.git</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;好了，现在我们就可以同时部署博客到 Github 和 Coding了，现在大家可以使用下面两种方式来访问我的博客。需要说明的是，使用 Coding Pages 的特性需要开启仓库的 <strong>Pages </strong>服务，并且 Coding 支持免费托管私有项目，虽然目前仓库的容量存在限制，对我们部署 Hexo 来说完全足够啦，下图是 Coding 上展示的提交历史，排版效果棒棒哒，哈哈，好了，以上就是这篇文章的内容啦，希望大家喜欢哦！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180227152041753" alt="Coding上展示的提交历史" title="">                </div>                <div class="image-caption">Coding上展示的提交历史</div>            </figure><ul><li><a href="https://qinyuanpei.github.io">Github Pages 镜像</a></li><li><a href="http://qinyuanpei.coding.me" target="_blank" rel="noopener">Coding Pages 镜像</a></li></ul><p>&emsp;&emsp;本文使用的 .travis.yml 文件可以从<a href="https://github.com/qinyuanpei/qinyuanpei.github.io/blob/blog/.travis.yml" target="_blank" rel="noopener">这里</a> 获取哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="独立博客" scheme="http://qinyuanpei.github.io/categories/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://qinyuanpei.github.io/tags/Hexo/"/>
    
      <category term="CI" scheme="http://qinyuanpei.github.io/tags/CI/"/>
    
      <category term="Travis" scheme="http://qinyuanpei.github.io/tags/Travis/"/>
    
  </entry>
  
  <entry>
    <title>基于Python实现的微信好友数据分析</title>
    <link href="http://qinyuanpei.github.io/posts/2805694118/"/>
    <id>http://qinyuanpei.github.io/posts/2805694118/</id>
    <published>2018-02-24T12:50:52.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;最近微信迎来了一次重要的更新，允许用户对”发现”页面进行定制。不知道从什么时候开始，微信朋友圈变得越来越复杂，当越来越多的人选择”仅展示最近三天的朋友圈”，大概连微信官方都是一脸的无可奈何。逐步泛化的好友关系，让微信从熟人社交逐渐过渡到陌生人社交，而朋友圈里亦真亦幻的状态更新，仿佛在努力证明每一个个体的”有趣”。有人选择在朋友圈里记录生活的点滴，有人选择在朋友圈里展示观点的异同，可归根到底，人们无时无刻不在窥探着别人的生活，唯独怕别人过多地了解自己的生活。人性中交织着的光明与黑暗，像一只浑身长满刺的刺猬，离得太远会感觉到寒冷，而靠得太近则害怕被刺扎到。朋友圈就像过年走亲戚，即便你心中有一万个不痛快，总是不愿意撕破脸，或屏蔽对方，或不给对方看，或仅展示最后三天，于是通讯录里的联系人越来越多，朋友圈越来越大，可再不会有能真正触动你内心的”小红点”出现，人类让一个产品变得越来越复杂，然后说它无法满足人类的需求，这大概是一开始就始料不及的吧！</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&emsp;&emsp;有人说，人性远比计算机编程更复杂，因为即使是人类迄今为止最伟大的发明——计算机，在面对人类的自然语言时同样会张惶失措 。人类有多少语言存在着模棱两可的含义，我认为语言是人类最大的误解，人类时常喜欢揣测语言背后隐藏的含义，好像在沟通时表达清晰的含义会让人类没有面子，更不用说网络上流行的猜测女朋友真实意图的案例。金庸先生的武侠小说《射雕英雄传》里，在信息闭塞的南宋时期，江湖上裘千丈的一句鬼话，就搅得整个武林天翻地覆。其实，一两句话说清楚不好吗？黄药师、全真七子、江南六怪间的种种纠葛，哪一场不是误会？一众儿武功震古烁今的武林高手，怎么没有丝毫的去伪存真的能力，语言造成了多少误会。</p><p>&emsp;&emsp;可即便人类的语言复杂得像一本无字天书，可人类还是从这些语言中寻觅到蛛丝马迹。古人有文王”拘而演周易”、东方朔测字卜卦，这种带有”迷信”色彩的原始崇拜，就如同今天人们迷信星座运势一般，都是人类在上千年的演变中不断对经验进行总结和训练的结果。如此说起来，我们的人工智能未尝不是一种更加科学化的”迷信”，因为数据和算法让我们在不断地相信，这一切都是真实地。生活在数字时代的我们，无疑是悲哀的，一面努力地在别人面前隐藏真实地自己，一面不无遗憾地感慨自己无处遁逃，每一根数字神经都紧紧地联系着你和我，你不能渴望任何一部数字设备具备真正的智能，可你生命里的每个瞬间，都在悄然间被数据地折射出来。</p><p>&emsp;&emsp;今天这篇文章会基于 Python 对微信好友进行数据分析，这里选择的维度主要有：性别、头像、签名、位置，主要采用图表和词云两种形式来呈现结果，其中，对文本类信息会采用词频分析和情感分析两种方法。常言道：工欲善其事，必先利其器也。在正式开始这篇文章前，简单介绍下本文中使用到的第三方模块：</p><ul><li><a href="https://github.com/littlecodersh/itchat" target="_blank" rel="noopener">itchat</a>：微信网页版接口封装Python版本，在本文中用以获取微信好友信息。</li><li><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba</a>：结巴分词的 Python 版本，在本文中用以对文本信息进行分词处理。</li><li><a href="https://matplotlib.org/" target="_blank" rel="noopener">matplotlib</a>： Python 中图表绘制模块，在本文中用以绘制柱形图和饼图</li><li><a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">snownlp</a>：一个 Python 中的中文分词模块，在本文中用以对文本信息进行情感判断。</li><li><a href="http://www.pythonware.com/products/pil/" target="_blank" rel="noopener">PIL</a>： Python 中的图像处理模块，在本文中用以对图片进行处理。</li><li><a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a>： Python中 的数值计算模块，在本文中配合 <a href="https://amueller.github.io/word_cloud/" target="_blank" rel="noopener">wordcloud</a> 模块使用。</li><li><a href="https://amueller.github.io/word_cloud/" target="_blank" rel="noopener">wordcloud</a>： Python 中的词云模块，在本文中用以绘制词云图片。</li><li><a href="https://github.com/Tencent-YouTu/Python_sdk" target="_blank" rel="noopener">TencentYoutuyun</a>：腾讯优图提供的 Python 版本 SDK ，在本文中用以识别人脸及提取图片标签信息。<br>以上模块均可通过 pip 安装，关于各个模块使用的详细说明，请自行查阅各自文档。</li></ul><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>&emsp;&emsp;分析微信好友数据的前提是获得好友信息，通过使用 itchat 这个模块，这一切会变得非常简单，我们通过下面两行代码就可以实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">itchat.auto_login(hotReload = <span class="keyword">True</span>)</span><br><span class="line">friends = itchat.get_friends(update = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;同平时登录网页版微信一样，我们使用手机扫描二维码就可以登录，这里返回的friends对象是一个集合，第一个元素是当前用户。所以，在下面的数据分析流程中，我们始终取friends[1:]作为原始输入数据，集合中的每一个元素都是一个字典结构，以我本人为例，可以注意到这里有Sex、City、Province、HeadImgUrl、Signature这四个字段，我们下面的分析就从这四个字段入手：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180223205004843" alt="好友信息结构展示" title="">                </div>                <div class="image-caption">好友信息结构展示</div>            </figure><h2 id="好友性别"><a href="#好友性别" class="headerlink" title="好友性别"></a>好友性别</h2><p>&emsp;&emsp;分析好友性别，我们首先要获得所有好友的性别信息，这里我们将每一个好友信息的Sex字段提取出来，然后分别统计出Male、Female和Unkonw的数目，我们将这三个数值组装到一个列表中，即可使用matplotlib模块绘制出饼图来，其代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseSex</span><span class="params">(firends)</span>:</span></span><br><span class="line">    sexs = list(map(<span class="keyword">lambda</span> x:x[<span class="string">'Sex'</span>],friends[<span class="number">1</span>:]))</span><br><span class="line">    counts = list(map(<span class="keyword">lambda</span> x:x[<span class="number">1</span>],Counter(sexs).items()))</span><br><span class="line">    labels = [<span class="string">'Unknow'</span>,<span class="string">'Male'</span>,<span class="string">'Female'</span>]</span><br><span class="line">    colors = [<span class="string">'red'</span>,<span class="string">'yellowgreen'</span>,<span class="string">'lightskyblue'</span>]</span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>,<span class="number">5</span>), dpi=<span class="number">80</span>)</span><br><span class="line">    plt.axes(aspect=<span class="number">1</span>) </span><br><span class="line">    plt.pie(counts, <span class="comment">#性别统计结果</span></span><br><span class="line">            labels=labels, <span class="comment">#性别展示标签</span></span><br><span class="line">            colors=colors, <span class="comment">#饼图区域配色</span></span><br><span class="line">            labeldistance = <span class="number">1.1</span>, <span class="comment">#标签距离圆点距离</span></span><br><span class="line">            autopct = <span class="string">'%3.1f%%'</span>, <span class="comment">#饼图区域文本格式</span></span><br><span class="line">            shadow = <span class="keyword">False</span>, <span class="comment">#饼图是否显示阴影</span></span><br><span class="line">            startangle = <span class="number">90</span>, <span class="comment">#饼图起始角度</span></span><br><span class="line">            pctdistance = <span class="number">0.6</span> <span class="comment">#饼图区域文本距离圆点距离</span></span><br><span class="line">    )</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>,)</span><br><span class="line">    plt.title(<span class="string">u'%s的微信好友性别组成'</span> % friends[<span class="number">0</span>][<span class="string">'NickName'</span>])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里简单解释下这段代码，微信中性别字段的取值有Unkonw、Male和Female三种，其对应的数值分别为0、1、2。通过Collection模块中的Counter()对这三种不同的取值进行统计，其items()方法返回的是一个元组的集合，该元组的第一维元素表示键，即0、1、2，该元组的第二维元素表示数目，且该元组的集合是排序过的，即其键按照0、1、2 的顺序排列，所以通过map()方法就可以得到这三种不同取值的数目，我们将其传递给matplotlib绘制即可，这三种不同取值各自所占的百分比由matplotlib计算得出。下图是matplotlib绘制的好友性别分布图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180223205838851" alt="微信好友性别分析" title="">                </div>                <div class="image-caption">微信好友性别分析</div>            </figure></p><p>&emsp;&emsp;看到这个结果，我一点都不觉得意外，男女比例严重失衡，这虽然可以解释我单身的原因，可我不觉得通过调整男女比例就能解决问题，好多人认为自己单身是因为社交圈子狭小，那么是不是扩展了社交圈子就能摆脱单身呢？我觉得或许这样会增加脱单的概率，可幸运之神应该不会眷顾我，因为我的好运气早在我24岁以前就消耗完啦。在知乎上有一个热门的话题：<a href="https://www.zhihu.com/question/55744630" target="_blank" rel="noopener">现在的男性是否普遍不再对女性展开追求了？</a>，其实哪里会有人喜欢孤独呢？无非是怕一次又一次的失望罢了。有的人并不是我的花儿，我只是恰好途径了她的绽放。曾经有人说我是一个多情的人，可她永远不会知道，我做出的每一个决定都炽热而悲壮。所谓”慧极必伤，情深不寿；谦谦君子，温润如玉”，世人苦五毒者大抵如此。</p><h2 id="好友头像"><a href="#好友头像" class="headerlink" title="好友头像"></a>好友头像</h2><p>&emsp;&emsp;分析好友头像，从两个方面来分析，第一，在这些好友头像中，使用人脸头像的好友比重有多大；第二，从这些好友头像中，可以提取出哪些有价值的关键字。这里需要根据HeadImgUrl字段下载头像到本地，然后通过<a href="http://youtu.qq.com/#/home" target="_blank" rel="noopener">腾讯优图</a>提供的人脸识别相关的API接口，检测头像图片中是否存在人脸以及提取图片中的标签。其中，前者是分类汇总，我们使用饼图来呈现结果；后者是对文本进行分析，我们使用词云来呈现结果。关键代码如下 所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseHeadImage</span><span class="params">(frineds)</span>:</span></span><br><span class="line">    <span class="comment"># Init Path</span></span><br><span class="line">    basePath = os.path.abspath(<span class="string">'.'</span>)</span><br><span class="line">    baseFolder = basePath + <span class="string">'\\HeadImages\\'</span></span><br><span class="line">    <span class="keyword">if</span>(os.path.exists(baseFolder) == <span class="keyword">False</span>):</span><br><span class="line">        os.makedirs(baseFolder)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Analyse Images</span></span><br><span class="line">    faceApi = FaceAPI()</span><br><span class="line">    use_face = <span class="number">0</span></span><br><span class="line">    not_use_face = <span class="number">0</span></span><br><span class="line">    image_tags = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>,len(friends)):</span><br><span class="line">        friend = friends[index]</span><br><span class="line">        <span class="comment"># Save HeadImages</span></span><br><span class="line">        imgFile = baseFolder + <span class="string">'\\Image%s.jpg'</span> % str(index)</span><br><span class="line">        imgData = itchat.get_head_img(userName = friend[<span class="string">'UserName'</span>])</span><br><span class="line">        <span class="keyword">if</span>(os.path.exists(imgFile) == <span class="keyword">False</span>):</span><br><span class="line">            <span class="keyword">with</span> open(imgFile,<span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">                file.write(imgData)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Detect Faces</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        result = faceApi.detectFace(imgFile)</span><br><span class="line">        <span class="keyword">if</span> result == <span class="keyword">True</span>:</span><br><span class="line">            use_face += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            not_use_face += <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Extract Tags</span></span><br><span class="line">        result = faceApi.extractTags(imgFile)</span><br><span class="line">        image_tags += <span class="string">','</span>.join(list(map(<span class="keyword">lambda</span> x:x[<span class="string">'tag_name'</span>],result)))</span><br><span class="line">    </span><br><span class="line">    labels = [<span class="string">u'使用人脸头像'</span>,<span class="string">u'不使用人脸头像'</span>]</span><br><span class="line">    counts = [use_face,not_use_face]</span><br><span class="line">    colors = [<span class="string">'red'</span>,<span class="string">'yellowgreen'</span>,<span class="string">'lightskyblue'</span>]</span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>,<span class="number">5</span>), dpi=<span class="number">80</span>)</span><br><span class="line">    plt.axes(aspect=<span class="number">1</span>) </span><br><span class="line">    plt.pie(counts, <span class="comment">#性别统计结果</span></span><br><span class="line">            labels=labels, <span class="comment">#性别展示标签</span></span><br><span class="line">            colors=colors, <span class="comment">#饼图区域配色</span></span><br><span class="line">            labeldistance = <span class="number">1.1</span>, <span class="comment">#标签距离圆点距离</span></span><br><span class="line">            autopct = <span class="string">'%3.1f%%'</span>, <span class="comment">#饼图区域文本格式</span></span><br><span class="line">            shadow = <span class="keyword">False</span>, <span class="comment">#饼图是否显示阴影</span></span><br><span class="line">            startangle = <span class="number">90</span>, <span class="comment">#饼图起始角度</span></span><br><span class="line">            pctdistance = <span class="number">0.6</span> <span class="comment">#饼图区域文本距离圆点距离</span></span><br><span class="line">    )</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>,)</span><br><span class="line">    plt.title(<span class="string">u'%s的微信好友使用人脸头像情况'</span> % friends[<span class="number">0</span>][<span class="string">'NickName'</span>])</span><br><span class="line">    plt.show() </span><br><span class="line"></span><br><span class="line">    image_tags = image_tags.encode(<span class="string">'iso8859-1'</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    back_coloring = np.array(Image.open(<span class="string">'face.jpg'</span>))</span><br><span class="line">    wordcloud = WordCloud(</span><br><span class="line">        font_path=<span class="string">'simfang.ttf'</span>,</span><br><span class="line">        background_color=<span class="string">"white"</span>,</span><br><span class="line">        max_words=<span class="number">1200</span>,</span><br><span class="line">        mask=back_coloring, </span><br><span class="line">        max_font_size=<span class="number">75</span>,</span><br><span class="line">        random_state=<span class="number">45</span>,</span><br><span class="line">        width=<span class="number">800</span>, </span><br><span class="line">        height=<span class="number">480</span>, </span><br><span class="line">        margin=<span class="number">15</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    wordcloud.generate(image_tags)</span><br><span class="line">    plt.imshow(wordcloud)</span><br><span class="line">    plt.axis(<span class="string">"off"</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里我们会在当前目录新建一个HeadImages目录，用以存储所有好友的头像，然后我们这里会用到一个名为FaceApi类，这个类由腾讯优图的SDK封装而来，这里分别调用了<a href="http://youtu.qq.com/#/develop/api-face-analysis-detect" target="_blank" rel="noopener">人脸检测</a>和<a href="http://youtu.qq.com/#/develop/api-image-tag" target="_blank" rel="noopener">图像标签识别</a>两个API接口，前者会统计”使用人脸头像”和”不使用人脸头像”的好友各自的数目，后者会累加每个头像中提取出来的标签。其分析结果如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180224095139638" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>&emsp;&emsp;可以注意到，在所有微信好友中，约有接近1/4的微信好友使用了人脸头像， 而有接近3/4的微信好友没有人脸头像，这说明在所有微信好友中对”颜值 “有自信的人，仅仅占到好友总数的25%，或者说75%的微信好友行事风格偏低调为主，不喜欢用人脸头像做微信头像。这是否说明”好看的皮囊”并非是千篇一律，长得好看的人实在是少数中的少数。所以，当女生的妆容越来越向着”韩式半永久粗平眉”、”瓜子脸”和”大红唇”靠拢的时候，当男生的服饰越来越向着”大背头”、”高领毛衣”和”长款大衣”靠拢的时候，我们能不能真正得个性一次。生命中有太多被世俗绑架着的事情，既要和别人不一样 ，同时还要和大多数人一样，这是人生在世的无可奈何。考虑到腾讯优图并不能真正得识别”人脸”，我们这里对好友头像中的标签再次进行提取，来帮助我们了解微信好友的头像中有哪些 关键词，其分析结果如图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180224100011424" alt="微信好友头像标签词云展示" title="">                </div>                <div class="image-caption">微信好友头像标签词云展示</div>            </figure></p><p>&emsp;&emsp;通过词云，我们可以发现：在微信好友中的签名词云中，出现频率相对较高的关键字有：女孩、树木、房屋、文本、截图、卡通、合影、天空、大海。这说明在我的微信好友中，好友选择的微信头像主要有日常、旅游、风景、截图四个来源，好友选择的微信头像中风格以卡通为主，好友选择的微信头像中常见的要素有天空、大海、房屋、树木。通过观察所有好友头像，我发现在我的微信好友中，使用个人照片作为微信头像的有15人，使用网络图片作为微信头像的有53人，使用动漫图片作为微信头像的有25人，使用合照图片作为微信头像的有3人，使用孩童照片作为微信头像的有5人，使用风景图片作为微信头像的有13人，使用女孩照片作为微信头像的有18人，基本符合图像标签提取的分析结果。</p><h2 id="好友签名"><a href="#好友签名" class="headerlink" title="好友签名"></a>好友签名</h2><p>&emsp;&emsp;分析好友签名，签名是好友信息中最为丰富的文本信息，按照人类惯用的”贴标签”的方法论，签名可以分析出某一个人在某一段时间里状态，就像人开心了会笑、哀伤了会哭，哭和笑两种标签，分别表明了人开心和哀伤的状态。这里我们对签名做两种处理，第一种是使用用结巴分词进行分词后生成词云，目的是了解好友签名中的关键字有哪些，哪一个关键字出现的频率相对较高；第二种是使用SnowNLP分析好友签名中的感情倾向，即好友签名整体上是表现为正面的、负面的还是中立的，各自的比重是多少。这里提取Signature字段即可，其核心代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseSignature</span><span class="params">(friends)</span>:</span></span><br><span class="line">    signatures = <span class="string">''</span></span><br><span class="line">    emotions = []</span><br><span class="line">    pattern = re.compile(<span class="string">"1f\d.+"</span>)</span><br><span class="line">    <span class="keyword">for</span> friend <span class="keyword">in</span> friends:</span><br><span class="line">        signature = friend[<span class="string">'Signature'</span>]</span><br><span class="line">        <span class="keyword">if</span>(signature != <span class="keyword">None</span>):</span><br><span class="line">            signature = signature.strip().replace(<span class="string">'span'</span>, <span class="string">''</span>).replace(<span class="string">'class'</span>, <span class="string">''</span>).replace(<span class="string">'emoji'</span>, <span class="string">''</span>)</span><br><span class="line">            signature = re.sub(<span class="string">r'1f(\d.+)'</span>,<span class="string">''</span>,signature)</span><br><span class="line">            <span class="keyword">if</span>(len(signature)&gt;<span class="number">0</span>):</span><br><span class="line">                nlp = SnowNLP(signature)</span><br><span class="line">                emotions.append(nlp.sentiments)</span><br><span class="line">                signatures += <span class="string">' '</span>.join(jieba.analyse.extract_tags(signature,<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'signatures.txt'</span>,<span class="string">'wt'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">         file.write(signatures)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sinature WordCloud</span></span><br><span class="line">    back_coloring = np.array(Image.open(<span class="string">'flower.jpg'</span>))</span><br><span class="line">    wordcloud = WordCloud(</span><br><span class="line">        font_path=<span class="string">'simfang.ttf'</span>,</span><br><span class="line">        background_color=<span class="string">"white"</span>,</span><br><span class="line">        max_words=<span class="number">1200</span>,</span><br><span class="line">        mask=back_coloring, </span><br><span class="line">        max_font_size=<span class="number">75</span>,</span><br><span class="line">        random_state=<span class="number">45</span>,</span><br><span class="line">        width=<span class="number">960</span>, </span><br><span class="line">        height=<span class="number">720</span>, </span><br><span class="line">        margin=<span class="number">15</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    wordcloud.generate(signatures)</span><br><span class="line">    plt.imshow(wordcloud)</span><br><span class="line">    plt.axis(<span class="string">"off"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    wordcloud.to_file(<span class="string">'signatures.jpg'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Signature Emotional Judgment</span></span><br><span class="line">    count_good = len(list(filter(<span class="keyword">lambda</span> x:x&gt;<span class="number">0.66</span>,emotions)))</span><br><span class="line">    count_normal = len(list(filter(<span class="keyword">lambda</span> x:x&gt;=<span class="number">0.33</span> <span class="keyword">and</span> x&lt;=<span class="number">0.66</span>,emotions)))</span><br><span class="line">    count_bad = len(list(filter(<span class="keyword">lambda</span> x:x&lt;<span class="number">0.33</span>,emotions)))</span><br><span class="line">    labels = [<span class="string">u'负面消极'</span>,<span class="string">u'中性'</span>,<span class="string">u'正面积极'</span>]</span><br><span class="line">    values = (count_bad,count_normal,count_good)</span><br><span class="line">    plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'simHei'</span>] </span><br><span class="line">    plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="keyword">False</span></span><br><span class="line">    plt.xlabel(<span class="string">u'情感判断'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">u'频数'</span>)</span><br><span class="line">    plt.xticks(range(<span class="number">3</span>),labels)</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>,)</span><br><span class="line">    plt.bar(range(<span class="number">3</span>), values, color = <span class="string">'rgb'</span>)</span><br><span class="line">    plt.title(<span class="string">u'%s的微信好友签名信息情感分析'</span> % friends[<span class="number">0</span>][<span class="string">'NickName'</span>])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过词云，我们可以发现：在微信好友的签名信息中，出现频率相对较高的关键词有：努力、长大、美好、快乐、生活、幸福、人生、远方、时光、散步。果然我的微信好友都是温暖、正直的好青年啊！ :smile:其实，签名这个设定，从某种程度上是在反映人的一种心态，人在年轻时不免”为赋新词强说愁”，等到你真正到了这个精神境界，突然发现年轻时图样图森破，或许这就是我们不愿意让别人了解过去的原因，因为伴随着人的成长，某一种瞬间的状态简直不忍直视，QQ空间陪伴了我们这代人的整个青春，令人印象深刻的”那年今日”功能，有时让我们感到回忆的温暖，有时让我们感到岁月的萧杀，”当时只道是寻常”的物是人非，”回首向来萧瑟处”的淡定从容，”今夕复何夕”的失落惆怅……都在这一行行签名里留下深深浅浅的印记。在知乎上有关于<a href="https://www.zhihu.com/topic/19665970/hot" target="_blank" rel="noopener">签名</a>的话题讨论，对此感兴趣的朋友不妨找时间看看。:smile:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/201802241102499" alt="微信好友签名信息词云展示" title="">                </div>                <div class="image-caption">微信好友签名信息词云展示</div>            </figure><p>&emsp;&emsp;通过柱状图，我们可以发现：在微信好友的签名信息中，正面积极的情感判断约占到55.56%，中立的情感判断约占到32.10%，负面消极的情感判断约占到12.35%。这个结果和我们通过词云展示的结果基本吻合，这说明在微信好友的签名信息中，约有87.66%的签名信息，传达出来都是一种积极向上的态度。朋友圈中基本上有两类用户，第一类用户使用朋友圈记录自己的生活，第二类用户使用朋友圈输出自己的观点。显然，对于第二类用户，它并不介意别人了解它的过去，它更在乎它从始至终输出的观点是否一致。所以，不管朋友圈里别人在或晒美食、或晒旅游、或秀恩爱、或晒宝宝、或煲鸡汤等等，在我看来这都是一种生活方式，精神层次和物质层次比你高的人群，觉得你朋友圈里的内容”无趣”，这是符合人类一贯的认知方式的，在大多数情况下，反而是那些和你层次差不多的人群，对不熟悉的人或者事物妄加判断，如果你不喜欢我朋友圈里的内容，请直接屏蔽我就好，因为这样我们还可以做朋友；如果你因为喜欢A而在我这里和我说B不好，这就真的是三观不合啦。我相信没有完全兴趣匹配的两个人，即使是男女朋友或者情侣之间，总之人与人相处嘛，真诚和互相尊重是基本要求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180224120700356" alt="微信好友签名信息情感分析展示" title="">                </div>                <div class="image-caption">微信好友签名信息情感分析展示</div>            </figure><h2 id="好友位置"><a href="#好友位置" class="headerlink" title="好友位置"></a>好友位置</h2><p>&emsp;&emsp;分析好友位置，主要通过提取Province和City这两个字段。Python中的地图可视化主要通过Basemap模块，这个模块需要从国外网站下载地图信息，使用起来非常的不便。百度的<a href="http://echarts.baidu.com/" target="_blank" rel="noopener">ECharts</a>在前端使用的比较多，虽然社区里提供了<a href="http://pyecharts.org/" target="_blank" rel="noopener">pyecharts</a>项目，可我注意到因为政策的改变，目前Echarts不再支持导出地图的功能，所以地图的定制方面目前依然是一个问题，主流的技术方案是配置全国各省市的JSON数据，这里博主使用的是<a href="https://me.bdp.cn/home.html" target="_blank" rel="noopener">BDP个人版</a>，这是一个零编程的方案，我们通过Python导出一个CSV文件，然后将其上传到BDP中，通过简单拖拽就可以制作可视化地图，简直不能再简单，这里我们仅仅展示生成CSV部分的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseLocation</span><span class="params">(friends)</span>:</span></span><br><span class="line">    headers = [<span class="string">'NickName'</span>,<span class="string">'Province'</span>,<span class="string">'City'</span>]</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'location.csv'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>,newline=<span class="string">''</span>,) <span class="keyword">as</span> csvFile:</span><br><span class="line">        writer = csv.DictWriter(csvFile, headers)</span><br><span class="line">        writer.writeheader()</span><br><span class="line">        <span class="keyword">for</span> friend <span class="keyword">in</span> friends[<span class="number">1</span>:]:</span><br><span class="line">           row = &#123;&#125;</span><br><span class="line">           row[<span class="string">'NickName'</span>] = friend[<span class="string">'NickName'</span>]</span><br><span class="line">           row[<span class="string">'Province'</span>] = friend[<span class="string">'Province'</span>]</span><br><span class="line">           row[<span class="string">'City'</span>] = friend[<span class="string">'City'</span>]</span><br><span class="line">           writer.writerow(row)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;下图是BDP中生成的微信好友地理分布图，可以发现：我的微信好友主要集中在宁夏和陕西两个省份。数字时代的神经牵动着每一个社交关系链的人，我们想要竭力去保护的那点隐私，在这些数据中一点点地折射出来。人类或许可以不断地伪装自己，可这些从数据背后抽离出来的规律和联系不会欺骗人类。数学曾经被人称为最没有用的学科，因为生活中并不需要神圣而纯粹的计算，在不同的学科知识里，经验公式永远比理论公式更为常用。可是此时此刻，你看，这世界就像一只滴滴答答转动着的时钟，每一分每一秒都是严丝合缝的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180223234011645" alt="微信好友地理分布图" title="">                </div>                <div class="image-caption">微信好友地理分布图</div>            </figure></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;写这篇文章的时候，我一直不知道该如何下笔，因为微信是一个神奇的存在，它是一个国民级别的全民APP，所以，微信的产品设计一直都是一个有趣的现象，从最初底部Tab的数目、每个Tab的名称、”发现”页面的定制、小程序入口、朋友圈入口到朋友圈评论等等一系列的设计细节，都是值得我们透过人性和心理去研究的。即使是被人们封神的”张小龙”，在面对结构最为复杂的中国用户群体的时候，他的潇洒中依旧不免充满无奈，从对朋友圈的置之不理就可以看出，这是一个怎么做都不会让人满意的功能，任何一个生态在面对巨大的用户群体的时候，功能的增减就会变成一个难题，所谓”林子大了什么鸟都有”，知乎面对的是同样的问题，营销类公众号在不断消费社会话题的同时，引导着一批又一批粉丝的价值取向，人类总渴望着别人了解自己，可人类真的了解自己吗？这篇博客是我对数据分析的又一次尝试，主要从性别、头像、签名、位置四个维度，对微信好友进行了一次简单的数据分析，主要采用图表和词云两种形式来呈现结果。总而言之一句话，”数据可视化是手段而并非目的”，重要的不是我们在这里做了这些图出来，而是从这些图里反映出来的现象，我们能够得到什么本质上的启示，我一位朋友问我怎么什么都想抓取，为什么啊，因为我不懂人类啊！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据分析" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="http://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="Wechat" scheme="http://qinyuanpei.github.io/tags/Wechat/"/>
    
      <category term="matplotlib" scheme="http://qinyuanpei.github.io/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>使用Python生成博客目录并自动更新README</title>
    <link href="http://qinyuanpei.github.io/posts/1329254441/"/>
    <id>http://qinyuanpei.github.io/posts/1329254441/</id>
    <published>2018-02-23T09:32:45.000Z</published>
    <updated>2018-06-04T06:11:50.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是：<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。首先在这里祝大家春节快乐，作为过完年以后的第一篇文章，博主想写点内容风格相对轻松的内容。自从博主的博客采用 <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">TravisCI</a> 提供的持续集成(CI)服务以以来，博客的更新部署变得越来越简单，所有的流程都被简化为Git工作流下的<strong>提交(commit)</strong>和<strong>推送(push)</strong>操作。考虑到博客是托管在 <a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener">Github</a> 上的，一直希望可以自动更新仓库主页的README文件，这样可以显示每次提交代码后的变更历史。基于这样一个构想，我想到了为博客生成目录并自动更新README，其好处是可以为读者建立良好的文档导航，而且Markdown是一种简单友好的文档格式，Github等代码托管平台天生就支持Markdown文档的渲染。关于博客采用 <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">TravisCI</a>  提供持续集成(CI)服务相关内容，可以参考 <a href="https://qinyuanpei.github.io/posts/3521618732/">持续集成在Hexo自动化部署上的实践</a> 这篇文章。</p><p>&emsp;&emsp;好了，现在考虑如何为博客生成目录，我们这里需要三个要素，即标题、链接和时间。标题和时间可以直接从 <strong>_posts</strong> 目录下的Markdown文档中读取出来，链接从何而来呢？我最初想到的办法是读取每个Markdown文档的文件名，因为我的使用习惯是采用英文命名，这样当博客的<strong>永久链接(permalink)</strong>采用默认的<strong>:year/:month/:day/:title/</strong>形式时，每个Markdown文档的文件名等价于文章链接。事实证明这是一个愚蠢的想法，因为当你改变了<strong>永久链接(permalink)</strong>的形式时，这种明显投机的策略就会彻底的失败。相信你在浏览器种打开这篇文章时，已然注意到链接形式发生了变化，当然这是我们在稍后的文章中讨论的话题啦。至此，我们不得不寻找新的思路，那么这个问题该如何解决呢？</p><p>&emsp;&emsp;我意识到我的博客配置了 <a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="noopener">hexo-generator-json-content</a> 插件，这个插件最初的目的是为博客提供离线的搜索能力，该插件会在博客的根目录里生成一个<strong>content.json</strong>文件，而这个文件中含有我们想要的一切信息，因此我们的思路转变为解析这个文件，人生苦短啊，我果断选择了我最喜欢的Python，这里我们会提取出所有的文章信息，按照日期由近到远排序后生成列表。Python强大到让我觉得这篇文章无法下笔，所以这里直接给出代码啦：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文档实体结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,date,link,title)</span>:</span></span><br><span class="line">        self.date  = date</span><br><span class="line">        self.link  = link</span><br><span class="line">        self.title = title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTitle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLink</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'https://qinyuanpei.github.io/'</span> + self.link</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDate</span><span class="params">(self)</span>:</span></span><br><span class="line">        d = re.findall(<span class="string">r'\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;'</span>,self.date)[<span class="number">0</span>]</span><br><span class="line">        t = re.findall(<span class="string">r'\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;'</span>,self.date)[<span class="number">0</span>]</span><br><span class="line">        dt = <span class="string">'%s %s'</span> % (d,t)</span><br><span class="line">        <span class="keyword">return</span> datetime.datetime.strptime(dt,<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从JSON中加载文档数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadData</span><span class="params">()</span>:</span></span><br><span class="line">    json_file = open(<span class="string">'./public/content.json'</span>,<span class="string">'rb'</span>)</span><br><span class="line">    json_data = json.load(json_file)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> json_data:</span><br><span class="line">        <span class="keyword">yield</span> Post(item[<span class="string">'date'</span>],item[<span class="string">'path'</span>],item[<span class="string">'title'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从列表生成Markdown文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkMarkdown</span><span class="params">(items)</span>:</span></span><br><span class="line">    mdfile = open(<span class="string">'README.md'</span>,mode=<span class="string">'wt'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    itemTpl = <span class="string">'* &#123;0&#125; - [&#123;1&#125;](&#123;2&#125;)\n'</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        mdfile.write(itemTpl.format(</span><br><span class="line">            datetime.datetime.strftime(item.getDate(),<span class="string">'%Y-%m-%d'</span>),</span><br><span class="line">            item.getTitle(),</span><br><span class="line">            item.getLink()</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(__name__ == <span class="string">"__main__"</span>):</span><br><span class="line">    items = sorted(loadData(),key=<span class="keyword">lambda</span> x:x.getDate(),reverse=<span class="keyword">True</span>)</span><br><span class="line">    mkMarkdown(items)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里需要注意的有两个地方，第一，从JSON中解析出来的日期形式为：<strong>2018-02-23T01:32:45.000Z</strong>。对于这个形式的日期，博主先后尝试了内建的time模块和第三方的datetime模块，发现均无法直接转换为日期类型，所以首先采用正则匹配出日期和时间，然后再组合为标准的<strong>%Y-%m-%d %H:%M:%S</strong>的格式，这样就可以使用datetime模块进行处理啦，我还是想吐槽人类对各种各样format的执着，这些通配符在不同的语言中存在差别，就像SQL和正则引擎或多或少地存在兼容性问题一样。如果有朋友知道如何对这种日期形式进行转换，欢迎在博客中评论留言，再次谢谢大家。第二，使用内置函数sorted()对数据进行排序，lambda表达式使用起来非常棒，因为默认是升序排列地，而我们需要的是日期由近到远，所以这里选择了降序排列。</p><p>&emsp;&emsp;现在我们更新博客时的流程将发生变化，首先通过 <strong>hexo generate 或 hexo g</strong>命令生成博客，这样Hexo会为我们生成 <strong> content.json</strong>，然后我们执行这段Python脚本，就可以生成REAMD.md文件，这里我们将这个文件推送到blog分支。相对应地，我们修改 <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">TravisCI</a> 的脚本文件 <strong>.travis.yml</strong> 文件如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script:</span><br><span class="line">  - hexo clean</span><br><span class="line">  - hexo generate</span><br><span class="line">  - cp README.md ./public/README.md</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;显然，这是告诉 TravisCI 在生成博客以后，将 README.md 文件复制到输出文件，这样当我们推送博客(指生成的静态页面)到 master 分支的时候，它会和 blog 分支同步共享同一份 README 。我想一定有朋友会问我，难道生成 README.md 文件的步骤不能交给 TravisCI 来处理？一定要在推送到 blog 分支以前手动地去执行脚本吗？我最初尝试过让 TravisCI 去执行这个 Python 脚本，可我发现一个残酷的事实时，我们这个虚拟机环境是 nodejs 的，这在我们定义 <strong>.travis.yml</strong> 文件时就指定了，因此这个环境中可能是没有 Python 支持的。起初我以为 Linux 系统自带 Python ， 因此尝试在 <strong>.travis.yml</strong> 文件中使用 pip 安装相关依赖，然后我发现持续集成服务华丽丽地挂了，因为 TravisCI 默认的 Python 版本是 Python2.7 , 除非我们指定的是一个 Python 的语言环境，所以这种想法不得不作罢，暂时就手动更新好啦。</p><p>&emsp;&emsp;好了，这篇文章核心的内容就这么多，下面想说些关于 Hexo 的延伸话题。 Hexo 是一个基于 nodejs 的静态博客生成器，按理说使用 nodejs 去扩展功能是最佳的实践方式，所以即使 Python 再强大，我们在这里看到的依然存在着天然的割裂感， 我们能不能将执行Python脚本的这个过程合并到 <strong>hexo generate 或者 hexo g</strong>这个步骤中去呢？ 通过官方文档中关于<a href="https://hexo.io/api/events.html" target="_blank" rel="noopener">事件</a>和<a href="https://hexo.io/api/events.html" target="_blank" rel="noopener">生成器</a>的描述，我们获得了两种新的思路，分别是在生成页面以后通过 child_process 模块调用 python 脚本、通过 Locals 变量获取全部文章信息后生成Markdown。从方案是否优雅的角度上来讲，我个人更倾向于第二种方案。基本的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案一</span></span><br><span class="line">hexo.on(<span class="string">'generateAfter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">post</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span>通过content.json文件生成markdown文档</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案二</span></span><br><span class="line">hexo.extend.generator.register(<span class="string">"markdown"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span>通过posts属性生成markdown文档</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;显然，我是不会写 nodejs 的，如果有时间和精力的话，我可能会考虑采用第二种方案写一个插件，可是像我这么懒的一个人，还是不要提前立 flag 啦，毕竟人生苦短呐，我都选择使用 Python 这门语言来写啦，我干嘛非要再花时间去迎合它呢？好啦，这篇文章就是这样啦，本文中的脚本可以到 <a href="https://github.com/qinyuanpei/BlogScripts/blob/master/HexoBlog.py" target="_blank" rel="noopener">这里</a> 来获取，本文生成的目录可以到 <a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener">这里</a> 来访问，再次谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="独立博客" scheme="http://qinyuanpei.github.io/categories/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Github" scheme="http://qinyuanpei.github.io/tags/Github/"/>
    
      <category term="Python" scheme="http://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="Script" scheme="http://qinyuanpei.github.io/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>愿你和我一样喜欢蛋炒饭</title>
    <link href="http://qinyuanpei.github.io/posts/1933583281/"/>
    <id>http://qinyuanpei.github.io/posts/1933583281/</id>
    <published>2018-02-10T16:12:25.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;周末花了一个晚上的时间看了部电影，由黄渤主演的《蛋炒饭》。有人说，这是一部刻意模仿《阿甘正传》的电影，充满胶片质感的纪录片风格，相似的镜头语言和表现手法，无一不在努力告诉你，这是一部本土化的《阿甘正传》。可是如同巧克力之于蛋炒饭，两种截然不同的食物会有不同的味道，电影所反映的实则是两种不同的内涵。如果说《阿甘正传》代表的是极具美国精神的励志故事，那么《蛋炒饭》代表的则是小人物为理想打拼的乌托邦。说《蛋炒饭》是本土化的《阿甘正传》其实不无道理，因为电影里充满了太多相似，这种在由时代感打磨出的细腻的情感，让我觉得这是一部值得一看的电影。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211094000741" alt="电影《阿甘正传》经典开头" title="">                </div>                <div class="image-caption">电影《阿甘正传》经典开头</div>            </figure><p>&emsp;&emsp;电影开头苏茉莉坐在游乐园长凳上自下而上的长镜头，不禁让人联想到《阿甘正传》的开场，联想到那片空中摇曳着的羽毛；电影中反复出现的台词，来自大卫父亲的那句：做蛋炒饭要慢要慢，一如《阿甘正传》里的经典台词：人生就像一盒巧克力，你永远不知道下一块会是哪种？电影令我印象深刻的地方，在于它具厚重的时代感，中美建交、改革开放、金融危机、邓丽君、摇滚音乐、周杰伦、周笔畅……看起来王大卫好像和阿甘一样，参与并影响了众多历史事件。可我的理解是，阿甘最终成为了流浪街头的大富翁，而王大卫一直一无所有，因为他一辈子都在做一件事情，那就是做蛋炒饭。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/201802110925019" alt="最美好的年纪" title="">                </div>                <div class="image-caption">最美好的年纪</div>            </figure><p>&emsp;&emsp;整个电影采用的是倒叙的表现手法。主人公王大卫是一个智商不太高，而且有语言表达障碍的“傻子”，他第一次出场是替好兄弟打抱不平，结果他就像星爷《功夫》里的少年一样，以为自己的武功盖世无双，结果自然是被人打得头破血流；他书包里藏着的“复仇”的板砖，在外国友人访华的时候，一板砖破坏了中美友谊，结果自然是被校长通报批评；他家祖上是宫廷御厨，父亲即将退休食堂安排他去顶岗，一心想做厨师的他差点烧了厨房，结果自然是迫使父亲替他求情以保住工作；他从小喜欢的女孩苏茉莉要和好兄弟发生关系，她吻了他一下叫他在门口把风，结果自然是茉莉被渣男欺骗然后甩了他；他用母亲变卖古董的钱来了饭店，好兄弟嫉妒他做了老板，骗走他的产业后远走高飞，结果自然是他从老板变成杂工。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211094910921" alt="有些爱就像一阵风" title="">                </div>                <div class="image-caption">有些爱就像一阵风</div>            </figure><p>&emsp;&emsp;看这个电影的时候，我一直觉得人生是绝望的，父母先后离开人世，哥哥在面前自杀而死，喜欢的女生抛弃自己，好兄弟发小欺骗自己……周围人对他全部是冷嘲热讽，每次发工资的时候，嘲弄他什么时候攒够钱赎回饭店；每次娱乐圈有绯闻传来的时候，说他“媳妇”苏茉莉又登上杂志封面；“好兄弟“因为金融危机背负债务，他就拎着辛苦攒下的一袋子零钱去帮他还债，结果半夜“好兄弟”开着车跑了……我不知道，我们该不该认同这种无条件“傻”的行为，电影想告诉我们的或许是“以德报怨，以德服人”这种儒家的传统思想，即在复杂的社会中，如何以一种淳朴单纯的心态，追寻本心，不畏曲折。所谓“众生虽苦，诸恶莫作”，这个社会复杂险恶是现实，可温润善良则是一种选择。我们抱怨时代给我们选择狭窄，因为我们放弃了那些艰难的选择，最终选择大多数人选择的那条路。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211095932714" alt="李红兵：人都是会变的" title="">                </div>                <div class="image-caption">李红兵：人都是会变的</div>            </figure><p>&emsp;&emsp;可我还是想说，无条件的善良是懦弱，我们选择善良，是因为我们不想伤害别人，可在今天这样一个时代，善良常常被当做是懦弱的表现，一个人努力让心变狠变硬，或许会达到通常意义上的成功，可成功的定义从来都是被人绑架着的，电影中“好兄弟”登上了“胡弄排行榜”，我不知道这是不是导演的一种讽刺，一个人靠着骗取好兄弟的产业而发家，即使收获了声名和利益，当他一个人在高速公路上疾驶，打算远走他乡的时候，内心是不是会有一点羞愧和遗憾呢？我们说，这是一部乌托邦式的电影，因为现实中像李红兵这样的人，绝对不会陡然间良心发现，把饭店归还王大卫，甚至王大卫拉开窗帘阳光照射进来，阳光下苏茉莉牵着女儿的手对他微笑，大卫的蛋炒饭得到溥仪认可，入选国际非遗名录……我宁愿相信，这是一种美好的理想。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211092759718" alt="大卫做蛋炒饭" title="">                </div>                <div class="image-caption">大卫做蛋炒饭</div>            </figure><p>&emsp;&emsp;大卫在电影中做过三次蛋炒饭，第一次是他顶替父亲的岗位到食堂工作，结果想做厨师的他差点烧了厨房，付出的代价是，因为御厨身份而自豪的父亲，向一辈子没低过头的食堂经理低头；第二次是他陪苏茉莉到医院流产，打完胎的苏茉莉说自己饿，他冒着被饭店人追打的危险，给苏茉莉做了一份蛋炒饭，付出的代价是，苏茉莉同他告别，独自到南方发展演艺事业；第三次是李红兵归还了饭店，成名后的王大卫，当着记者的面做了一次蛋炒饭，溥仪评价大卫的蛋炒饭，比他爷爷做得还要好，蛋炒饭入选国际非遗名录。大卫的一生都在做一件事情，那就是做蛋炒饭，这种专注是他和阿甘不一样的地方，在一个浮躁的时代，我们每天都在追逐都在忙碌，可我们追逐的是什么呢？或许是一盘蛋炒饭的安宁，从这个角度来说，蛋炒饭这种食物，真的是质朴而简单的存在啦。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211094532546" alt="有些人像你生命里的天使" title="">                </div>                <div class="image-caption">有些人像你生命里的天使</div>            </figure><p>&emsp;&emsp;如果你看过《阿甘正传》这部电影，会觉得苏茉莉和珍妮这两个角色是相似的。她们看起来都知道自己想要些什么，苏茉莉选择发展演艺事业进入娱乐圈，珍妮一直知道自己想要什么，她想做一名歌手，为了唱歌吃尽苦头，在酒吧、街头甚至任何可以唱歌的地方，只有有场合给她吉他，她就可以唱，甚至为了唱歌而穷困潦倒到卖身吸毒……她可以真挚地给成名的阿甘一个拥抱，而不愿依附他达到自己成名的目的，她深爱阿甘的同时，深知阿甘不会同自己结婚，因为童年的经历让她内心无比自卑，她始终打不开心里的结，她选择为阿甘生下孩子，这是一种自我成全。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211094252365" alt="愿茉莉一直这样美好" title="">                </div>                <div class="image-caption">愿茉莉一直这样美好</div>            </figure><p>&emsp;&emsp;苏茉莉成名后取艺名苏菲，据说这个人物原型来自王菲，苏茉莉在成名过程中不断豪门势力，从最初回北京办演唱会拉赞助，到嫁入豪门以后受不了娱乐圈绯闻骚扰，进而宣布退出娱乐圈回到北京，她是一个不知道自己想要什么的人，直到故事最后她终于发现，原来那个深爱着自己的人，一直就在默默地等自己回来。所以对比两部电影中的女主，就可以发现，两部电影阐述的观点是截然相反的，即阿甘是迷茫的，而珍妮是坚定的；王大卫是坚定的，而苏茉莉是迷茫的。当你不知道想要什么的时候，不妨慢下来做份蛋炒饭，或许你就会找到答案。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211104230957" alt="你饿不饿，我做蛋炒饭给你吃呀" title="">                </div>                <div class="image-caption">你饿不饿，我做蛋炒饭给你吃呀</div>            </figure><p>&emsp;&emsp;故事接近尾声的时候，王大卫再次登上三个人从小便常去的城楼，猛然间看到三个孩子正在那里玩耍，孩子们说这是他们的地盘，王大卫还是像从前一样，知趣地准备转身离开，阳光照耀城楼的刹那，我分明看见他脸上满意的笑容，那种历经沧桑后初心不改的从容。每个人，都既注定的命运，同时有偶然，两者都在同时发生，就像那片羽毛，努力飘啊飘啊，终于飘到阿甘脚下，然后又无可奈何的飘离阿甘。羽毛不是飞鸟，无法掌控飞行的方向，其实很想和你在一起，但偏偏风把距离吹得好远。如果可以的话，我想你和我一样，都喜欢蛋炒饭。你饿不饿，我做蛋炒饭给你吃呀？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="蛋炒饭" scheme="http://qinyuanpei.github.io/tags/%E8%9B%8B%E7%82%92%E9%A5%AD/"/>
    
  </entry>
  
  <entry>
    <title>基于Python实现Windows下壁纸切换功能</title>
    <link href="http://qinyuanpei.github.io/posts/2822230423/"/>
    <id>http://qinyuanpei.github.io/posts/2822230423/</id>
    <published>2018-02-05T16:48:39.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;在过去一年多的时间里，我尝试改变博客的写作风格，努力让自己不再写教程类文章，即使在这个过程中，不断地面临着写作内容枯竭的痛苦。因为我渐渐地意识到，告诉别人如何去做一件事情，始终停留在”术”的层面，而比这个更为重要的是，告诉别人为什么要这样做，这样就可以过渡到”道”的层面。古人云：形而上者谓之道，形而下者谓之器。我们常常希望通过量变来产生质变，可是如果在这个过程中不能及时反思和总结，我们认为的努力或许仅仅是重复的劳作而已。如你所见，在这篇文章里，我们将通过Python和Windows注册表实现壁纸切换功能，主要涉及到的Python中的requests、pyinstaller这两个模块的使用，希望大家喜欢。</p><h1 id="故事缘由"><a href="#故事缘由" class="headerlink" title="故事缘由"></a>故事缘由</h1><p>&emsp;&emsp;人们常常相信事出有因，可这世界上有些事情，哪里会有什么原因啊，比如喜欢与不喜欢。做这样一个小功能的初衷，起源于我对桌面壁纸的挑剔。作为一个不完全的强迫症患者，我需要花费大量时间去挑选一张壁纸，丝毫不亚于在网上挑选一件喜欢的商品。我注意到知乎上有这样的话题：<a href="https://www.zhihu.com/question/22857942" target="_blank" rel="noopener">有哪些无版权图片网站值得推荐？</a>，因此对于桌面壁纸的筛选，我渐渐地开始摆脱对搜索引擎的依赖，我个人比较喜欢<a href="https://www.pexels.com" target="_blank" rel="noopener">Pexels</a>和<a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a>这两个网站，所以我想到了从这两个网站抓取图片来设置Windows壁纸的方案。市面上类似的商业软件有<a href="http://bizhi.baidu.com/" target="_blank" rel="noopener">百度壁纸</a>、<a href="http://bizhi.sogou.com/index.html" target="_blank" rel="noopener">搜狗壁纸</a>等，可这些软件都不纯粹，或多或少地掺杂了额外功能，个中缘由想来大家都是知道的。联想到微信最新版本的更新，”发现”页面支持所有项目的隐藏，甚至是盟友京东的电商入口和腾讯最赚钱的游戏入口，这让我开始正视腾讯这家公司，我收回曾经因为抄袭对腾讯产生的不满，腾讯是一家值得尊重的互联网公司。做一个纯粹的应用程序，这就是我的初心。</p><h1 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h1><p>&emsp;&emsp;好了，现在我们考虑如何来实现这个功能，我们的思路是从<a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a>这个网站抓取图片，并将其存储在指定路径，然后通过Windows API完成壁纸的设置。Python脚本会通过pyinstaller模块打包成可执行文件，我们通过修改注册表的方式，在右键菜单内加入切换壁纸的选项，这样我们可以直接通过右键菜单实现壁纸切换功能。在编写脚本的时候，起初想到的是抓包这样的常规思路，因为请求过程相对复杂而失败，后来意外地发现官方提供了API接口。事实上<a href="https://www.pexels.com" target="_blank" rel="noopener">Pexels</a>和<a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a>都提供了API接口，通过调用这些API接口，我们的探索进行得非常顺利，下面是具体脚本实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Query Images</span></span><br><span class="line">searchURL = <span class="string">'https://unsplash.com/napi/search?client_id=%s&amp;query=%s&amp;page=1'</span></span><br><span class="line">client_id = <span class="string">'fa60305aa82e74134cabc7093ef54c8e2c370c47e73152f72371c828daedfcd7'</span></span><br><span class="line">categories = [<span class="string">'nature'</span>,<span class="string">'flowers'</span>,<span class="string">'wallpaper'</span>,<span class="string">'landscape'</span>,<span class="string">'sky'</span>]</span><br><span class="line">searchURL = searchURL % (client_id,random.choice(categories))</span><br><span class="line">response = requests.get(searchURL)</span><br><span class="line">print(<span class="string">u'正在从Unsplash上搜索图片...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse Images</span></span><br><span class="line">data = json.loads(response.text)</span><br><span class="line">results = data[<span class="string">'photos'</span>][<span class="string">'results'</span>]</span><br><span class="line">print(<span class="string">u'已为您检索到图片共%s张'</span> % str(len(results)))</span><br><span class="line">results = list(filter(<span class="keyword">lambda</span> x:float(x[<span class="string">'width'</span>])/x[<span class="string">'height'</span>] &gt;=<span class="number">1.33</span>,results))</span><br><span class="line">result = random.choice(results)</span><br><span class="line">resultId = str(result[<span class="string">'id'</span>])</span><br><span class="line">resultURL = result[<span class="string">'urls'</span>][<span class="string">'regular'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download Images</span></span><br><span class="line">print(<span class="string">u'正在为您下载图片:%s...'</span> % resultId)</span><br><span class="line">basePath = sys.path[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span>(os.path.isfile(basePath)):</span><br><span class="line">    basePath = os.path.dirname(basePath)</span><br><span class="line">baseFolder = basePath + <span class="string">'\\Download\\'</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> path.exists(baseFolder)):</span><br><span class="line">    os.makedirs(baseFolder)</span><br><span class="line">jpgFile = baseFolder + resultId + <span class="string">'.jpg'</span></span><br><span class="line">bmpFile = baseFolder + resultId + <span class="string">'.bmp'</span></span><br><span class="line">response = requests.get(resultURL)</span><br><span class="line"><span class="keyword">with</span> open(jpgFile,<span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(response.content)</span><br><span class="line">img = Image.open(jpgFile)</span><br><span class="line">img.save(bmpFile,<span class="string">'BMP'</span>)</span><br><span class="line">os.remove(jpgFile)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这部分代码非常简单，需要关注的地方有：第一，这个API对应的密钥是公共的，即所有人都可以使用，这里随机从指定的分类中去搜索图片。第二，这里使用filter()函数过滤出宽高比超过1.33的图片，即分辨率为1366 * 768的图片。这里需要注意的是，在Python3.X下filter需要转化为list，否则会引发一个异常。第三，下载的图片默认为JPEG格式，而Windows下设置壁纸使用的是位图格式，即BMP格式，所以在这里我们使用PIL模块来完成格式转换。这里需要注意的是，PIL模块目前不支持Python3.X以后的版本，我们这里使用的是Pillow模块，该模块可以通过pip直接完成安装。</p><p>&emsp;&emsp;现在，我们将壁纸下载到本地以后，就可以着手设置壁纸相关的工作。这些工作主要借助为win32api和win32gui这两个内置模块，我们一起来看具体代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">u'正在设置图片:%s为桌面壁纸...'</span> % resultId)</span><br><span class="line">key = win32api.RegOpenKeyEx(win32con.HKEY_CURRENT_USER,</span><br><span class="line">    <span class="string">"Control Panel\\Desktop"</span>,<span class="number">0</span>,win32con.KEY_SET_VALUE)</span><br><span class="line">win32api.RegSetValueEx(key, <span class="string">"WallpaperStyle"</span>, <span class="number">0</span>, win32con.REG_SZ, <span class="string">"2"</span>) </span><br><span class="line"><span class="comment">#2拉伸适应桌面,0桌面居中</span></span><br><span class="line">win32api.RegSetValueEx(key, <span class="string">"TileWallpaper"</span>, <span class="number">0</span>, win32con.REG_SZ, <span class="string">"0"</span>)</span><br><span class="line">win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, bmpFile, <span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line">print(<span class="string">u'成功应用图片:%s为桌面壁纸'</span>  % resultId)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这部分内容非常简单，基本没有复杂的东西在里面。接下来我们需要通过pyinstaller模块将脚本打包成可执行文件，实际上这个步骤完全可以省略，因为现在我们通过命令行就可以实现壁纸切换，为什么要做这样额外的工作呢？考虑到Windows下GUI更为便捷一点，所以我们打包成可执行文件，主要是为了给右键菜单添加功能，我们最终点击想要实现的功能是，点击右键菜单就可以完成壁纸的切换。首先通过pip安装pyinstaller模块，在终端下执行命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install pyinstaller</span><br></pre></td></tr></table></figure></p><p>安装完成后按照<a href="http://www.pyinstaller.org/" target="_blank" rel="noopener">官方</a>文档即可在./dist/目录中找到生成的可执行文件，如果打包出错可以修改Python根目录下的./Scripts/pyinstaller-script.py文件，修改第一行Python.exe的路径，删除两端的引号即可，如下图所示。关于pyinstaller模块打包时的详细参数设定，请自行查阅官方文档。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180207140459403" alt="pyinstaller-script.py文件" title="">                </div>                <div class="image-caption">pyinstaller-script.py文件</div>            </figure><p>&emsp;&emsp;现在，在生成可执行文件以后，我们打开注册表，定位到以下节点：<br><strong>计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</strong>，然后创建一级子节点WallPaper，其默认值填写”更换壁纸”，接下来创建二级子节点command，注意这个名称不能修改，其默认值填写可执行文件路径，本例中为：E:\Software\WallPaper\main.exe，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180207140515219" alt="为右键菜单增加" 更换壁纸"选项"="" title="">                </div>                <div class="image-caption">为右键菜单增加"更换壁纸"选项</div>            </figure><p>&emsp;&emsp;好了，现在我们可以看看在右键菜单中增加”更换壁纸”选项以后的效果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180207143108184" alt="最终效果" title="">                </div>                <div class="image-caption">最终效果</div>            </figure></p><h1 id="文本小结"><a href="#文本小结" class="headerlink" title="文本小结"></a>文本小结</h1><p>&emsp;&emsp;本文使用Python实现了Windows下切换壁纸的功能，通过requests模块从网络上抓取图片，通过PIL模块实现JPEG格式到BMP格式的转换，通过win32api和win32gui模块实现壁纸设置，并通过修改注册表的方式，将这一功能整合到系统菜单中，可以非常便捷地更换桌面壁纸。作为一个设计上的扩展，我们需要考虑更多的问题，比如当网络断开的时候如何避免异常，如何接入更多的在线图库API，如何支持可配置的图片分类信息以及如何将修改注册表的过程自动化等等，这些问题博主会利用空闲时间去解决，今天这篇文章就是这样啦，本文源代码可以通过<a href="https://github.com/qinyuanpei/WallPaper" target="_blank" rel="noopener">这里</a>获取，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="脚本" scheme="http://qinyuanpei.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="Windows" scheme="http://qinyuanpei.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出理解Python装饰器</title>
    <link href="http://qinyuanpei.github.io/posts/2829333122/"/>
    <id>http://qinyuanpei.github.io/posts/2829333122/</id>
    <published>2018-01-23T15:55:13.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。今天我想和大家一起探讨的话题是Python中的装饰器。因为工作关系最近这段时间在频繁地使用Python，而我渐渐意识到这是一个非常有趣的话题。无论是在Python标准库还是第三方库中，我们越来越频繁地看到装饰器的身影，从某种程度上而言，Python中的装饰器是Python进阶者的一条必由之路，正确合理地使用装饰器可以让我们的开发如虎添翼。装饰器天然地和函数式编程、设计模式、AOP等概念产生联系，这更加让我对Python中的这个特性产生兴趣。所以，在这篇文章中我将带领大家一起来剖析Python中的装饰器，希望对大家学习Python有所帮助。</p><h1 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h1><p>&emsp;&emsp;什么是装饰器？这是一个问题。在我的认知中，装饰器是一种语法糖，其本质就是函数。我们注意到Python具备函数式编程的特征，譬如lambda演算，map、filter和reduce等高阶函数。在函数式编程中，函数是一等公民，即“一切皆函数”。Python的函数式编程特性由早期版本通过渐进式开发而来，所以对“一切皆对象”的Python来说，函数像普通对象一样使用，这是自然而然的结果。为了验证这个想法，我们一起来看下面的示例。</p><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line">func = square</span><br><span class="line"><span class="keyword">print</span> func    <span class="comment">#&lt;function square at 0x01FF9FB0&gt;</span></span><br><span class="line"><span class="keyword">print</span> func(<span class="number">5</span>) <span class="comment">#25</span></span><br></pre></td></tr></table></figure><p>可以注意到，我们将一个函数直接赋值给一个变量，此时该变量表示的是一个函数对象的实例，什么叫做函数对象呢？就是说你可以将这个对象像函数一样使用，所以当它带括号和参数时，表示立即调用一个函数；当它不带括号和参数时，表示一个函数。在C#中我们有一个相近的概念被称为委托，而委托本质上是一个函数指针，即表示指向一个方法的引用，从这个角度来看，C#中的委托类似于这里的函数对象，因为Python是一个动态语言，所以我们可以直接将一个函数赋值给一个对象，而无需借助Delegate这样的特殊类型。</p><ul><li><p>使用函数作为参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_square</span><span class="params">(f,m,n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(m) + f(n)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">print</span> sum_square(square,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">#25</span></span><br></pre></td></tr></table></figure></li><li><p>使用函数作为返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_wrapper</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n * n</span><br><span class="line">    <span class="keyword">return</span> square</span><br><span class="line">    </span><br><span class="line">wrapper = square_wrapper()</span><br><span class="line"><span class="keyword">print</span> wrapper(<span class="number">5</span>) <span class="comment">#25</span></span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;既然在Python中存在函数对象这样的类型，可以让我们像使用普通对象一样使用函数。那么，我们自然可以将函数推广到普通对象适用的所有场合，即考虑让函数作为参数和返回值，因为普通对象都都具备这样的能力。为什么要提到这两点呢？因为让函数作为参数和返回值，这不仅是函数式编程中高阶函数的基本概念，而且是闭包、匿名方法和lambda等特性的理论基础。从ES6中的箭头函数、Promise、React等可以看出，函数式编程在前端开发中越来越流行，而这些概念在原理上是相通的，这或许为我们学习函数式编程提供了一种新的思路。在这个示例中，<strong>sum_square()</strong>和<strong>square_wrapper()</strong>两个函数，分别为我们展示了使用函数作为参数和返回值的可行性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(m)</span>:</span></span><br><span class="line">    n = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> m + n</span><br><span class="line">    <span class="keyword">return</span> outer</span><br><span class="line"></span><br><span class="line">func = outer(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> func() <span class="comment">#15</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#内函数修改外函数局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(a)</span>:</span></span><br><span class="line">    b = [<span class="number">10</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        b[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a + b[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> func() <span class="comment">#16</span></span><br><span class="line"><span class="keyword">print</span> func() <span class="comment">#17</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对Python这门语言来说，这里的outer()函数和inner()函数分别被称为外函数和内函数，变量n的定义不在inner()函数内部，因此变量n称为inner()函数的环境变量。在Python中，一个函数及其环境变量就构成了闭包(<strong>Closure</strong>)。要理解闭包我认为我们可以把握这三点：第一，外函数返回了内函数的引用，即我们调用outer()函数时返回的是inner()函数的引用；第二，外函数将自己的局部变量绑定到内函数，其中变量b的目的是展示如何在内函数中修改环境变量；第三，调用内函数意味着发生出、入栈，不同的是每次调用都共享同一个闭包变量，请参考第二个示例。好了，现在讲完闭包以后，我们就可以开始说Python中的装饰器啦。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>&emsp;&emsp;装饰器是一种高级Python语法，装饰器可以对一个函数、方法或者类进行加工。所以，装饰器就像女孩子的梳妆盒，经过一番打扮后，可以让女孩子更漂亮。装饰器使用起来是非常简单的，其难点主要在如何去写一个装饰器。带着这个问题，我们来一起看看Python中的装饰器是如何工作的，以及为什么我们说装饰器的本质就是函数。早期的Python中并没有装饰器这一语法，最早出在Python 2.5版本中且仅仅支持函数的装饰，在Python 2.6及以后版本中装饰器被进一步用于类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_print</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*arg)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> arg</span><br><span class="line">        <span class="keyword">return</span> func(*arg)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_print</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x+y,array)</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> sum(data)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们注意到装饰器可以使用def来定义，装饰器接收一个函数对象作为参数，并返回一个新的函数对象。装饰器通过名称绑定，让同一个变量名指向一个新返回的函数对象，这样就达到修改函数对象的目的。在使用装饰器时，我们通常会在新函数内部调用旧函数，以保留旧函数的功能，这正是“装饰”一词的由来。在定义好装饰器以后，就可以使用@语法了，其实际意义时，将被修饰对象作为参数传递给装饰器函数，然后将装饰器函数返回的函数对象赋给原来的被修饰对象。装饰器可以实现代码的可复用性，即我们可以用同一个装饰器修饰多个函数，以便实现相同的附加功能。在这个示例中，我们定义了一个decorator_print的装饰器函数，它负责对一个函数func进行修饰，在调用函数func以前执行print语句，进而可以帮助我们调试函数中的参数，通过@语法可以让我们使用一个名称去绑定一个函数对象。在这里，它的调用过程可以被分解为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = decorator_print(sum)</span><br><span class="line"><span class="keyword">print</span> sum()</span><br></pre></td></tr></table></figure></p><p>接下来，我们再来写一个统计代码执行时长的装饰器decorator_watcher:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_watcher</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*arg)</span>:</span></span><br><span class="line">        t1 = time.time()</span><br><span class="line">        result = func(*arg)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        print(<span class="string">'time:'</span>,t2-t1)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p><p>此时我们可以使用该装饰器来统计sum()函数执行时长：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator_watcher</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x+y,array)</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> sum(data)</span><br></pre></td></tr></table></figure></p><p>现在，这个装饰器打印出来的信息格式都是一样的，我们无法从终端中分辨它对应哪一个函数，因此考虑给它增加参数以提高辨识度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_watcher</span><span class="params">(funcName=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*arg)</span>:</span></span><br><span class="line">            t1 = time.time()</span><br><span class="line">            result = func(*arg)</span><br><span class="line">            t2 = time.time()</span><br><span class="line">            print(<span class="string">'%s time:'</span> % funcName,t2-t1)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_watcher('sum')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x+y,array)</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> sum(data)</span><br></pre></td></tr></table></figure></p><p>装饰器同样可以对类进行修饰，譬如我们希望某一个类支持单例模式，在C#中我们定义泛型类Singleton<t>。下面演示如何通过装饰器来实现这一功能：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">instances = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInstance</span><span class="params">(aClass, *args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> aClass <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">        instances[aClass] = aClass(*args)</span><br><span class="line">    <span class="keyword">return</span> instances[aClass]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(aClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onCall</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getInstance(aClass,*args)</span><br><span class="line">    <span class="keyword">return</span> onCall</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,hours,rate)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.hours = hours</span><br><span class="line">        self.rate = rate</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.hours * self.rate</span><br></pre></td></tr></table></figure></t></p><p>&emsp;&emsp;除此以外，Python标准库中提供了诸如classmethod、staticmethod、property等类装饰器，感兴趣的读者朋友可以自行前去研究，这里不再赘述。</p><h1 id="装饰器与设计模式"><a href="#装饰器与设计模式" class="headerlink" title="装饰器与设计模式"></a>装饰器与设计模式</h1><p>&emsp;&emsp;装饰器可以对函数、方法和类进行修改，同时保证原有功能不受影响。这自然而然地让我想到面向切面编程(<strong>AOP</strong>)，其核心思想是，以非侵入的方式，在方法执行前后插入代码片段，以此来增强原有代码的功能。面向切面编程(<strong>AOP</strong>)通常通过代理模式(静态/动态)来实现，而与此同时，在Gof提出的“设计模式”中有一种设计模式被称为装饰器模式，这两种模式的相似性，让我意识到这会是一个有趣的话题，所以在接下来的部分，我们将讨论这两种设计模式与装饰器的内在联系。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>&emsp;&emsp;<strong>代理模式</strong>，属于23种设计模式中的结构型模式，其核心是为真实对象提供一种代理来控制对该对象的访问。在这里我们提到了<strong>真实对象</strong>，这就要首先引出代理模式中的三种角色，即<strong>抽象对象</strong>、<strong>代理对象</strong>和<strong>真实对象</strong>。其中：</p><ul><li><strong>抽象对象</strong>：通过接口或抽象类声明真实角色实现的业务方法。</li><li><strong>代理对象</strong>：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法。</li><li><strong>真实对象</strong>：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</li></ul><p>&emsp;&emsp;下面是一个典型的代理模式UML图示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180202094102971" alt="代理模式" title="">                </div>                <div class="image-caption">代理模式</div>            </figure></p><p>&emsp;&emsp;通过UML图我们可以发现，代理模式通过代理对象隐藏了真实对象，实现了调用者对真实对象的访问控制，即调用者无法直接接触到真实对象。“代理”这个词汇是一个非常生活化的词汇，因为我们可以非常容易地联系到生活种的中介这种角色，譬如租赁房屋时会存在房屋中介这种角色，租客(<strong>调用者</strong>)通过中介(<strong>代理对象</strong>)来联系房东(<strong>真实对象</strong>)，这种模式有什么好处呢？中介(<strong>代理对象</strong>)的存在隔离了租客(<strong>调用者</strong>)与房东(<strong>真实对象</strong>)，有效地保护了房东(<strong>真实对象</strong>)的个人隐私，使其免除了频繁被租客(调用者)骚扰的困惑，所以代理模式的强调的是<strong>控制</strong>。</p><p>&emsp;&emsp;按照代理机制上的不同来划分，代理模式可以分为<strong>静态代理</strong>和<strong>动态代理</strong>。前者是将<strong>抽象对象</strong>、<strong>代理对象</strong>和<strong>真实对象</strong>这三种角色在编译时就确定下来。对于C#这样的静态强类型语言而言，这意味着我们需要手动定义出这些类型；而后者则是指在运行时期间动态地创建代理类，譬如Unity、Ca’stle、Aspect Core以及ASP.NET中都可以看到这种技术的身影，即所谓的“动态编织”技术，通过反射机制和修改IL代码来达到动态代理的目的。通常意义上的代理模式，都是指静态代理，下面我们一起来看代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RealSubject</span> : <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"我是RealSubject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProxySubject</span> : <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ISubject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过示例代码，我们可以注意到，在代理对象ProxySubject中持有对ISubject接口的引用，因此它可以代理任何实现了ISubject接口的类，即真实对象。在Request()方法中我们调用了真实对象的Request()方法，实际上我们可以在代理对象中增加更多的细节，譬如在Request()方法执行前后插入指定的代码，这就是面向切面编程(<strong>AOP</strong>)的最基本的原理。在实际应用中，主要以动态代理最为常见，Java中提供了InvocationHandler接口来实现这一接口，在.NET中则有远程调用(<strong>Remoting Proxies</strong>)、<strong>ContextBoundObject</strong>和<strong>IL织入</strong>等多种实现方式。从整体而言，生成代理类和子类化是常见的两种思路。相比静态代理，动态代理机制相对复杂，不适合在这里展开来说，感兴趣的朋友可以去做进一步的了解。</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>&emsp;&emsp;<strong>装饰器模式</strong>，同样是一种结构型模式，其核心是为了解决由继承引发的“类型爆炸”问题。我们知道，通过继承增加子类就可以扩展父类的功能，可随着业务复杂性的不断增加，子类变得越来越多，这就会引发“类型爆炸”问题。<strong>装饰器模式</strong>就是一种用以代替继承的技术，即无需通过继承增加子类就可以扩展父类的功能，同时不改变原有的结构。在《西游记》中孙悟空和二郎神斗法，孙悟空变成了一座庙宇，这是对原有功能的一种扩展，因为孙悟空的本质依然是只猴子，不同的是此刻具备了庙宇的功能。这就是装饰器模式。下面，我们一起来看一个生活中的例子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180202130527268" alt="咖啡种类" title="">                </div>                <div class="image-caption">咖啡种类</div>            </figure><p>&emsp;&emsp;喜欢喝咖啡的朋友，看到这张图应该感到特别亲切，因为咖啡的种类的确是太多啦。在开始喝咖啡以前，我完全不知道咖啡会有这么多的种类，而且咖啡作为一种略显小资的饮品，其名称更是令人目不暇接，一如街头出现的各种女孩子喜欢的茶品饮料，有些当真是教人叫不出来名字。这是一个典型的“类型爆炸”问题，人们在吃喝上坚持不懈的追求，让咖啡的种类越来越多，这个时候继承反而变成了一种沉重的包袱，那么该如何解决这个问题呢？装饰器模式应运而生，首先来看装饰器模式的UML图示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180202113809724" alt="装饰器模式" title="">                </div>                <div class="image-caption">装饰器模式</div>            </figure></p><p>&emsp;&emsp;从这个图示中可以看出，装饰器和被装饰者都派生自同一个抽象类Component，而不同的Decorator具备不同的功能，DecoratorA可以为被装饰者扩展状态，DecoratorB可以为被装饰者扩展行为，可无论如何，被装饰者的本质不会发生变化，它还是一个Component。回到咖啡这个问题，我们发现这些咖啡都是由浓缩咖啡、水、牛奶、奶泡等组成，所以我们可以从一杯浓缩咖啡开始，对咖啡反复进行调配，直至搭配出我们喜欢的咖啡，这个过程就是反复使用装饰器进行装饰的过程，因此我们可以写出下面的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饮料抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Drink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Drink <span class="title">Mix</span>(<span class="params">Drink drink</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//牛奶装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MilkDecorator</span> : <span class="title">Drink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Drink milk;</span><br><span class="line">    MilkDecorator(Drink milk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.milk = milk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Drink <span class="title">Mix</span>(<span class="params">Drink coffee</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.Mix(<span class="keyword">this</span>.milk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//热水装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">WaterDecorator</span> : <span class="title">Drink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Drink water;</span><br><span class="line">    WaterDecorator(Drink water)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.water = water;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Drink <span class="title">Mix</span>(<span class="params">Drink coffee</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.Mix(<span class="keyword">this</span>.water);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一杯浓缩咖啡</span></span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> Coffee()</span><br><span class="line"><span class="comment">//咖啡里混入水</span></span><br><span class="line">coffee = <span class="keyword">new</span> WaterDecorator(<span class="keyword">new</span> Water()).Mix(coffee)</span><br><span class="line"><span class="comment">//咖啡里混入牛奶</span></span><br><span class="line">coffee = <span class="keyword">new</span> MilkDecorator(<span class="keyword">new</span> Milk()).Mix(coffee)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们演示了如何通过装饰器模式来调配出一杯咖啡，这里我没有写出具体的Coffee类。在实际场景中，我们还会遇到在咖啡里加糖或者配料来收费的问题，此时装饰器模式就可以帮助我们解决问题，不同的装饰器会对咖啡的价格进行修改，因此在应用完所有装饰器以后，我们就可以计算出最终这杯咖啡的价格。由此我们可以看出，装饰器模式强调的是<strong>扩展</strong>。什么是扩展呢，就是在不影响原来功能的基础上增加新的功能。</p><h2 id="区别和联系"><a href="#区别和联系" class="headerlink" title="区别和联系"></a>区别和联系</h2><p>&emsp;&emsp;代理模式和装饰器模式都是结构型的设计模式，两者在实现上是非常相似的。不同的地方在于，代理模式下调用者无法直接接触到真实对象，因此代理模式强调的是<strong>控制</strong>，即向调用者隐藏真实对象的信息，控制真实对象可以访问的范围；装饰器模式下，扩展功能的职责由子类转向装饰器，且装饰器与被装饰者通常是<strong>“同源”</strong>的，即派生自同一个父类或者是实现了同一个接口，装饰器关注的是增加被装饰者的功能，即<strong>扩展</strong>。两者的联系在于都需要持有一个<strong>“同源”</strong>对象的引用，譬如代理对象与真实对象同源，装饰器与被装饰者同源。从调用的层面上来讲，调用者无法接触到真实对象，它调用的始终是代理对象，对真实对象的内部细节一无所知，这是代理模式；调用者可以接触到装饰器和被装饰者，并且知道装饰器会对被装饰者产生什么样的影响，通常是从一个默认的对象开始”加工”，这是装饰器模式。</p><h1 id="装饰器与面向切面"><a href="#装饰器与面向切面" class="headerlink" title="装饰器与面向切面"></a>装饰器与面向切面</h1><p>&emsp;&emsp;这篇文章写到现在，我发觉我挖了一个非常大的坑，因为这篇文章中涉及到的概念实在太多，务求每一个概念都能讲得清楚透彻，有时候就像莫名立起来的flag，时间一长连我自己都觉得荒唐。有时候感觉内容越来越难写，道理越来越难同别人讲清楚。写作从一开始坚持到现在，就如同某些固执的喜欢一样，大概连我都不记得最初是为了什么吧。好了，现在来说说装饰器与面向切面。我接触Python装饰器的时候，自然而然想到的是.NET中的Attribute。我在越来越多的项目中使用Attribute，譬如ORM中字段与实体的映射规则、数据模型(<strong>Data Model</strong>)中字段的校验规则、RESTful API/Web API设计中的路由配置等，因为我非常不喜欢Java中近乎滥用的配置文件。</p><p>&emsp;&emsp;C#中的Attribute实际上是一种依附在目标(<strong>AttributeTargets</strong>)上的特殊类型，它无法通过new关键字进行实例化，它的实例化必须依赖所依附的目标，通过分析IL代码我们可以知道，Attribute并非是一种修饰符而是一种特殊的类，其方括号必须紧紧挨着所依赖的目标，构造函数以及对属性赋值均在圆括号内完成。相比较而言，Python中的装饰器就显得更为顺理成章些，因为Python中的装饰器本质就是函数，装饰器等价于用装饰器函数去修饰一个函数。函数修饰函数，听起来感觉不可思议，可当你理解了函数和普通对象一样，就不会觉得这个想法不可思议。有时回想起人生会觉得充满玄学的意味，大概是因为我们还没有学会把自己看得普通。</p><p>&emsp;&emsp;通过这篇文章的梳理，我们会发现一个奇妙的现象，Java的Spring框架采用了动态代理了实现AOP，而Python的装饰器简直就是天生的AOP利器，从原理上来讲，这两门语言会选择什么样的方案都说得通。Java是典型的面向对象编程的语言，所以不存在任何游离于Class以外的函数，代理模式对类型的要求更为强烈些，因为我必须限制或者说要求Proxy实现里面的方法，而装饰器模式相对更为宽松些，遇到Python这样的动态类型语言，自然会显得事半功倍。这说明一个道理，通往山顶的道路会有无数条，从中找出最为优雅的一条，是数学家毕生的心愿。AOP是一种思想，和语言无关，我常常听到Java的同学们宣称AOP和IOC在Java社区里如何流行，其实这些东西本来就是可以使用不同的方式去实现的，有些重要的东西，需要你剥离开偏见去认知。</p><p>&emsp;&emsp;关于C#中的Attribute和AOP如何去集成，在Unity和Aspect Core这两个框架中都有涉及，主流的AOP都在努力向这个方向去靠拢，Java中的注解同样不会跳出这个设定，因为编程技术到了今天，语言间的差别微乎其微，我至今依然可以听到，换一种语言就能让问题得到解决的声音，我想说，软件工程是没有银弹的，人类社会的复杂性会永远持续地存在下去，你看微信这样一个社交软件，其对朋友圈权限的粒度之细足以令人叹服。有朋友尝试在C#中借鉴Python的装饰器，并在一组文章中记录了其中的心得，这里分享给大家，希望对这个问题有兴趣的朋友，可以继续努力研究下去，AOP采用哪种方式实现重要吗？有人用它做权限控制，有人用它做日志记录……允许差异的存在，或许才是我们真正需要从这个世界里汲取的力量。</p><ul><li><p><a href="https://www.cnblogs.com/leven/archive/2009/12/28/decorator-csharp-1.html" target="_blank" rel="noopener">轻量级AOP框架-移植python的装饰器(Decorator)到C#(思考篇) </a></p></li><li><p><a href="http://www.cnblogs.com/leven/archive/2009/12/28/decorator-csharp-2.html" target="_blank" rel="noopener">轻量级AOP框架-移植python的装饰器(Decorator)到C#(编码篇) </a></p></li></ul><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文是博主学习Python时临时起意的想法，因为曾经有在项目中使用过AOP的经验，所以在学习Python中的装饰器的时候，自然而然地对这个特性产生了兴趣。有人说，装饰器是Python进阶的重要知识点。在今天这篇文章中，我们首先从Python中的函数引出”函数对象”这一概念，在阐述这个概念的过程中，穿插了函数式编程、高阶函数、lambda等等的概念，”函数是一等公民”，这句话在Python中出现时就是指装饰器，因为装饰器的本质就是函数。然后我们讨论了两种和装饰器有关的设计模式，即代理模式和装饰器模式，选择这两种模式来讨论，是因为我们在Java/C#和Python中看到了两种截然不同的实现AOP的思路，这部分需要花功夫去精心雕琢。博主有时候觉得力不从心，所以写作中有不周到的地方希望大家谅解，同时积极欢迎大家留言，这篇文章就先写到这里吧，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="AOP" scheme="http://qinyuanpei.github.io/tags/AOP/"/>
    
      <category term="装饰器" scheme="http://qinyuanpei.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>AI时代：聊聊大数据中的MapReduce</title>
    <link href="http://qinyuanpei.github.io/posts/2911923212/"/>
    <id>http://qinyuanpei.github.io/posts/2911923212/</id>
    <published>2018-01-19T00:45:08.000Z</published>
    <updated>2018-06-04T06:11:50.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>各位朋友，大家好，我是Payne，欢迎大家关注我的博客。最近读一本并行计算相关的书籍，在这本书中作者提到了MapReduce。相信熟悉大数据领域的朋友，一定都知道MapReduce是Hadoop框架中重要的组成部分。在这篇文章中，博主将以函数式编程作为切入点，来和大家聊一聊大数据中的MapReduce。如今人工智能正成为行业内竞相追逐的热点，选择MapReduce这个主题，更多的是希望带领大家一窥人工智能的门庭，更多深入的话题需要大家来探索和挖掘。</p><h1 id="MapReduce的前世今生"><a href="#MapReduce的前世今生" class="headerlink" title="MapReduce的前世今生"></a>MapReduce的前世今生</h1><p>MapReduce最早是由Google公司研究并提出的一种面向大规模数据处理的并行计算模型和方法。2003年和2004年，Google公司先后在国际会议上发表了关于Google分布式文件系统(GFS)和MapReduce的论文。这两篇论文公布了Google的GFS和MapReduce的基本原理和主要设计思想，我们通常所说的Google的三驾马车，实际上就是在说GFS、BigTable和MapReduce。因此，这些论文的问世直接催生了Hadoop的诞生，可以说今天主流的大数据框架如Hadoop、Spark等，无一不是受到Google这些论文的影响，而这正是MapReduce由来，其得名则是因为函数式编程中的两个内置函数: map()和reduce()。</p><p>我们常常说，脱离了业务场景去讨论一项技术是无意义的，这个原则在MapReduce上同样适用。众所周知，Google是一家搜索引擎公司，其设计MapReduce的初衷，主要是为了解决搜索引擎中大规模网页数据的并行化处理。所以，我们可以说，MapReduce其实是起源自Web检索的。而我们知道，Web检索可以分为两部分，即获取网页内容并建立索引、根据网页索引来处理查询关键字。我们可以认为互联网上的每个网页都是一个文档，而每个文档中都会有不同的关键字，Google会针对每一个关键字建立映射关系，即哪些文档中含有当前关键字，这是建立索引的过程。在建立索引以后，查询就会变得简单，因为现在我们可以按图索骥。</p><p>互联网诞生至今，网站及网页的数量越来越庞大，像Google这样的搜索引擎巨头是如何保证能够对Web上的内容进行检索的呢？答案是采用并行计算(<strong>Parallel</strong>)。硬件技术的不断革新，让计算机可以发挥多核的优势来处理数据，可当数据量庞大到单机无法处理的程度，就迫使我们不得不采用多台计算机进行并行计算。我们知道并行计算的思想是，将大数据分割成较小的数据块，交由不同的任务单元来处理，然后再将这些结果聚合起来。因此，可以将MapReduce理解为一种可以处理<strong>海量数据</strong>、运行在<strong>大规模集群</strong>上、具备<strong>高度容错</strong>能力、以<strong>并行处理</strong>方式执行的软件框架。MapReduce是分治思想在大规模机器集群时代的集中体现(<strong>如图所示</strong>)，其中，Mapper负责任务的划分，Reducer负责结果的汇总。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180119003729791" alt="MapReduce原理图" title="">                </div>                <div class="image-caption">MapReduce原理图</div>            </figure><p>MapReduce的推出给大数据并行处理带来了巨大的革命性影响，使其成为事实上的大数据处理的工业标准，是目前为止最为成功、最广为接受和最易于使用的大数据并行处理技术。广为人知的大数据框架Hadoop，正是受到MapReduce的启发。自问世来，成为Apache基金会下最重要的项目，受到全球学术界和工业界的普遍关注，并得到推广和普及应用。MapReduce的非凡意义在于，它提出了一个基于集群的高性能并行计算模型，允许使用市场上普通的商用服务器构成一个含有数十、数百甚至数千个节点的分布式并行计算集群，可以在集群节点上自动分配和执行任务以及收集计算结果，通过Mapper和Reducer提供了抽象的大数据处理并行编程接口，可以帮助开发人员更便捷地完成大规模数据处理的编程和计算工作。今天，Google有超过10000个不同的项目已采用MapReduce来实现。</p><h1 id="函数式编程与MapReduce"><a href="#函数式编程与MapReduce" class="headerlink" title="函数式编程与MapReduce"></a>函数式编程与MapReduce</h1><p>我们提到，MapReduce之得名，其灵感来自函数式编程中的两个内置函数：map()和reduce()。函数式编程中，有一个重要的概念叫做高阶函数，是指函数自身能够接受函数，并返回函数的一种函数。我们所熟悉的C#和Java都是典型的面向对象编程(<strong>OOP</strong>)的语言，在这类编程语言中类(<strong>Class</strong>)是第一等公民，即不允许有独立于类的结构出现在代码中。虽然微软从未公开表示C#支持函数式编程，可从LINQ中我们依然可以窥见高阶函数的身影，譬如我们熟悉的Select()、Where()等扩展方法，就可以让我们按照函数式编程的风格去编写代码，这正是为什么Java 8开始支持Stream API的原因。最经典的函数式编程语言当属Haskell语言，我们今天见到的各种编程语言，在考虑引入函数式编程风格的时候，或多或少地都会受到这门语言影响。当你开始适应函数作为第一等公民、高阶函数、柯里化以及惰性求值以后，你或许就会感受到函数式编程特有的美感。</p><p>这里我们选择Python来阐述函数式编程与MapReduce的关系。Python可以让我们轻易地在多种不同的编程风格间切换，事实上现在的编程语言都有向着混合式编程风格发展的趋势。我们提到MapReduce来自两个内置函数：map()和reduce()。其中，map()方法可以对指定集合中的元素按照指定函数进行映射，并将映射后的结果以集合形式返回。譬如我们有一个集合<strong>[1,3,5,7,9]</strong>，我们希望对集合中的每一个元素做平方运算。借助Python中的map()方法和lambda表达式，这个问题可以通过1行代码得到解决。同理，如果我们希望对该集合内的元素做求和运算，我们可以借助于Python中的reduce()方法，该方法位于functools模块中。在某些编程语言中该方法又被成为fold()方法，实际上这两种叫法是等价的，我们关注函数式编程的本质即可。什么是本质呢？当然是函数啦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">list = map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]) <span class="comment">#[1,9,25,49,81]</span></span><br><span class="line">sum = functools.reduce(<span class="keyword">lambda</span> x,y: x+y, [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]) <span class="comment">#25</span></span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line">好了，现在我们来分析下这两个函数，这将帮助我们更好地理解MapReduce。map()方法在这里被称为映射函数，它可以将一种类型映射为一种新的类型。举一个生活中的例子，譬如我们做菜的时候，必不可少的一个环节是将各种各样的食材切碎， 此时作用在这些食材的这个操作就是一个Map操作，你给Map一个洋葱就可以得到洋葱丝。同样地 ，你给Map一个番茄就可以得到番茄块。所以Map处理的原始数据，每条数据间没有相互联系，聪明的你告诉我洋葱和番茄有什么关系。相比map()方法，reduce()方法复杂的地方在于，它要求<span class="keyword">lambda</span>表达式中必须是两个参数。如果继续沿用做菜这个生活化的例子，reduce()方法是将Map操作中切好的食材混合在一起。假设我们要做一份辣椒酱，辣椒酱需要的材料有辣椒、姜和蒜，因此在第一步Map的时候，这些食材将具有相同的Key。对同一类数据，我们就可以使用reduce()进行左/右折叠操作，这相当于我们将同一道菜的食材一起放到锅里，所以 Reduce阶段处理的数据是以Key-Value形式组织的，同一个Key下的Value具有相关性。这样，从理论上它就完全符合函数式编程里的map()和reduce()啦。        </span><br><span class="line">                </span><br><span class="line"><span class="comment"># C#并行编程里的PLINQ</span></span><br><span class="line">关于MapReduce中一个经典案例是，统计不同文章中出现的关键字的频率。对这样一个问题，我们基本上可以想到下面四种方法：</span><br><span class="line">*  写一个单线程程序，顺序地遍历所有文章，然后统计每个关键字出现的频率。</span><br><span class="line">* 写一个多线程程序，并发地遍历所有文章，然后统计每个关键字出现的频率。</span><br><span class="line">* 写一个单线程程序，部署到N台不同的计算机上，然后将文章分割成N份分别输入，再由人工汇总N份结果。</span><br><span class="line">* 使用MapReduce，程序部署、任务划分、结果汇总全部交给框架去完成，我们定义好任务即可。</span><br><span class="line">通过对比，我们可以非常容易地分析出来，第一种方法最简单同时最耗时；第二种方法理论上比第一种高效，尤其是当计算机是多核或者多处理器的时候，缺点是要解决线程同步的问题；第三种方法初现集群的思想，可无法解决程序部署、任务划分和结果汇总等一系列问题；第四种方法本质上就是第三种方法， 可是MapReduce解决了第三种方法全部缺陷，所以它或许是目前最完美的方法。我们下面来考虑，如何模拟这个过程，因为博主不可能为了写一篇科普性质的文章，专门去准备一个Hadoop的开发环境啊，哈哈。</span><br><span class="line"></span><br><span class="line">PLINQ，即Parallel LINQ，是.NET <span class="number">4.0</span>中增加的任务并行库(**TPL**)中的一部分。并行编程中有两个基本的概念，**任务并行**和**数据并行**。前者是指，将程序分割成一组任务并使用不同的线程来运行不同的任务，这种方式被称为**任务并行**；而后者是指，将数据分割成较小的数据块，对这些数据进行并行计算，然后聚合这些计算结果，这种编程模型称为**数据并行**。伴随着并行算法的出现，并行集合相继而来，显然LINQ的并行版本就是PLINQ。这里我们来看一个使用PLINQ实现的词频统计代码，这将作为我们实现MapReduce的一个示例：</span><br><span class="line"></span><br><span class="line">```CSharp</span><br><span class="line">//Origin Texts</span><br><span class="line">string strTarget = @<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">//Map</span><br><span class="line">string[] words = strTarget.Split(<span class="string">' '</span>); </span><br><span class="line">ILookup&lt;string, int&gt; map = words.AsParallel().ToLookup(p =&gt; p, k =&gt; 1); </span><br><span class="line"></span><br><span class="line">//Reduce</span><br><span class="line">var reduce = <span class="keyword">from</span> IGrouping&lt;string, int&gt; wordMap <span class="keyword">in</span> map.AsParallel() </span><br><span class="line">                 where wordMap.Count() &gt; <span class="number">1</span> </span><br><span class="line">                 select new &#123; Word = wordMap.Key, Count = wordMap.Count() &#125;; </span><br><span class="line"></span><br><span class="line">//Show Results</span><br><span class="line">foreach (var word <span class="keyword">in</span> reduce) </span><br><span class="line"> Console.WriteLine(<span class="string">"Word: '&#123;0&#125;' : Count: &#123;1&#125;"</span>, word.Word, word.Count);</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>今天Google发布了全新的AI服务工具Cloud AutoML，从这个产品的名字就可以看出，这是一个试图将人工智能大众化的产品。目前AI是行业中不容置疑热点，国外的科技巨头如Google、微软，国内的科技巨头如腾讯、阿里和百度等，无一不在积极布局AI的上下游产业链。最近CSDN发布了人工智能方向的发展规划，整个产品线的基本都在做战略上调整，我们这些曾经的老用户被新的社区 运营搞得非常郁闷，因为所有的资源都在向着人工智能和区块链倾斜。上周在知乎上看到一篇讽刺国内区块链发展乱象的<a href="https://zhuanlan.zhihu.com/p/32796998" target="_blank" rel="noopener">文章</a>，大概就是说国人喜欢拿一个Token当做加密货币来买，实则连底层技术、分布账本、钱包等基础设施都没有。对于这一点我深有体会，任何新的商业模式在中国都火不过1年，譬如在2017年里被发扬广大的共享经济，有多少共享单车是靠技术和产品赢得市场的，我相信大部分都是沾了人口基数大的光。目前的人工智能，核心算法及技术都掌握在科技巨头手上。我们所追逐的人工智能，有多少是需要靠不断调整参数反复去训练来达到的呢？我觉得找到切实可靠的需求落脚点，比追逐一个又一个热点要更现实，我们大部分工程师都是在科学家工作的基础上做集成应用，所以拨开泡沫看清方向比盲目跟风更重要呀。</p><p>这篇文章蹭了人工智能的热点，其实它对MapReduce并没有做多少深入的研究。我们从Google的业务场景着手分析，思考为什么Google需要MapReduce，即提出MapReduce是为了解决一个什么样的问题？答案是为了适应Google在大规模Web检索业务方面的需要。通过梳理Web检索的一般流程，我们意识到，Web检索可以分为两部分，即获取网页内容并建立索引、根据网页索引来处理查询关键字，从而引出了Mapper和Reducer两个基本的数据处理单元，MapReduce是分治思想在大规模机器集群时代的集中体现，其中，Mapper负责任务的划分，Reducer负责结果的汇总。接下来，我们顺着函数式编程的思路，分析了函数式编程中的map()和reduce()，这两个核心的函数同MapReduce在思想上的一致性，这正是为了印证前文中MapReduce得名的由来。考虑到C#中提供了PLINQ，而在阅读《C#多线程编程》这本书时，同样提到了MapReduce这种并行计算模型，所以在这里将这两者进行结合，提供了一个通过并行计算统计单词频率的简单示例。以上就是这篇文章的所有内容了，如果大家对文章有什么意见或者建议，可以在文章评论区留言，这篇文章就是这样了，谢谢大家，晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="人工智能" scheme="http://qinyuanpei.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="AI" scheme="http://qinyuanpei.github.io/tags/AI/"/>
    
      <category term="MapReduce" scheme="http://qinyuanpei.github.io/tags/MapReduce/"/>
    
      <category term="FP" scheme="http://qinyuanpei.github.io/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>无问东西：你曾是少年</title>
    <link href="http://qinyuanpei.github.io/posts/1983298072/"/>
    <id>http://qinyuanpei.github.io/posts/1983298072/</id>
    <published>2018-01-19T00:42:06.000Z</published>
    <updated>2018-06-04T06:11:50.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>如果提前了解了你所要面对的人生，你是否还有勇气前来？</p></blockquote><p>这是电影《无问西东》里提出的一个问题。作为一部清华大学建校100周年的献礼片，在因为种种原因而被雪藏6年以后，终于以这样一种倔强而孤傲的姿态，进入到人们的视野。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144159822" alt="绘制彩红的张果果" title="">                </div>                <div class="image-caption">绘制彩红的张果果</div>            </figure><p>电影一开始，透过玻璃注视着四胞胎的张果果(张震饰)，第一次向我们发问：如果提前了解了你所要面对的人生，你是否还有勇气前来。而在电影接近尾声的时候，张果果再一次注视着四胞胎，在窗户上为它们勾勒彩虹，此时旁白再次想起，一问一答间，张果果心中已然找到答案。我想知道的是，屏幕前的你，是不是同样找到了答案？</p><p>这是一部讲述传承的电影，它不同于目前电影市场上任何一种主流的类型，它从一开始就注定是一部不讨巧、不友善、不商业的电影。其故事跨度将近一个世纪，或许我们所看到的，不过是历史长河里的星星点点，可依然难掩背后熠熠生辉的文人风骨，这种由时代所赋予的文化气息，让它成为一部瑕不掩瑜的电影，所以即使这部电影在叙事、配乐和剪辑上存在缺陷，这依然是一部值得关注的电影。</p><p>电影尝试用四个平行的板块，讲述四个不同历史阶段的故事，这些故事中的人物彼此关联，组成了一幅波澜壮阔的历史画面，而影片中想要去表达的精神内核，恰好是关联起这些人物的一种特质，我们称之为传承的东西。按照影片线性叙事的结构，我们可以梳理出这样四条线索。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144246715" alt="上进求学的吴岭澜" title="">                </div>                <div class="image-caption">上进求学的吴岭澜</div>            </figure><p>1923年，北平，清华学堂的高材生吴岭澜(陈楚生饰)，面对选择文理科时的迷茫与彷徨，校长梅贻绮告诉他什么是真实，适逢泰戈尔访华到清华园演讲，在听到“不要忘记你们的真心和真性”后，开始思考人生的意义。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144326412" alt="捐躯赴国的沈光耀" title="">                </div>                <div class="image-caption">捐躯赴国的沈光耀</div>            </figure><p>1938年，昆明，世家子弟沈光耀面对山河破碎的现实，在忠与孝的两难抉择中深感困惑，直到听到吴岭澜说“不要放弃对生活的思索，对自己的真实”，毅然选择投笔从戎，成为飞虎队队员，在国家危亡之际战死沙场。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144448584" alt="青春阳光的陈鹏" title="">                </div>                <div class="image-caption">青春阳光的陈鹏</div>            </figure><p>1962年，北京，清华毕业生陈鹏，在面对国家的大爱与恋人的小爱的选择时，饱含着对恋人王敏佳的爱远赴沙漠投身科研，他质问为支边而蒙蔽内心的李想什么是真实，他用爱托着恋人鼓励她努力活下去，为爱而奉献一生。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144541946" alt="寻找本心的张果果" title="">                </div>                <div class="image-caption">寻找本心的张果果</div>            </figure><p>2010年，北京，广告总监张果果，在明争暗斗的职场上遭人排挤，在面对职场中的名利诱惑时，在面对四胞胎永无止境的救助要求时，李想用生命拯救了张果果的父母，完成自我救赎，而张果果则在迷茫中找会初心，让爱传承下去。</p><p>看这样一部电影的时候，像是在经历一件久远的事情。“这个时代缺少的不是完美的人，缺少的是从自己心底里给出的，真心、正义、无畏和同情”，这是电影中飞虎队教练在招收飞行员时所说的话。我想我们喜欢这部电影，恰恰是因为我们缺少这些东西，这些让我们感到温暖而纯粹的东西。借用吴岭澜在影片中的一句话，“此刻我终于不觉得这样的思考是羞耻的，甚而是你们人生必须的”，面对一个我们无力反驳的现实，或许思考有时候会显得更为苍白。彼时，清华大学校长梅贻绮对迷茫中的吴岭澜这样说道，“人把自己置身于忙碌之中，有一种麻木的踏实，但丧失了真实”，那么你知道什么是真实吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144640309" alt="循循善诱的清华校长梅贻琦" title="">                </div>                <div class="image-caption">循循善诱的清华校长梅贻琦</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144747948" alt="聆听泰戈尔演讲的吴岭澜" title="">                </div>                <div class="image-caption">聆听泰戈尔演讲的吴岭澜</div>            </figure><p>电影中第一个人物，是1924年就读于清华大学的吴岭澜，他见证过泰戈尔访问清华，最终从摇摆不定到听从内心声音，找寻人生的意义。吴岭澜当时是清华大学的一名学生，他的理科成绩属于不列，而当时最好的学生都会去读理科，所以他开始面临学业选择上的困惑。校长梅贻绮给他的答案是：“真实是你看到什么，听到什么，做什么和谁在一起，有一种从心灵深处满溢出来的不懊悔也不羞耻的平和与喜悦”。当时诗人泰戈尔访问清华，演讲的主题是”对自己的真诚”，这次演讲促使吴岭澜心态发生最终变化，转学文科，并最终成为西南联大的一名文科教授。电影对吴岭澜的描绘着重放在他和校长梅贻绮的谈话，以及他出现在泰戈尔演讲现场时那双坚定而执著的眼睛。影片中泰戈尔并没有给出完整的正脸，我们可以看到的只有他标志性的长头发和白头发，可见当时泰戈尔的演讲激起了这代青年人内心的热潮。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144839631" alt="历史上的西南联大" title="">                </div>                <div class="image-caption">历史上的西南联大</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144915148" alt="西南联大师生合影" title="">                </div>                <div class="image-caption">西南联大师生合影</div>            </figure><p>历史上的西南联合大学，始于1938年4月。“七七事变”后，京津地区陷入日军炮火，彼时的清华、北大和南开三校一致决定南迁，遂组成西南联合大学。电影中投笔从戎的沈光耀(王力宏饰)就是这段历史时期的一个缩影，西南联大是中国高等教育史上最伟大的传奇，在短短8年间，汇聚并培养了一大批精英，譬如陈寅恪、钱穆、梁思成、朱自清、闻一多、冯友兰……可以说这是近代最为光华璀璨的时期，可谓群贤毕至、风华绝代。短短8年间，西南联大共毕业学生3882名，其中诺贝尔奖获得者2位、国家最高科学技术奖获得者4位、两弹一星功勋奖章获得者8位、两院院士171位及人文大师100多位。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144951566" alt="静坐停雨" title="">                </div>                <div class="image-caption">静坐停雨</div>            </figure><p>电影中这段我最喜欢的场景是“静坐听雨”。历史上西南联大的校舍，是由梁思成夫妇参与设计的。因为战争时期物资非常紧缺，校方无法提供充足的建筑材料，所以梁思成夫妇的设计方案一改再改，从楼房变成了平房，从砖墙变成了泥墙，最终124亩的校园里，只有图书馆和实验室以青瓦覆顶，教室用铁皮，宿舍则用茅草。铁皮屋顶最害怕下雨，而昆明偏偏是多雨气候，因此就有了雨声太大导致学生无法听清老师讲课，老师无奈地在黑板上写下“静坐听雨”四个字，这样苦涩中带着温情的画面。电影中沈光耀推开教室窗户，听到的是雨中体育系学生坚持出操的呐喊，看到的是雨中垂钓者的“一蓑烟雨任平生”的从容。我们今天的大学占地越来越大，楼越盖越高，可再找不回这种令人动容的场景。我本科有位老师喜欢讲《大学》，他说这大学不是“高楼大厦之谓”，而是“大师之谓”，这一刻我很想再听老师讲一次大学之道。</p><p>汪曾琪有篇散文《跑警报》，讲述的正是当时的师生躲避日军飞机轰炸的故事，电影中沈光耀(王力宏饰)在锅炉房相遇煮冰糖银耳的桥段，正是取材于这篇散文。在影片中，吴岭澜(陈楚生饰)是一个对沈光耀产生深远影响的人，吴岭澜此时已成为西南联大文学系教授，他冒着被轰炸的危险把煮冰糖银耳的沈光耀从校舍拉了出来，一句“学生不走老师怎么能走”，足以让其形象瞬间高大起来。电影中吴岭澜躲避轰炸的时候带了只鸽子，而历史真实的故事则是金岳霖抱着一只鸡。当时流传着这样一个段子，“陈寅恪跑警报是为了保护国粹，刘文典跑警报是为了庄子，沈从文跑警报到底是为了什么“。在防空洞里吴岭澜讲述泰戈尔的“真实就是你所见所闻”，将真实传承到沈光耀心里，所以他会冒着受罚的风险向饥民空投物资，所以他会不顾家人反对毅然选择投笔从戎、加入飞虎队，直至弹尽粮绝的最后一刻，他毫不犹豫地选择同日军舰艇同归于尽，这是他们的青春故事。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123145045010" alt="研制原子弹归来的陈鹏" title="">                </div>                <div class="image-caption">研制原子弹归来的陈鹏</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123145058418" alt="用深情撑住恋人的陈鹏" title="">                </div>                <div class="image-caption">用深情撑住恋人的陈鹏</div>            </figure><p>陈鹏(黄晓明饰)在影片中是清华大学的一名学生，在毕业后参与原子弹的研制工作。他对恋人王敏佳矢志不渝的爱，成为了支撑她熬过人生低谷的强大动力。影片中的王敏佳一心想帮助曾经的老师摆脱“家庭暴力”，结果反倒被师母诬陷她勾引自己老师，而她的虚荣心迫使她被组织审查直至接受批斗。在批斗中王敏佳失去了美丽的面庞，她的好朋友李想为争取支援边区的名额，不敢承认自己的错误并坚决同她划清了界限。只有陈鹏自始至终守护在王敏佳身边。可陈鹏依然在国家和个人的抉择中，选择了远赴沙漠参与原子弹的研制工作，对他而言，照顾王敏佳和研制原子弹，就是他生命的全部。可当陈鹏回到曾经熟悉的地方时，却发现恋人因为“破四旧”运动而不见踪影。在爱人与国家面前，在爱情与理想面前，我们到底应该怎么去选择，我想大概就是电影中陈鹏告诉李想那句话，“死者已矣，生者如斯”，这是“晃晃”哥哥和神父教给他的大爱。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123145713649" alt="眼神里都是戏的领导" title="">                </div>                <div class="image-caption">眼神里都是戏的领导</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123145759140" alt="现代人的感情，就剩这么点了" title="">                </div>                <div class="image-caption">现代人的感情，就剩这么点了</div>            </figure><p>生活在现代都市的张果果(张震饰)，在尔虞我诈的人际关系中艰难前行，他恪守上下级的职场伦理却被有预谋地当作了替罪羊。面对女下属的质疑，不得不以高深莫测的“你猜”来掩饰内心的焦虑。对父母缺乏耐心以至于出去吃饭的时候直接将碗筷丢进垃圾框，他习惯性地防备着身边的一切，一如喜欢给自己覆盖一层冰冷盔甲的你我。他怕四胞胎家人纠缠而从医院匆匆离开，却又主动掏出名片在门口等人家追上来；目睹四胞胎家人住在没有暖气的出租屋里，冷峻着脸转身离开却又悄声让助理帮忙找个好点的两居室；他买来各种奶粉默默研究选出最满意的奶粉并长期供给，却又不愿意让四胞胎家人对他抱太高期望……起初会觉得这个角色和整个故事无关，可当张果果的父母交代出李想在边区为救自己而牺牲的故事，这一刻我们终于明白，这种传承从未改变，经历过迷茫和无助的张果果终于找回初心，自信地对这个世界说：“我和他们不一样”。</p><p>我相信每个时代里的青年都曾这样迷茫过，就像我们今天所要面对的这种困局一样。媒体称我们这一代人是得过且过的佛系青年，我们为工作中无法得到别人认可而焦虑过，我们为空有适婚的年龄而无适婚的感情而烦闷过，我们为透支父母毕生积蓄来买房而羞愧过……可你看每一个在时代洪流中挣扎的人，其生命无一不被同时打上时代和民族的烙印。吴岭澜是因真心而重新选择自己的人生，沈光耀是因为正义而投笔从戎，陈鹏是因为无畏而托住恋人投身科研，张果果是因为同情而重拾本心迷途知返。列夫·托尔斯泰说过，幸福的人生都是相似的，不幸的人生各有各的不同。每个时代有每个时代的不幸，我们今天不单单要面对水涨船高的房价，更要面对逐渐枯竭甚至贫瘠的心灵。有人说，这部拍给清华学生看的电影，对改善我们的生活毫无意义，可这世上有多少东西，说出来以后能不变得庸俗呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123145847393" alt="那时的爱情真美好" title="">                </div>                <div class="image-caption">那时的爱情真美好</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123150016826" alt="这个校服好帅诶" title="">                </div>                <div class="image-caption">这个校服好帅诶</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123150042048" alt="不管多远都要去寻找你" title="">                </div>                <div class="image-caption">不管多远都要去寻找你</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123150121157" alt="最后的国学大师，王国维" title="">                </div>                <div class="image-caption">最后的国学大师，王国维</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123150159518" alt="那时的青春真美好" title="">                </div>                <div class="image-caption">那时的青春真美好</div>            </figure><p>同样是在迷茫的20多岁，有人找到了真性在生命里惊鸿一瞥，有人在沉浮中随波逐流迷失本心，前者是沈光耀目睹战友牺牲与敌舰同归于尽，后者是李想为争取支边名额背弃朋友间的友谊。陈鹏的爱慷慨而深沉，王敏佳不幸而无能为力……每个时代都是写意的，有佚群绝类的意气，有献血淋漓的痛苦，今天的人们注定无法理解曾经艰苦的生活，而曾经的人们同样无法理解现代人所面对的压力。现实中的离婚和出轨，让美好的爱情变得遥不可及。我们今天越是期待什么，我们的心里就越是缺乏什么。白居易说《长恨歌》是虚构的，而感情是真实的，这或许完全是我们的内心在作怪。世道艰辛，梦想与现实，家国与大义，爱情与理想，名利与善良，仿佛冥冥之中被逼迫到进退两难境地的每一个人，众生皆苦，各自悲欢。张果果在酒吧里拎着半瓶红酒自嘲道，“现代人的情感，就这么多了”，当本心迷失，便是我们有火车，有高铁，有飞机，都不知道要去哪里了！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123150238166" alt="路一直都在远方" title="">                </div>                <div class="image-caption">路一直都在远方</div>            </figure><p>古人说“为天地立心，为生民立命，为往圣继绝学，为万世开太平”，这是传统知识分子对文化传承的一种使命感。在这部电影中，防空洞里师生背诵《楚辞》、讲述泰戈尔，这是我理解的文化上的传道；王国维在一片英语声中转身离去，那个萧疏没落的背景像是很久很久以前的事情；沈光耀的母亲不愿意他为功名荣辱，在不知人生为何物的时候匆匆离开；师母看到被人打得半死的王敏佳，内心残存的善念觉醒愧而坠井……这些游曳在光影里的残余画面，显得温暖而残酷，终于化作电影结束时一个又一个陌生而熟悉的名字。我们之所以怀念青春，是因为青春本该就是这个样子，真实勇敢，无惧无悔。世俗这样强大，强大到生不出改变它们的念头来。可是无论外界的社会如何跌宕起伏，都对自己真诚，坚守原则。内心没有了杂念和疑问，才能勇往直前。愿你在被打击时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="无问西东" scheme="http://qinyuanpei.github.io/tags/%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C/"/>
    
  </entry>
  
</feed>
