<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞鸿踏雪的部落格</title>
  
  <subtitle>人生到处知何似，应似飞鸿踏雪泥</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qinyuanpei.github.io/"/>
  <updated>2017-12-24T08:21:25.709Z</updated>
  <id>http://qinyuanpei.github.io/</id>
  
  <author>
    <name>Payne</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于新浪微博的男女性择偶观数据分析</title>
    <link href="http://qinyuanpei.github.io/2017/12/23/a-data-analyse-about-the-view-of-choosing-spouse-based-on-weibo.html"/>
    <id>http://qinyuanpei.github.io/2017/12/23/a-data-analyse-about-the-view-of-choosing-spouse-based-on-weibo.html</id>
    <published>2017-12-23T20:28:40.000Z</published>
    <updated>2017-12-24T08:21:25.709Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;或许是因为我喜欢的姑娘从来都不喜欢我，而感情上的挫折一度让我陷入无尽的自卑。朋友在朋友圈里发布一条关于皮影戏的动态，我开玩笑说这个皮影戏结局应该是个悲剧，因为我注意到在剧中，无论一个人如何卖力地表演甚至双腿跪倒在地，有的人从故事开场到结束一直对此无动于衷。朋友回复我说，这不就是你现在的状态吗？我沉默半天终于熄灭手机屏幕。我听到过各种各样让我放弃她的话，即使这种念头在我脑海里萌生已久，是幻想让我硬生生地拖了这么久。当你努力想要融入对方的生活，而等待你的是一道冰冷的墙。这种感觉像什么呢？大概就是一个又一个“好友”安安静静地躺在联系人的置顶名单里，不敢发消息让对方知道，更不愿残忍地把对方删除。我安慰自己说，对我而言，我失去的是一个不喜欢你的人；而对对方而言，失去的是一个喜欢她的人。你当然可以说我没有那么喜欢她，如果一定要喜欢到卑微如尘土的地步，我宁愿一个人单身到天荒地老。</p><p>&emsp;&emsp;当我意识到人与人间，即使亲近如父母尚且无法完全理解彼此的时候，我忽然发现一个有趣的现象，我们喜欢一个人的时候，首先注意到的会是外表，我们将其称之为眼缘，所以人与人间的感情纽带最初会是吸引，而后是了解彼此的优缺点，最终是相互理解和扶持。可我们知道，外表是可以伪装出来的，所以我们习惯通过外表和言语来评价一个人，这就像是数学归纳法，我们总认为推倒第一块多诺米骨牌，就意味着所有多诺米骨牌都会倒下。可现实世界矛盾的地方就在于，我们认为理所当然正确的事情，或许正是我们无法证明其正确性的，这在数学上称为哥德尔不完备定理。所以，一件残酷的事情是，当你无法吸引一个人的时候，通往内心世界的路就被堵死了。朋友圈里精彩纷呈的社交互动，并不代表有人愿意真正了解你的生活，何况是你吸引不到的人呢？我很想知道，我们在选择伴侣的时候到底看中什么，所以我一直在关注<a href="https://weibo.com/u/5566882921" target="_blank" rel="noopener">@西安月老牵线</a>上发布的征婚交友类微博，本文的故事从这里正式展开。</p><h1 id="身高175的悲伤"><a href="#身高175的悲伤" class="headerlink" title="身高175的悲伤"></a>身高175的悲伤</h1><p>&emsp;&emsp;或许你以为我会无聊到试图从微博上找到女朋友，可事实上作为一个程序员的我，即使整天投入精力在编程上，依然无法避免对象空引用的异常出现。如果说找到女朋友是个小概率事件，那么在我看来，找到一个真正懂我、喜欢我的女朋友，基本上是不可能事件。你不要觉得我对没有调整好心态、对生活过分悲观，如果你了解贝叶斯公式就会真正地理解我说的话。这个微博开始引起我的注意，是我发现身高在155到165左右的女生，对男生的要求基本上无疑例外地是175+到180+，我想知道到底有多少女生是有这样的想法，这是我想要抓取新浪微博的数据进行分析的初衷。更重要的是，身高不到175的我在面对这种要求的时候是悲伤的，因为我想起了《巴黎圣母院》中的卡西莫多，一个外表丑陋而拥有高尚人格的“丑八怪”。现代人整天都特别忙碌，以至于没有人会有耐心，园艺在忍受着你丑陋的外表的同时，同你讲一只小兔子亲了它喜欢的长颈鹿一下这种故事。</p><p>&emsp;&emsp;我听到这样一句话，“好看的皮囊千篇一律，有趣的灵魂万里挑一”，可谁会觉得像卡西莫夫这样的人，会拥有或者配拥有高尚的人格呢？我们这副皮囊不管好看与否，它们都是父母给予我们的最好的礼物。难道一个所谓情商高的人，会在收到别人的时候因为礼物不好看而生气吗？ 我想起《画心》里懊悔受狐妖小唯皮相蛊惑而自毁双目的霍心，美丑都是父母赐予我们的，不该被我们拿来一番大肆炫耀，可我还是想知道，我们评价一个人的标准到底是什么？因为我渐渐明白，有些人不喜欢我们，并不是我们不好，而仅仅是某一点和对方不匹配。喜欢一个人的时候，像拔下身上的一根根刺，因为你越是得不到回应，就越像变成对方期待的样子，这个过程会让你觉得自己一无是处。直到今天看到一句话，一句足以热泪盈眶的话，如果不曾喜欢你，我本来非常可爱的。有时候，人做一件事情，或许就是在和自己过不去，比如说这件事情。</p><h1 id="花点时间爬爬微博"><a href="#花点时间爬爬微博" class="headerlink" title="花点时间爬爬微博"></a>花点时间爬爬微博</h1><p>&emsp;&emsp;好了，现在我们来考虑从新浪微博上抓取<a href="https://weibo.com/u/5566882921" target="_blank" rel="noopener">@西安月老牵线</a>上发布的微博，因为这是我们进行数据分析的前提。事实上，在写这篇文章前我曾花了大量时间来调试爬虫，然后用了一天的时间对数据进行清洗，最终利用晚上下班的时间生成词云。由此我们可以理出整体的思路：</p><p><img src="http://img.blog.csdn.net/20171223234945060" alt="流程图"></p><p>&emsp;&emsp;通过流程图我们可以注意到，在这里我选择了Python来实现整个功能。转眼间我已经25岁了，这是种什么样的概念呢？两年前我23岁的时候，听别人讨论结婚这个问题，我觉得它离我还很遥远。如今看着周围人都结婚了，我竟有种“高处不胜寒”的感觉。所以呢，人生苦短，当你不能阻止时间一天天消逝的时候，你只能趁着现在去做你想做的事情，为了节省时间去做技术以外的尝试，我选择拥有全世界最丰富的库的Python。</p><p>&emsp;&emsp;这段时间学习数据分析，我渐渐意识到我们所熟悉的这个世界，如果以一种理性的角度，完全通过数据来解构的话，我们在这个数字时代里留下的每一条讯息，都冷冰冰地暴露着我们的喜怒哀乐，每一张照片里细微的表情变化，每一段文字里隐匿着的真实意图，都能被人脸识别和自然语言处理等等，这类人工智能为代表的技术所解读，我们努力想在朋友圈里隐藏些什么，当朋友圈的访问范围从半年逐渐缩小到三天，我们究竟能隐藏下什么呢？</p><h2 id="微博爬虫分析"><a href="#微博爬虫分析" class="headerlink" title="微博爬虫分析"></a>微博爬虫分析</h2><p>&emsp;&emsp;首先，我们需要从微博上抓取数据下来，我没有去做抓包分析这样的重复性工作，因为我注意到这个问题，在网络上有很多朋友在讨论，我主要参考了以下内容：</p><ul><li><a href="https://www.zhihu.com/question/29666539/answer/63325949" target="_blank" rel="noopener">Python 爬虫如何机器登录新浪微博并抓取内容？</a></li><li><a href="https://github.com/xchaoinfo/fuck-login" target="_blank" rel="noopener">https://github.com/xchaoinfo/fuck-login</a></li><li><a href="http://python.jobbole.com/84349/" target="_blank" rel="noopener">用Python写一个简单的微博爬虫</a></li></ul><p>通过以上内容，我了解到在抓取新浪微博数据的问题上，我们基本会有以下思路：</p><ul><li>保存cookie信息，利用requests库发起请求并带上cookie</li><li>利用requests库模拟登录新浪微博并在请求过程中保持cookie</li><li>利用selenium库模拟登录新浪微博然后取得页面内容</li><li>利用PhantomJS库模拟登录新浪微博然后取得页面内容</li></ul><p>可以看出差异主要集中在cookie的获取以及是否支持headless模式，并且我们得到一个共识，抓取新浪微博<a href="http://weibo.cn/" target="_blank" rel="noopener">移动版</a>要比<a href="https://weibo.com" target="_blank" rel="noopener">PC版</a>要容易，因为移动版优先为小尺寸屏幕设备提供服务，因而页面结构相对整洁便于我们提取数据。起初博主认为第一种方式太简单粗暴，坚持要采用第二种方式去实现，最终证明还是太年轻了啊，新浪微博的登录给人的感觉就是蛋疼，这里就简单介绍下思路哈。</p><p>&emsp;&emsp;首先我们会向服务器发出一次GET请求，它返回的结果是一段JavaScript代码，然后我们需要用正则匹配出其中的JSON字符，这样我们就获得了第二次请求需要用到的参数；接下来，第二次请求是一个POST请求，我们需要将用户名采用Base64加密，密码则采用RSA加密，需要用到第一次请求返回的参数。实际上，新浪微博官方给我们提供API获取微博数据，可这个API可以获取的微博数据非常有限，更让人难以接受的是新浪微博的应用授权方式，如果我们采用调用API的方式，在这里会有第三次POST请求，有朋友分析了完整的模拟登录过程，可我对此表示毫无兴趣啊。最早我采用了模拟这种方式，抓取第一页的时候还是登录的状态，可等到抓取第二页的时候变成了注销的状态，整个过程使用的是同一个session对象，所以我最后果断放弃了这种方式。</p><p>&emsp;&emsp;好了，现在我们只需要在Chrome里F12找到Network选项卡，抓一次包取得cookie，然后在请求的时候带上cookie即可。我们不用过分担心cookie过期的问题，在博主测试的时候，一个cookie可以持续工作3至5天，而且在后面我们会讲到，这个爬虫抓取的数据量其实并不大，在一两个小时内就可以完成抓取，没有必要将爬虫考虑得太严谨。在下图中我们标记出了博主计算机上存储的cookie，我们通过cookie就可以免登录抓取信息啦。</p><p><img src="http://img.blog.csdn.net/20171224011921074" alt="提取Cookie"></p><p>&emsp;&emsp;解决登录的问题以后，回到这个问题本身，我们需要抓取<a href="https://weibo.com/u/5566882921" target="_blank" rel="noopener">@西安月老牵线</a>发布的所有微博，移动版对微博做了分页处理，所以我们只需要知道总共有多少页，然后循环去提取每一页里的信息即可，因为我们注意到每一页的地址都符合<a href="https://weibo.cn/u/3232168977?page=2" target="_blank" rel="noopener">https://weibo.cn/u/3232168977?page=2</a>这样的形式。首先页数，我们可以通过name为mp的隐藏控件来获得，其value属性表示总页数。其次，每条微博存放在class为c，id以M_开头的div标签里，在这里我们只需要文本信息，顺藤摸瓜我们发现信息被存放在class为ctt的span标签里，这里博主遇到一个奇怪的问题，BeautifulSoup默认的解析器html.parser，不知道因为原因无法解析出标签，而lxml当时因为pip的问题无法安装，所以不能使用XPath来解析DOM解构，在这里我认为XPath更适合这个场景，如果有时间可以考虑对代码进行重构。</p><p>&emsp;&emsp;在抓取微博的过程中，博主发现官方的反爬虫策略非常给力，连续工作超过5分钟IP就会被封锁，进而无法访问微博的服务器， 大概经过20至30分钟后会自动解封。或许主流的方案是花钱买动态代理，可我这个就是临时起意的一个想法，所以我采取了最简单粗暴的方法，让线程睡一会儿，在这样条件下，我花了大概1个半小时到2个小时左右的时间，从微博上抓取了5600条数据，并将其存储在了SQLite数据库中。什么？你问我为什么不考虑多线程，因为我这个人懒啊，这个问题最难的地方在数据分析，数据抓取方面我不太关注效率，因为我有足够的时间去等这些数据，所以关于性能方面的问题，有时间我们再做进一步讨论吧！</p><h2 id="数据处理过程"><a href="#数据处理过程" class="headerlink" title="数据处理过程"></a>数据处理过程</h2><p>&emsp;&emsp;数据处理这块，我本来打算尝试下MongoDB这个数据库的，而实际上这是我今年计划要去学习的内容之一，后来因为种种原因一直搁置到现在，可当我注意到Windows下安装MongoDB的繁琐后，我果断放弃了这种念头回归简单的SQLite，我基本上是交叉使用Windows和Linux，而我知道Linux下安装MongoDB是非常简单的。我反复强调我喜欢小而美的东西，就是因为我想保留对方案的选择权。在这里我们的数据处理，主要是数据清洗和中文分词。首先，我们来一起看看数据库表的设计：</p><p><img src="http://img.blog.csdn.net/20171224120313193" alt="数据表结构"></p><p>&emsp;&emsp;我这里一切从简，所以将这5600多条数据都存储在一张表里，表中有四个字段ID、Post、Wish和Tags。显然，ID是自增的主键，为每条微博提供一个唯一的标识；Post存储我们从微博上抓取的原始信息，这里不含HTML标签，可是会含有微博表情字符啊摔；Wish存储每条微博中对伴侣的要求具体有哪些，这里我们主要通过关键字来截取可谓简单粗暴，具体原因稍后会讲到:)；Tags存储Wish字段经过分词以后的结果，这里我们使用结巴分词和SnowNLP，该字段中存储的是序列化后的JSON字符串，下面我们具体来讲这些字段的处理。</p><p>&emsp;&emsp;首先，分析<a href="https://weibo.com/u/5566882921" target="_blank" rel="noopener">@西安月老牵线</a>发布的微博我们可以发现，所有征婚相关的微博都是以<strong>#征婚交友#</strong>或者<strong>#月老爱牵线#</strong>这样的话题开始，并且每条微博都是先介绍个人情况，然后再描述对理想伴侣的期望，所以我们只需要找出每条微博里对理想伴侣的期望相关的描述，然后再根据这条微博是由<strong>男嘉宾</strong>还是<strong>女嘉宾</strong>发布的，即可汇总出男、女性对各自伴侣的期望到底是什么，我们将这部分信息更新在Wish字段里，我们一起来看具体的代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Filter Data</span><br><span class="line">sql = <span class="string">"SELECT ID, Post FROM table_weibo WHERE POST LIKE '%%%%%s%%%%' OR POST LIKE '%%%%%s%%%%'"</span></span><br><span class="line">sql = sql % (<span class="keyword">u</span><span class="string">'#征婚交友#'</span>,U<span class="string">'#月老爱牵线#'</span>)</span><br><span class="line">self.<span class="built_in">cursor</span>.<span class="keyword">execute</span>(sql)</span><br><span class="line">rows = self.<span class="built_in">cursor</span>.fetchall()</span><br><span class="line"></span><br><span class="line"># Adjust Data</span><br><span class="line">patterns = [<span class="string">'想找'</span>,<span class="string">'希望找'</span>,<span class="string">'要求'</span>,<span class="string">'希望另一半'</span>,<span class="string">'择偶标准'</span>,<span class="string">'希望对方'</span>,</span><br><span class="line"><span class="string">'希望'</span>,<span class="string">'找一位'</span>,<span class="string">'找一个'</span>,<span class="string">'一半'</span>,<span class="string">'找'</span>,<span class="string">'想'</span>,<span class="string">'喜欢'</span>,<span class="string">'择偶条件'</span>,<span class="string">'寻'</span>,<span class="string">'期待'</span>,</span><br><span class="line"><span class="string">'女孩'</span>,<span class="string">'男孩'</span>,<span class="string">'女生'</span>,<span class="string">'男生'</span>,<span class="string">'女士'</span>,<span class="string">'男士'</span>,<span class="string">'理想型'</span>]</span><br><span class="line">sql = <span class="string">"UPDATE table_weibo SET Wish = ? WHERE ID = ?"</span></span><br><span class="line"><span class="keyword">for</span> row in row<span class="variable">s:</span></span><br><span class="line">    id = row[<span class="number">0</span>]</span><br><span class="line">    post = row[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">match</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> pattern in pattern<span class="variable">s:</span></span><br><span class="line">        <span class="keyword">if</span>(pattern in post):</span><br><span class="line">            <span class="keyword">match</span> = post.<span class="keyword">find</span>(pattern) + <span class="built_in">len</span>(pattern)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">match</span> != -<span class="number">1</span>):</span><br><span class="line">            wish = str(post[<span class="keyword">match</span>:])</span><br><span class="line">            wish = wish.replace(<span class="string">'#西安月老牵线#'</span>,<span class="string">''</span>)</span><br><span class="line">            wish = wish.replace(<span class="string">'[心]@月老蜀黍'</span> ,<span class="string">''</span>)</span><br><span class="line">            wish = wish.replace(<span class="string">'#月老爱牵线#'</span>  ,<span class="string">''</span>)</span><br><span class="line">            self.<span class="built_in">cursor</span>.<span class="keyword">execute</span>(sql,(wish,id))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.<span class="built_in">cursor</span>.<span class="keyword">execute</span>(sql,(<span class="string">''</span>,id))</span><br><span class="line">self.connect.commit()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以注意到，我们首先按照话题对微博进行了筛选，然后通过关键字列表patterns来截取我们所需要的Wish字段，实际上这里是需要反复去调整patterns的，直到所有满足我们期望的数据都被提取出来，所以这是一个渐进式的数据处理过程。或许我们能想到通过NLP相关的技术来分析这段文本，我尝试通过SnowNLP去分析这样一段长度为100到500的文本，因为SnowNLP具备分析一段话的摘要及关键字的能力。可我发现这样实践下来效果并不太好，这是因为SnowNLP本身是以电商网站的评论数据为基础的，所以遇到我们微博这样相对灵活的文本信息时，它提取出的关键字并不能完全地符合我们的期望。固然，我们可以通过训练SnowNLP来达到我们的目的，可训练需要准备大量的文本信息作为支撑。作为一个懒惰的人，我最终选择了通过关键字来提取关键信息，准确度基本可以保证90%以上，因为暴力截取难免会拆分出不符合期望的信息。</p><p>&emsp;&emsp;接下来，我们有了针对男、女择偶要求期望的Wish字段，可这些信息对我们而言，依然显得繁重而冗余，所以接下来我们考虑对Wish字段进行分词，最初的设想是通过词性和语法来分析，可当我分完词以后我就不得不佩服中文的博大精深，这里我选择了两个中文处理相关的库，即<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">结巴分词</a>和<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">SnowNLP</a>，它们都是开源项目并且有大量的文档作为参考，这里想说的是，SnowNLP中支持中文文本的情感分析，这是我最初想要使用这个库的一个重要原因，因为我想从这些微博中找出评价一个人的形容词或者名词，而这些词的情感分析，可以作为我们是否将其作为一个评价指标的重要依据。</p><p>&emsp;&emsp;可我们有句话叫做“认真你就输了”，尤其在女性的思维模式中，充满太多太多不能直接去理解的信息。这种我不用举例子啦，现在铺天盖地的直男癌/女权癌席卷而来，其实有太多问题无关对错，你输就输在没有照顾好对方的情绪，我们现在常常把情商挂在嘴上，可情商概念中的<strong>自我意识</strong>、<strong>控制情绪</strong>、<strong>自我激励</strong>、<strong>认知他人情绪</strong>和<strong>处理相互关系</strong>，有60%说的是自我管理，而其余的40%，恰恰就是我们日常理解中关于人际关系方面的，所以我们说人工智能不能完全代替人类，因为只有绝对理性的世界是恐怖的，可只有情绪化的感情而不讲道理的世界则是空虚的。我们可以去追逐人类内心中的灵性，即真、善、美，这是任何冰冷的计算机所不具备的东西。可我们能不能真诚一点呢，明明知道这一切都是套路可你还满心期待，我们并非不懂得什么是爱，爱不是我用一个又一个套路去套路你，而是我明知这是套路还愿意陪你表演下去，我没有在讽刺浙江卫视某节目，愿温柔的你被这个世界温柔地对待。</p><p>&emsp;&emsp;关于结巴分词和SnowNLP地对比评测，大家可以参考：<a href="http://blog.csdn.net/sinat_26917383/article/details/77067515" target="_blank" rel="noopener">Python︱六款中文分词模块尝试</a>，这里博主发现SnowNLP适合做大颗粒分词拆分，而结巴分词适合做小颗粒分词拆分。其实，从分词效果上来讲，结巴分词是要比SnowNLP效果更好一些的，可我这样说不是会显得情商比较高吗？这样你们会喜欢吗？最终我们采取的方案是两者混用，故而我们有了这样的代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTags</span><span class="params">(<span class="keyword">self</span>,text)</span></span><span class="symbol">:</span></span><br><span class="line">    snow = SnowNLP(text)</span><br><span class="line">    sentences = snow.tags</span><br><span class="line">    tags = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="symbol">sentences:</span></span><br><span class="line">        words = pseg.cut(s[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="symbol">words:</span></span><br><span class="line">            tags.append(&#123;<span class="string">'word'</span><span class="symbol">:w</span>.word,<span class="string">'flag'</span><span class="symbol">:w</span>.flag&#125;)</span><br><span class="line">    <span class="keyword">return</span> json.dumps(tags)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以注意到，这里我们使用结巴分词获得了每个词的词性，不过到我写这篇文章的时候，对于词性的处理我依然没有什么好的想法，这里仅将其作为结果以JSON的形式存储到数据库中，现在我们基本上完成了所有数据处理的流程，在这个过程中会有些特殊的中文字符，我们采取暴力替换的方式进行去除即可，对此不在这里展开说啦。下图展示了数据库中部分数据：</p><p><img src="http://img.blog.csdn.net/20171224141144095" alt="处理后的数据"></p><h2 id="处理结果呈现"><a href="#处理结果呈现" class="headerlink" title="处理结果呈现"></a>处理结果呈现</h2><p>&emsp;&emsp;说起这篇文章，可以说这是我第一次接触数据分析，我们这个时代积累了大量的数据，所以我们有基于大数据的推荐和预测等等相关场景，知乎和微博的首页Feed流经过无数次算法调整，可人们依然在抱怨算法向人们推荐了无关的内容，这是否说明，我们所期待的智能，仅仅是让我们觉得智能而已，这一系列基于统计的数据分析理论，是否一定是符合某种冥冥之中的规则，我想起《模仿游戏》中和卷福扮演的图灵形成鲜明对比的，正是以休.压力山大为代表的统计方法派，电影中他们试图通过分析字母出现的频率来破解恩尼格玛。对于数据分析而言，如果说可视化是面向人类的分析手段，那么数据挖掘就是面向机器的分析手段。作为一个刚刚入门的萌新，我描述的是我对数据分析的一种感觉。回到本文主题，这里我选择以词云作为最终处理结果的呈现载体。</p><p>&emsp;&emsp;词云，即WordCloud，是一种展现关键字出现频率的表达方式，如果你对博客写作比较熟悉的话，就会知道诸如WordPress、Ghost、Hexo等都提供了标签云功能，我们每篇文章中都会给文章添加若干标签，而标签基本可以让读者了解这个博客都有哪些内容，在标签云中出现频率越高的标签其字体通常会越大，这样我们可以非常直观地了解到，每个因素在整体上占到的比重。本文之所以采用这种方案，正是希望通过词云来呈现男女在择偶观上更看重什么。生成词云的方式有很多，具体可以参考这篇文章：<a href="https://www.zhihu.com/question/28382979/answer/117544077" target="_blank" rel="noopener">除了 Tagxedo外，还有什么好的软件制作可以词云?</a>，而博主最终选择了<a href="https://github.com/amueller/word_cloud" target="_blank" rel="noopener">wordcloud</a>，你可以看到Python基本上是万能的语言，有这么多优秀的第三方库可以用，我就问你怕不怕，关于这个库的用法，请参考：<a href="https://amueller.github.io/word_cloud/" target="_blank" rel="noopener">https://amueller.github.io/word_cloud/</a>，如果通过pip无法直接安装该库，可以通过<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud" target="_blank" rel="noopener">这里</a>下载.whl文件进行安装，注意升级pip到最新版本即可。</p><p>&emsp;&emsp;参照官方的示例，我们从数据库中根据Post来过滤性别，根据Tags来获取关键字，然后将所有Tags串联成一个字符串，传递给WordCloud模块即可。下面给出代码片段：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filter Data</span></span><br><span class="line">sql = <span class="string">"SELECT Post, Tags FROM table_weibo WHERE Tags &lt;&gt; ''"</span></span><br><span class="line">self.cursor.execute(sql)</span><br><span class="line">rows = self.cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Filter Tags</span></span><br><span class="line">male_tags = <span class="string">''</span></span><br><span class="line">female_tags = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    post = row[<span class="number">0</span>]</span><br><span class="line">    tags = json.loads(row[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="string">u'男嘉宾[向右]'</span> <span class="keyword">in</span> post:</span><br><span class="line">        female_tags += <span class="string">','</span>.join(map(<span class="keyword">lambda</span> x:x[<span class="string">'word'</span>],tags))</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">u'女嘉宾[向右]'</span> <span class="keyword">in</span> row[<span class="number">0</span>]:</span><br><span class="line">        male_tags += <span class="string">','</span>.join(map(<span class="keyword">lambda</span> x:x[<span class="string">'word'</span>],tags))</span><br><span class="line">                </span><br><span class="line"><span class="comment"># WordCloud self.generateWordCloud(female_tags,'female.png','output_female.png') self.generateWordCloud(male_tags,'male.png','output_male.png')</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在这里我们主要将男嘉宾/女嘉宾分别筛选出来，然后将分词结果用逗号串联起来，这样即可得到male_tags和female_tags，我们会将其传递给WordCloud模块，可以注意到我们为男性/女性词云分别设置了不同的背景图片，最终会生成两张不同的图片，这里主要参考了<a href="https://amueller.github.io/word_cloud/auto_examples/colored.html" target="_blank" rel="noopener">Image-colored</a>这个示例，代码片段展示如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateWordCloud</span><span class="params">(self,text,background,output)</span>:</span></span><br><span class="line">    back_coloring = np.array(Image.open(background))</span><br><span class="line">    stopwords = set(STOPWORDS)</span><br><span class="line">    stopwords.add(<span class="string">u'西安'</span>)</span><br><span class="line">    stopwords.add(<span class="string">u'生活'</span>)</span><br><span class="line">    wordcloud = WordCloud(</span><br><span class="line">        font_path=<span class="string">'simfang.ttf'</span>,  <span class="comment"># 设置字体</span></span><br><span class="line">        background_color=<span class="string">"white"</span>,  <span class="comment"># 背景颜色</span></span><br><span class="line">        max_words=<span class="number">5000</span>,  <span class="comment"># 词云显示的最大词数</span></span><br><span class="line">        mask=back_coloring,  <span class="comment"># 设置背景图片</span></span><br><span class="line">        stopwords=stopwords, <span class="comment">#停用词设置</span></span><br><span class="line">        max_font_size=<span class="number">75</span>,  <span class="comment"># 字体最大值</span></span><br><span class="line">        random_state=<span class="number">42</span>,</span><br><span class="line">        width=<span class="number">1000</span>, height=<span class="number">860</span>, margin=<span class="number">15</span>,<span class="comment"># 设置图片默认的大小,但是如果使用背景图片的话,那么保存的图片大小将会按照其大小保存,margin为词语边缘距离</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    wordcloud.generate(text)</span><br><span class="line">    plt.imshow(wordcloud)</span><br><span class="line">    plt.axis(<span class="string">"off"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    wordcloud.to_file(output)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里我们注意到添加了两个停止词，这是因为我们发现，<strong>西安</strong>和<strong>生活</strong>这两个关键词，在整体中所占权重虽然较高，可是因为我们这里抓取的是西安本地的微博，所以这两个关键词对我们而言是没有意义的。再对这两个关键字进行剔除以后，我们最终生成的词云如图：</p><p><img src="http://img.blog.csdn.net/20171224153059421" alt="男性心目中的伴侣"></p><p><img src="http://img.blog.csdn.net/20171224153232864" alt="女性心目中的伴侣"></p><h1 id="这是个看脸的世界"><a href="#这是个看脸的世界" class="headerlink" title="这是个看脸的世界"></a>这是个看脸的世界</h1><p>&emsp;&emsp;对这样一个显然成立的结论，我是表示失望的，这种感觉像什么呢？就像你期待着对方说喜欢你，结果到最后她还是会说我们不合适。可花费如此大的篇幅来讲这样一个悲伤的故事，我们就象征性地分析下结论吧！首先，我们注意到男性心目中的伴侣，排名靠前关键字是<strong>性格</strong>、<strong>孝顺</strong>、<strong>善良</strong>、<strong>懂事</strong>、<strong>结婚</strong>、<strong>身高</strong>、<strong>眼缘</strong>，而女性心目中的伴侣，排名靠前的关键字是<strong>身高</strong>、<strong>稳重</strong>、<strong>责任心</strong>、<strong>上进心</strong>、<strong>工作</strong>、<strong>成熟</strong>。所以，我现在完全可以理解，为什么女生会对180的身高如此迷恋，因为她们想被男朋友举高高呀，我的一位朋友如是说。</p><p>&emsp;&emsp;与此同时，我们发现很多指标譬如<strong>孝顺</strong>、<strong>善良</strong>、<strong>稳重</strong>、<strong>责任心</strong>、<strong>上进心</strong>等，其实都是需要两个人在相处久了以后慢慢去验证的，可这些最终会被<strong>眼缘</strong>和<strong>身高</strong>这种因素阻挡在外面。或许你会觉得这样浅显的道理，居然值得我花费时间和精力去思考。一个你吸引不到的人，终究是难以拉近两个人心间的距离的。喜欢是两个人的事情，我不是要卑微地乞求你来见我，而是你想要来见我我就主动迎上去。有天在QQ空间看到有人在看《怦然心动》，就忍不住下载下来一个人看。有时候我们喜欢的那个人，或许并没有那么好，你会渐渐发现，那种因为喜欢而附加在对方身上的光环，会随着时光而慢慢变淡。而有那么一瞬间，我只想比她变得更优秀，而不再幻想她会转身回来看我，或许这就是成长吧！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;大概没有谁会像我这样，在写一篇技术文章的过程中，掺杂如此多的个人情感。可有时候，一个人做一件事情的动机，的确就是如此简单。我羡慕175以上的身高，可是不是我具备了这样的身高，你就会喜欢我呢？我想应该不会吧，因为你总能找到新的理由来拒绝我。所以，我写这篇文章，通过Python抓取新浪微博数据并对其进行分析，并不是想告诉你，你因为不具备哪些因素而不被人喜欢，而是想告诉你，我们每一个人都是这个世界上独一无二的存在，我们的优点同我们的缺点组合起来，这才是完整的我们。别人喜欢不喜欢我们到底有什么意义呢？就像我们喜欢许嵩、喜欢林依晨，难道就要让人家喜欢我们吗？我可以非常喜欢你，但我一定要骄傲地喜欢你，因为我骄傲时的样子最帅，谁让这是一个看脸的世界呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;或许是因为我喜欢的姑娘从来都不喜欢我，而感情上的挫折一度让我陷入无尽的自卑。朋友在朋友圈里发布一条关于皮影戏的动态，我开玩笑说这个皮影戏结局应该是个悲剧，因为我注意到在剧中，无论一个人如何卖力地表演甚至双腿跪倒在地，有的人从故事开场到结束一直对此无动
      
    
    </summary>
    
      <category term="数据分析" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="http://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="微博" scheme="http://qinyuanpei.github.io/tags/%E5%BE%AE%E5%8D%9A/"/>
    
      <category term="词云" scheme="http://qinyuanpei.github.io/tags/%E8%AF%8D%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>冬天来了，春天还会远吗？</title>
    <link href="http://qinyuanpei.github.io/2017/11/19/wish-a-better-tomorrow.html"/>
    <id>http://qinyuanpei.github.io/2017/11/19/wish-a-better-tomorrow.html</id>
    <published>2017-11-19T10:16:17.000Z</published>
    <updated>2017-12-24T08:21:25.725Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;接到妈妈打来的电话时，时间已然接近中午时分，从床上爬起来的刹那间，就听见妈妈熟悉的声音。妈妈问我年底公司有没有什么变动<br>写下这篇文章的时候，心中可谓是百感交集，因为发生在年底的release事件，就像这个冬天里的雾霾如约而至。即使早在去年就经历过这样的事情，可当它发生在自己身上时，依然不免让人感到这个冬天的寒冷。如同二十四朝的兴废更替一般，历史对我们而言常常是相似的。我们的人生仿佛穿梭在一个平行蒙太奇的世界里，昨天和今天就在我们沉溺于回忆的顷刻间模糊了界限。我突然想到二十四时从第一家公司裸辞的自己，想到三年前和同学来第一次来西安的自己，想到一年前拖着行李独自来西安打拼的自己，可此时此刻我仿佛又回到这种状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;接到妈妈打来的电话时，时间已然接近中午时分，从床上爬起来的刹那间，就听见妈妈熟悉的声音。妈妈问我年底公司有没有什么变动&lt;br&gt;写下这篇文章的时候，心中可谓是百感交集，因为发生在年底的release事件，就像这个冬天里的雾霾如约而至。即使早在去年就经历
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="生活" scheme="http://qinyuanpei.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="工作" scheme="http://qinyuanpei.github.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>迁移Hexo博客到Google渐进式Web应用(PWA)</title>
    <link href="http://qinyuanpei.github.io/2017/10/24/migrate-hexo-as-a-progressive-web-app.html"/>
    <id>http://qinyuanpei.github.io/2017/10/24/migrate-hexo-as-a-progressive-web-app.html</id>
    <published>2017-10-24T23:13:41.000Z</published>
    <updated>2017-12-24T08:21:25.721Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;如果说通过TravisCI实现博客的自动化部署，是持续集成这个概念在工作以外的一种延伸，那么今天这篇文章想要和大家分享的，则是我自身寻求技术转型和突破的一种挣扎。前段时间Paul同我聊到Web技术的发展趋势，Paul认为Web应用会逐渐取代原生应用成为主流，我对此不置可否。真正让我陷入思考的是，在这个充满变化的时代，知识的更新速度远远超过你我的学习速度，我们应该如何去追随这个时代的步伐。如同那些淹没在时间河流里的技术名词，当青春不再的时候，我们喜欢把这个过程称之为成长，当发现距离第一次使用FontPage制作网站已过去十年，当发现曾经的网页三剑客在岁月蹉跎里频频改换姓名，当发现那些淹没在历史里的技术来不及学习就成为过往……或许，这个世界真正迷人的地方，就在于它每天都在不断变化。</p><h1 id="新一代Web应用——PWA"><a href="#新一代Web应用——PWA" class="headerlink" title="新一代Web应用——PWA"></a>新一代Web应用——PWA</h1><p>&emsp;&emsp;接着Paul关于Web技术的这个话题，我认为Web技术在短期内会成为原生应用的一种补充。事实上，原生应用和Web应用哪一个会是未来，这个问题的争论由来已久，在业界我们可以看到HTML5、PhoneGap、React/React Native、Electron/NW.js、小程序等方案百家争鸣，每一种方案都可以让我们去Web技术去打破平台间的差异。与此同时，我们注意到移动开发领域对原生技术的需求在缩减，虽然马克·扎克伯格曾表示，“选择HTML5是Facebook最大的错误“，可我们注意到，越来越多的Web技术被运用在原生应用中，Web技术被认为是最佳的打造跨平台应用的技术，可以通过一套代码实现不同平台间体验的一致性。我们注意到知乎和天猫的客户端中都混合使用了一定的Web技术，因为纯粹使用原生技术去开发一个移动应用，其最大的弊端就在于我们要为Android和iOS维护两套不同的代码，从国内曾经疯狂火热的iOS培训就可以看出，单独使用原生技术去开发客户端，其成本实际上是一直居高不下的。</p><p>&emsp;&emsp;虽然我们有Xamarin这样的跨平台技术，试图用一种编程语言和代码共享的方式，去开发两种不同平台的应用程序，可是我们注意到，平台间的差异和抗阻是天然存在的，就像SQL和面向对象这样我们再熟悉不过的例子。同样的，Facebook的React Native项目，试图用Web技术去弱化平台间的差异，React Native存在的主要问题是，它依然依赖原生组件暴露出来的组件和方法，所以像DatePickerIOS、TabBarIOS等控件是iOS Only的，这意味着在开发过程中开发者还是要考虑平台间的差异性，其次React本身的JSX(对应HTML)、CSS Layout(对应CSS)本身是具有一定的学习曲线的，虽然底层因为没有使用WebView的原因提高了部分性能，然而整体上是牺牲了扩展性的。总而言之，这是一个介于Web技术和原生技术之间的中间技术，在我看来地位着实蛮尴尬的，因为无论在Web层还是Native层都选择了部分妥协，完美实现跨平台真心不容易啊。</p><p>&emsp;&emsp;要掌握一门新技术，最好的方法就是去应用它。我的博客使用的是Indigo主题，这是一个典型的Material Design风格的主题，所以我一直想尝试将其改造成原生应用，我曾经接触过移动端应用开发，如果通过WebView内嵌网页的方式来实现，我需要处理离线状态下页面的显示问题，以及所有混合应用开发都会遇到的一个问题，即原生应用层需要和Web应用层进行通信的问题。而如果采用Hybrid App的思路去开发一个混合应用，意味着我需要去学习Cordova这样的Hybrid开发框架，去了解JavaScript和Native交互的细节。那么有没有一种学习成本相对较低，同时可以提供原生应用体验的思路呢？答案是确定的，这就是我们下面要说的渐进式应用(PWA)。</p><p>&emsp;&emsp;渐进式应用(Progressive Web Apps，PWA)是Google提出的新一代Web应用概念，其目的是提供可靠、快速、接近Native应用的服务方案。我们知道传统Web应用有两个关键问题无法解决，即<strong>需要从网络实时加载内容而带来的网络延迟</strong>和<strong>依赖浏览器入口而带来的用户体验</strong>，从某种意义上而言，渐进式应用的出现有望让这些问题得到解决，首先，渐进式应用可以显著加快应用加载速度，其提供的离线缓存机制可以让应用在离线环境下继续使用，关键技术为Service Worker和Cache Storage；其次，渐进式应用可以被添加到主屏，有独立的图标、启动页、全屏支持，整体上更像Native App，关键技术为Web.App Manifest；最后，渐进式应用同操作系统集成能力得到提高，具备在不唤醒状态下推送消息的能力，关键技术为Push API和Notification API。</p><h1 id="PWA中关键技术解析"><a href="#PWA中关键技术解析" class="headerlink" title="PWA中关键技术解析"></a>PWA中关键技术解析</h1><p>&emsp;&emsp;Google对外提出PWA这个概念其实是在今天的二月份左右，所以现在我写这篇文章实际上是在赶一趟末班车。我最近比较喜欢的一个男演员张鲁一，在接受媒体采访时媒体称他是一个大器晚成的人，他的确让我找到了理想中成熟男人的一个标准，如果你要问我这个标准是什么，我推荐你去看他主演的电视剧《红色》。那么，好了，为了让大家了解渐进式Web应用(<strong>PWA</strong>)，相比其它跨平台方案有何优缺点，我们这里来简单讨论下PWA中的关键技术。</p><h2 id="ServiceWorker"><a href="#ServiceWorker" class="headerlink" title="ServiceWorker"></a>ServiceWorker</h2><p>&emsp;&emsp;我们知道，传统的Web应用需要在网络环境下使用，当处在离线环境下时，因为HTTP请求无法被发送到服务器上，所以浏览器通常会显示一个空白页，并告知用户页面无法加载，因此会影响用户在离线环境下的使用体验，与此同时，因为Web页面在打开的过程中需要加载大量资源，因此在页面刚刚打开的一段时间内，用户看到的页面通常都是一个空白页面，考虑到缓存或者是预加载的Web应用，通常都会以预设资源作为占位符来填充页面，因此带来访问者的印象往往会更好。那么渐进式Web应用带给我们最大的惊喜，就是它可以在离线环境下使用，其核心技术就是ServiceWorker，我们来一起看看如何使用SeviceWorker：<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker.register(<span class="string">'service-worker.js'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(registration)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'service worker 注册成功'</span>);</span><br><span class="line">  &#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'servcie worker 注册失败'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们这里看到一个基本的注册ServiceWorker的代码片段，并且它采用了业界流行的Promise的写法。那么首先第一个问题，ServiceWorker到底是什么？ServiceWorker本质上是一个Web应用程序和浏览器间的代理服务器，它可以在离线环境下拦截网络请求，并基于网络是否可用以及资源是否可用，来采取相对应的处理动作，所以ServiceWorker最基本用法是作为离线缓存来使用，而高阶用法则是消息推送和后台同步。通常来讲，ServiceWorker会经历如下的生命周期：</p><p><img src="http://jbcdn2.b0.upaiyun.com/2016/01/55b0169cdfe92b08203757ebc4e5ece2.png" alt="ServiceWorker生命周期"><br>注：<strong>配图来自  <a href="http://web.jobbole.com/84792/" target="_blank" rel="noopener">http://web.jobbole.com/84792/</a></strong></p><p>&emsp;&emsp;按照<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">官方文档</a>中的定义，ServiceWorker同WebWorker一样，是一段JavaScript脚本，作为一个后台独立线程运行，其运行环境与普通的JavaScript不同，因此不直接参与Web交互行为，从某种意义上来说，ServiceWorker的出现，正是为了弥补Web应用天生所不具备的离线使用、消息推送、后台自动更新等特性，我们这里来看一个使用ServiceWorker缓存文件已达到离线使用的目的的例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheStorageKey = <span class="string">'minimal-pwa-1'</span></span><br><span class="line"><span class="keyword">var</span> cacheList = [</span><br><span class="line">  <span class="string">'/'</span>,</span><br><span class="line">  <span class="string">"index.html"</span>,</span><br><span class="line">  <span class="string">"main.css"</span>,</span><br><span class="line">  <span class="string">"e.png"</span></span><br><span class="line">]</span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(cacheStorageKey)</span><br><span class="line">    .then(<span class="function"><span class="params">cache</span> =&gt;</span> cache.addAll(cacheList))</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> self.skipWaiting())</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在这里例子中，我们在ServiceWorker的install事件中添加了待缓存文件列表，这将意味着这些静态资源，会在网页中的ServiceWorker被install的时候添加到缓存中，我们在某个合适的时机到来时就可以再次使用这些缓存资源。事实上考虑到安全性的问题，ServiceWorker在设计时被约束为按照路径给予最高权限，即ServiceWorker在指定路径下是有效的。这里简单提下ServiceWorker的缓存策略，因为这个问题在我看来蛮复杂的，例如官方出品的<a href="https://github.com/GoogleChromeLabs/sw-toolbox" target="_blank" rel="noopener">sw-tool</a>中定义的缓存策略就有如下五种：</p><ul><li>网络优先:：从网络获取, 失败或者超时再尝试从缓存读取</li><li>缓存优先:：从缓存获取, 缓存插叙不到再尝试从网络抓取</li><li>最快：同时查询缓存和网络, 返回最先拿到的</li><li>仅限网络：仅从网络获取</li><li>仅限缓存：仅从缓存获取</li></ul><p>&emsp;&emsp;我们刚刚提到被缓存的静态资源会在合适的时机被再次使用，那么什么时候可以称之未合适的时机呢？在这个问题中，我们是指fetch事件，事实上通过拦截fetch事件，我们就可以拦截即将被发送到服务器端的HTTP请求，ServiceWorker首先会检查缓存中是否存在待请求资源，如果存在，就直接使用这个资源并返回HTTP响应，否则就发起HTTP请求到服务器端，此时ServiceWorker担任的是一个代理服务器的角色。至此，我们就会明白，ServiceWorker的作用其实就是在离线条件下利用缓存伪造HTTP响应返回，这样我们就达到了离线使用的目的，传统的Web应用在离线环境无法使用，根本原因是没有这样一个Mock的Server去伪造HTTP响应并返回，因为HTTP请求此时根本就无法发送到服务端。为了让ServiceWorker全面接管HTTP请求以便利用请求，我们这里的实现方式如下：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span> &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.<span class="built_in">match</span>(event.request)</span><br><span class="line">      .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(response)</span></span> &#123;</span><br><span class="line">        // Cache hit - <span class="keyword">return</span> response</span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;好了，以上就是ServiceWorker在离线缓存方面的基本用法，希望进行深入了解的朋友，可以参考文末链接做进一步研究。</p><h2 id="Web-App-Manifest"><a href="#Web-App-Manifest" class="headerlink" title="Web App Manifest"></a>Web App Manifest</h2><p>&emsp;&emsp;接下来介绍Web App Manifest，它其实是Web开发领域的一个”叛徒”，因为它所做的事情为大家所不齿，基本可以概括为，怎么样假装自己是一个Native App，我们直接看它的定义：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Minimal app to try PWA"</span>,</span><br><span class="line">  <span class="attr">"short_name"</span>: <span class="string">"Minimal PWA"</span>,</span><br><span class="line">  <span class="attr">"display"</span>: <span class="string">"standalone"</span>,</span><br><span class="line">  <span class="attr">"start_url"</span>: <span class="string">"/"</span>,</span><br><span class="line">  <span class="attr">"theme_color"</span>: <span class="string">"#8888ff"</span>,</span><br><span class="line">  <span class="attr">"background_color"</span>: <span class="string">"#aaaaff"</span>,</span><br><span class="line">  <span class="attr">"icons"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"e.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"256x256"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个我确认没有什么好说的，详细的参数可以参考<a href="http://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/Manifest" target="_blank" rel="noopener">这里</a>，通常我们需要将以上文件命名为manifest.json，并通过以下方式引入到HTML结构中，通常是添加在<head>标签下，我们所期望的图标、启动页、主题色等Native App的特性都是在这里定义的，这里想吐槽的是，随着越来越多的平台开始向<head>标签中注入”新血液”，譬如<meta>标签和<link>标签：现在HTML结构变得越来越复杂，更不要说主流的AngularJS和Vue这类MVVM框架，基本上都是通过扩展HTML属性来完成数据绑定的。对PWA应用来讲，我们只需要在<head>标签下引入以下内容：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">"manifest"</span> <span class="attribute">href</span>=<span class="string">"manifest.json"</span> /&gt;</span><br></pre></td></tr></table></figure></head></head></head></p><p>这里简单介绍下Web App Manifest中常见的参数含义及其作用：</p><ul><li>name/short_name：表示应用被添加到屏幕上以后显示的名称，当屏幕空间不足以显示完整的name时，将显示short_name。</li><li>start_url：表示用户从屏幕启动应用时所加载网页的URL，通常我们将其指向网站的首页。</li><li>theme_color：表示应用程序的主题颜色，PWA事实上是建议使用Material Design设计风格的，因此该属性可以控制应用的主题颜色，并在页面加载完成前展示一个过渡动画。</li><li>scope：表示PWA应用的作用域，即哪些页面可以以PWA应用的形式呈现。</li><li>display：表示PWA应用呈现的方式，可以是fullscreen、standalone、minimal-ui和browser中的任意取值。</li><li>orientation：表示PWA应用的屏幕方向，如果你有移动开发的经验，对此应该不会感到陌生。</li><li>icons：表示PWA应用在屏幕上的图标，为了适配不同尺寸的屏幕，这里可以设置不同尺寸下的图标。同样地，如果你有移动开发的经验，对此应该不会感到陌生。</li></ul><h2 id="Push-Notification-API"><a href="#Push-Notification-API" class="headerlink" title="Push/Notification API"></a>Push/Notification API</h2><p>&emsp;&emsp;关于这两个东西，我们简单说一下啊，PWA中的Push机制主要有<a href="https://www.w3.org/TR/notifications/" target="_blank" rel="noopener">Notification</a>和<a href="https://www.w3.org/TR/push-api/" target="_blank" rel="noopener">Push API</a>两部分组成，前者用于向用户展示通知，而后者用于订阅推送消息。网络上对这块介绍的并不多，关于推送这个问题，一直是国内Android用户和开发者的一块心病，因为Google的推送服务在国内水土不服，因此国内厂商或者是SDK提供商基本上都有自己的一套方案，这就导致在用户的设备上同时开启着若干个消息推送服务，用户手机里的电就是这样一点点被耗尽的，所以这个问题大家看看就好。在PWA中，我们可以通过ServiceWorker 的后台计算能力结合 Push API 对推送事件进行响应，并通过 Notification API 实现通知的发出与处理：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'push'</span>, event =&gt; &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">// Process the event and display a notification.</span></span><br><span class="line">    <span class="keyword">self</span>.registration.showNotification(<span class="string">"Hey!"</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'notificationclick'</span>, event =&gt; &#123;  </span><br><span class="line">  <span class="comment">// Do something with the event  </span></span><br><span class="line">  event.notification.close();  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'notificationclose'</span>, event =&gt; &#123;  </span><br><span class="line">  <span class="comment">// Do something with the event  </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="移植Hexo博客到PWA应用"><a href="#移植Hexo博客到PWA应用" class="headerlink" title="移植Hexo博客到PWA应用"></a>移植Hexo博客到PWA应用</h1><p>&emsp;&emsp;现在，我们基本了解了PWA的概念以及实现PWA的关键技术，我们现在考虑将Hexo博客改造成一个PWA应用，我们这里不打算考虑消息推送的相关问题，所以对Hexo这样一个静态博客生成器而言，我们可以做的实际上只有两件事情，即通过Web App Manifest让它更像一个Native应用，通过ServiceWorker为它提供离线缓存的特性。我们从最简单的开始，我们需要在Hexo的根目录中增加一个manifest.json文件，该文件我们可以通过这个网站 <a href="http://www.manifoldjs.com/generator" target="_blank" rel="noopener">manifoldjs.com</a> 来生成。下面给出博主博客中使用的配置：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"飞鸿踏雪的部落格"</span>,</span><br><span class="line">  <span class="attr">"short_name"</span>:<span class="string">"Payne's Blog"</span>,</span><br><span class="line">  <span class="attr">"description"</span>:<span class="string">"人生到处知何似，应似飞鸿踏雪泥"</span>,</span><br><span class="line">  <span class="attr">"icons"</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird36.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"36x36"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird48.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"48x48"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird72.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"72x72"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird96.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"96x96"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird144.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"144x144"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird192.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"192x192"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">"background_color"</span>:<span class="string">"#fff"</span>,</span><br><span class="line">  <span class="attr">"theme_color"</span>:<span class="string">"#000"</span>,</span><br><span class="line">  <span class="attr">"start_url"</span>:<span class="string">"/"</span>,</span><br><span class="line">  <span class="attr">"display"</span>:<span class="string">"standalone"</span>,</span><br><span class="line">  <span class="attr">"orientation"</span>:<span class="string">"portrait"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;好了，现在我们来考虑如何去实现一个ServiceWorker，Google官方提供了一个ServiceWorker的<a href="https://github.com/GoogleChrome/samples/tree/gh-pages/service-worker/basic" target="_blank" rel="noopener">示例项目</a>，以及网友提供的<a href="https://github.com/minimal-xyz/minimal-pwa" target="_blank" rel="noopener">Minimal-PWA</a>，这两个项目都可以帮助我们去了解，如何去实现一个ServiceWorker，甚至于我们有<a href="http://link.zhihu.com/?target=https%3A//github.com/GoogleChrome/sw-precache" target="_blank" rel="noopener">sw-toolbox</a>和<a href="http://link.zhihu.com/?target=https%3A//github.com/GoogleChrome/sw-precache" target="_blank" rel="noopener">sw-precache</a>这样的工具，配合gulp和webpack我们定制缓存策略并生成ServiceWorker。可是你要知道，懒惰对程序员而言是一种美德，在这里我选择了Hexo的插件<a href="https://github.com/JLHwung/hexo-offline" target="_blank" rel="noopener">hexo-offline</a>，该插件可以帮助我们生成ServiceWoker，关于它的使用及配置，大家可以自行去了解，我重点想说说支持ServiceWorker以后，我的博客所呈现出来的变化以及PWA实际运行的效果。</p><p><img src="http://img.blog.csdn.net/20171119125504778" alt="ServiceWorker和Cache Storage"></p><p>&emsp;&emsp;通过这张图，我们可以清楚地看到，ServiceWorker确实在后台工作着，而Cache Storage确实对博客内的静态资源做了缓存处理。事实上对Hexo这样的静态博客而言，整个博客都是静态资源，所以在实际运行中它会对所有内容进行缓存，我们可以在终端中验证这个想法：</p><p><img src="http://img.blog.csdn.net/20171119130811446" alt="在Hexo中监听到的缓存请求"></p><p>&emsp;&emsp;可我想说这一切并没有什么用，因为我并不能如愿地在离线状态下访问我的博客，甚至因为有了缓存机制，当我在撰写这篇博客时，虽然我改变了markdown文档的内容，但当我刷新博客的时候，因为缓存机制的存在，我不能像从前那样直接看到博客的变化，更重要的一点是，整个缓存大概有8M左右的体积，因此每次请求页面时，我能够明显地感觉到页面加载的延迟，看起来我们费了大量周折最终却一无所获，这听起来实在是讽刺不是吗？</p><p>&emsp;&emsp;说完了ServiceWorker，我们再来说说Web App Manifest，我尝试从豌豆荚下载了移动版Chrome，可我自始至终无法将应用添加到主屏幕，貌似这需要Android系统底层的支持，我测试了两部手机，一部OPPO手机和一部小米手机，发现都没有明显的PWA支持，当我访问页面的时候，浏览器更加不会主动提示我”将应用添加到主屏”，像UC浏览器是将网站以应用的形式添加到浏览器首页，这的确没有什么值得令人惊喜的地方，因为在PC端的时候，我们就可以做到类似地实现，这篇文章耗费时间蛮长的啦，大概是因为我不知道，该如何描述这个失败的尝试。最近接触到一位前辈的项目，这是一个需要跨PC端和移动端的项目。目前面临的一个挑战就是，移动端有太多依赖原生接口的功能设计，所以一套代码在全平台适配，真的仅仅是一个美好的理想，离实现永远有一段不可逾越的距离。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文主要以Google提出的渐进式Web应用(Progressive Web Apps)为主线，简单探讨了Google的渐进式Web应用及其关键技术。渐进式Web应用试图解决传统Web应用的两个关键问题，即<strong>需要从网络实时加载内容而带来的网络延迟</strong>和<strong>依赖浏览器入口而带来的用户体验</strong>。首先，渐进式应用可以显著加快应用加载速度，其提供的离线缓存机制可以让应用在离线环境下继续使用，关键技术为Service Worker和Cache Storage；其次，渐进式应用可以被添加到主屏，有独立的图标、启动页、全屏支持，整体上更像Native App，关键技术为Web.App Manifest；最后，渐进式应用同操作系统集成能力得到提高，具备在不唤醒状态下推送消息的能力，关键技术为Push API和Notification API。在此背景下，我们对静态博客Hexo进行了改造，尝试将其迁移到一个PWA应用上，虽然最终以失败告终，可是在整个过程中我们依然有所收获，我觉得一件事情能让我们有所思考或者有所感悟的话，这就已然是一种幸运、一种成功啦。</p><p>&emsp;&emsp;其实Web应用与原生应用并非彼此水火不容，除了纯粹的Web技术和Native技术以外，在这两者之间我们看到的更多是混合技术的应用，所以我认为开发人员在未来一定要具备两种能力，即跨语言和跨平台开发的能力。比如小程序是在微信原生生态下建立的定制化Web应用，它有着类似HTML/CSS/JavaScript的技术方案，同时提供了统一的应用程序外观和使用体验；而跨平台游戏引擎cocos2d-x，通过JavaScript Bridge等类似技术，则可以实现将Web技术转化为Native技术…..总而言之，在技术选型这个问题上，我们可以选择的方案越来越多，如何让想法可以伴随技术产生优秀的产品，这是我们在这个时代真正该去思考的问题。目前来讲，国内普遍重视iOS，可惜遗憾的是iOS不支持PWA；国内的Android系统经过阉割以后，国内用户无法使用Chrome，以及各个厂商定制的浏览器存在兼容性问题；国内因为政策及现实原因，第三方推送相对GCM推送要活跃很多，厂商并不会太关注对PWA应用推送的支持。虽然现实如此，可Web技术发展到今天为止，我们能做的就是希望它越来越好，在此引用<a href="https://huangxuan.me" target="_blank" rel="noopener">黄玄</a>的一句话：</p><blockquote><p>我们信仰 Web，不仅仅在于软件、软件平台与单纯的技术，还在于『任何人，在任何时间任何地点，都可以在万维网上发布任何信息，并被世界上的任何一个人所访问到。』而这才是 web 的最为革命之处，堪称我们人类，作为一个物种的一次进化。」</p></blockquote><hr><ul><li><a href="http://harttle.com/2017/01/28/pwa-explore.html" target="_blank" rel="noopener">PWA 初探：基本特性与标准现状</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service Worker API</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API/Using_the_Push_API" target="_blank" rel="noopener">Using the Push API</a></li><li><a href="http://web.jobbole.com/84792/" target="_blank" rel="noopener">Service Worker初体验</a></li><li><a href="https://zhuanlan.zhihu.com/p/25524382" target="_blank" rel="noopener">PWA 入门: 理解和创建 Service Worker 脚本</a></li><li><a href="https://zhuanlan.zhihu.com/p/25459319" target="_blank" rel="noopener">PWA 入门: 写个非常简单的 PWA 页面</a></li><li><a href="http://huangxuan.me/2017/02/09/nextgen-web-pwa/" target="_blank" rel="noopener">下一代 Web 应用模型 —— Progressive Web App</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;如果说通过TravisCI实现博客的自动化部署，是持续集成这个概念在工作以外的一种延伸，那么今天这篇文章想要和大家分享的，则是我自身寻求技术转型和突破的一种挣扎。前段时间Paul同我聊到Web技术的发展趋势，Paul认为Web应用会逐渐取代原生应用成
      
    
    </summary>
    
      <category term="独立博客" scheme="http://qinyuanpei.github.io/categories/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://qinyuanpei.github.io/tags/Hexo/"/>
    
      <category term="PWA" scheme="http://qinyuanpei.github.io/tags/PWA/"/>
    
      <category term="Web" scheme="http://qinyuanpei.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>持续集成在Hexo自动化部署上的实践</title>
    <link href="http://qinyuanpei.github.io/2017/10/21/practice-of-continuous-integration-on-hexo-deployment.html"/>
    <id>http://qinyuanpei.github.io/2017/10/21/practice-of-continuous-integration-on-hexo-deployment.html</id>
    <published>2017-10-21T22:57:55.000Z</published>
    <updated>2017-12-24T08:21:25.721Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;曾经听到过这样一句话，”不要用战术上的勤奋掩盖战略上的懒惰”，所以战术和战略更像是抽象类和具体类，而面向对象设计实际上是现实等级制度的一种映射。因此我们注意到，决策者通常关注的是战略层面的抽象概念，而执行者通常更关注战术层面的具体实现，正如在代码的架构设计中，处在顶层的代码以发送指令为主要使命，处在底层的代码以实现功能为主要使命。面对日新月异的互联网技术，当我们听到越来越多的新名词，譬如微服务、DevOps、单页面应用、前后端分离等等，这些概念曾让我们迷恋于追寻一个又一个风口，一如曾经的O2O、VR、共享经济和人工智能，那么我们真的懂得如何让这些概念落地吗？在今天这篇文章中，我想和大家一起探讨持续集成相关的话题，并以Hexo结合TravisCI实现自动化部署为例，聊聊我心目中的DevOps。</p><h1 id="从DevOps谈谈持续集成"><a href="#从DevOps谈谈持续集成" class="headerlink" title="从DevOps谈谈持续集成"></a>从DevOps谈谈持续集成</h1><p>&emsp;&emsp;不知从何时起，DevOps开始成为大家竞相追捧的概念，同ThoughtWorks所倡导的微服务、敏捷开发一样，大家仿佛抓住了一根新的救命稻草一般，那么我们在说DevOps的时候，我们到底想要表达什么观点呢？想要搞清楚这个问题，我认为首先要明白，什么是DevOps？从概念上讲，DevOps是一个面向IT运维的工具流，以IT自动化以及持续集成(CI)、持续部署(CD)为基础，目的是优化开发、测试、运维等所有环节，所以DevOps本质上是一组部门间沟通协作的流程和方法，其目的是为了协调开发(DEV)、测试(QA)、运维(OPS)这三种角色，使开发运维一体化，通过高度自动化工具和流程，来确保软件构建、测试和发布更加快捷、频繁和稳定。</p><p>&emsp;&emsp;所以，我们在说DevOps的时候，我们想表达的或许是流程和管理、运维和自动化、架构和服务、文化和组织等等的概念，那么在这些观点中，最重要的是什么呢？我认为是持续集成(CI)和持续部署(CD)，这是DevOps中从始至终贯穿的一条主线。通过Git这样的源代码控制工具，我们可以确保项目在一条主干上开发。而自动化测试/部署等周边工具，则为我们提供了实施持续集成/持续部署的必要条件。从公司角度出发，公司普遍更看重项目的交付能力，所以在传统持续集成/部署的基础上，我们时常会听到持续交付这样的声音，这时我们就会意识到，DevOps实则是持续集成思想的一种延伸，它并不是一个新的概念，事实上我们这个行业，每年都喜欢这种“旧酒换新瓶”的做法，持续集成/部署/交付是DevOps的核心技术，如果没有自动化测试和自动化部署，DevOps就是难以落地的空中楼阁。</p><p>&emsp;&emsp;由此，我们就引出今天这篇文章的主题，即持续集成。我们提到，DevOps是是一套面向IT的跨部门协作的工作流，它是持续集成思想的一种延伸，所以持续集成首先是一组工具链的集合。从某种意义上来讲，决策者喜欢DevOps，并不是真正喜欢DevOps，而是形式上的DevOps非常容易实现，因为有形的工具资源的整合是非常容易的，真正困难的是无形的流程资源的整合。你可以让两个陌生人在一起假装情侣，但你永远不可能真正拉近两个人心间的距离。通常而言，我们会用到下列工具：</p><ul><li>版本控制和协作开发：Github、GitLab、BitBucket、Coding等。</li><li>自动化构建和测试：Apache Ant、Maven、Selenium、QUnit、NUnit、XUnit、MSBuild等。</li><li>持续集成和交付：Jenkins、TravisCI、Flow.CI等。</li><li>容器/服务部署：Docker、AWS、阿里云等。</li></ul><p>&emsp;&emsp;从术和道的角度来看待持续集成，我们会发现在术的层面上，我们有非常多的选择空间，所以接下来我们主要从道的层面，来说说持续集成的核心思想。我们提到在实践DevOps的时候，需要有一条项目主干，那么持续集成的基本概念，就是指频繁地提交代码到主干分支，这样做的目的是，保证问题被及时发现以及避免分支大幅度偏离主干。</p><p>&emsp;&emsp;在使用Git的场景下来看待持续集成，及时提交代码到主分支，可以避免因为分支改动过大而带来的冲突问题。按照敏捷开发的理论，每个feature通过迭代开发来集成到最终产品中，那么持续集成的目的，就是为了让产品可以在快速迭代的同时保证产品质量。在这里产品质量有两层含义，第一，本次feature提交通过测试；第二，本次feature提交无副作用。我们可以注意到，持续集成的第一个目的，即保证问题被及时发现，对应前者；持续集成的第二个目的，即避免分支大幅度偏离主干，对应后者。</p><p>&emsp;&emsp;所谓持续集成，是指代码在集成到主干前，必须要通过自动化测试，只要有一个测试用例失败，就不能集成到主干，所以持续集成和自动化测试天生就是紧密联系在一起的。我们不能只看到持续集成/部署/交付，如果连流程上的自动化都无法实现，这些都是无从谈起的，从开发者的角度来看，理想的状态是编译即部署，我们提交的每一行代码，都是可以集成、交付和部署的代码，所以实际上是对开发者的代码质量提高了要求。所有我们觉得美好的事情，其实核心都在于人如何去运作，想到一位前辈说过的话，“软件开发没有银弹”，所有试图通过某种方法论解决软件工程复杂性的想法，都是天真而幼稚的。</p><h1 id="Jenkins持续集成落地实践"><a href="#Jenkins持续集成落地实践" class="headerlink" title="Jenkins持续集成落地实践"></a>Jenkins持续集成落地实践</h1><p>&emsp;&emsp;博主曾经在公司项目上实践过持续集成，深感持续集成想要真正在团队里落地，受到太多太多的因素制约。我们采取的方案是，使用Git/Github作为源代码版本控制工具，使用Jenkins作为持续集成工具，使用MSBuild作为项目构建工具，使用MSTest/NUnit作为单元测试框架，使用Selenium/UI Automation作为UI自动化测试框架，这些工具可以很好地同Jenkins整合起来。在持续集成工具的选择上，我们并没有太多的选择空间，因为公司需要同时支持Java和JavaScript/Nodejs项目的持续集成，在持续集成落地这件事情上，我们最终选择了妥协，我们不再追求自动化部署，而是选择通过这个过程来快速定位问题，具体原因我们下面来讲。</p><p>&emsp;&emsp;首先，我们期望的是开发者在提交代码以后，可以触发编译、构建、测试和部署等一系列操作，我们会通过Git从远程仓库拉取最新代码，然后通过MSBuild来编译整个代码，由于MSBuild提供了定制化的脚本，可以对编译、测试和部署等环节进行精准控制，所以我们在Jenkins上触发的实际上是一系列动作，而这些都是可以在Jenkins上进行配置的，我们通常会将Jenkins上的日志以邮件形式发送给开发者，所以在很长一段时间里，每天到公司第一件事情，就是查看邮箱里的邮件，一旦发现有测试用例没有通过测试，我们就需要重复“修改代码“-&gt;“提交代码“这个过程，直至所有用例都完全通过测试，理论上通过测试的代码就可以直接部署上线，因为MSBuild可以帮助我们生成最终文件，我们只需要将其打包然后上传到服务器即可，可是实际上这是我们假想的一种场景而已，因为现实场景中我们考虑得通常会更多。</p><p>&emsp;&emsp;一个关键的问题是，我们没有可以量化的标准去评估，本次提交是否可以集成到主干。我知道你一定会说测试，事实是开发者不喜欢写测试，或者是写了不可测的测试，前一种观点认为写测试会占用开发时间，所以在开发时间相对紧张的时候，这就变成了我们不写测试的借口；后一种观点则是不会写可测试代码的表现，典型的表现是代码耦合度高、依赖大量无法Mock的对象实例、不会合理使用断言，所以在这种情况下，持续集成是没有意义的，我们不知道何时代码可以集成、交付和部署。我承认自动化测试无法全面替代人工测试，但当我们的关注点放在交付和部署上的时候，是否应该考虑先让持续集成落地，这实在是比DevOps更基础、更接地气，因为我相信持续集成是一种思想，它对开发团队中的每一个人都提出了更高的要求，持续集成是为了在保证产品质量的同时快速迭代，如果你心中没有产品质量的概念，DevOps并不能帮你提高产品质量。</p><p>&emsp;&emsp;第二个关键的问题是，开发和运维该如何去协作，DevOps是为了促进部门间沟通协作而提出的一套工作流，自动化是这套机制能够良好运行下去的前提，可是在现实场景中一切并没有那么理想。以我们公司为例，开发组和运维组分属两个不同的部门，运维组在上线、部署等关键环节设置了严格的审批流程，即运维组牢牢地控制着线上生产环境，所以即使我们通过MSBuild在Jenkins上为程序打好了包，我们依然需要按照运维组的要求，提交上线请求、人工上传程序以及等待部门审批，通常我们上线只有等到每周五，而上线流程所需的东西，我们需要在一周前准备好，所以你可以注意到一个现象，虽然在流程上开发团队和运维团队是结合在一起的，但实际上两者的工作目标依然是分离的。那是不是将两个团队放在一起工作，就能解决这个问题呢？我想合作的前提是相互理解和信任，如果彼此都不愿意去了解对方的工作流程，DevOps可能仅仅是我们用工具堆积出来的虚幻感。</p><h1 id="实现Hexo博客的自动化部署"><a href="#实现Hexo博客的自动化部署" class="headerlink" title="实现Hexo博客的自动化部署"></a>实现Hexo博客的自动化部署</h1><p>&emsp;&emsp;好了，在公司使用Jenkins实践持续集成，在现实场景中总会受到各种各样的制约，这并不是因为持续集成这个想法不好，而是在现实面前我们都选择了妥协。有句话说，“如果没有见过光明，我本可忍受黑暗”，我们喜欢一个人或者是一样东西，都是因为我们觉得它是美好的，可以让我们觉得这个世界温暖，那么在公司以外的地方，我想更加自由地做些我喜欢的事情。在公司实践持续集成的时候，因为公司对权限的严格控制，我难以实现那种想象中的持续集成，即在成功地在提交代码以后直接触发编译和部署，我想在公司之外做成这件事情。</p><p>&emsp;&emsp;为什么想到要给博客做持续集成呢？首先，持续集成和单元测试联系紧密，我自认为我的单元测试刚刚入门，为了写出更好的单元测试，我必须要这样做，来强迫自己努力去写好单元测试；其次，持续集成可以将开发和部署分离，所以我在任何一台计算机上撰写博客，都可以通过TravisCI实现编译和部署，对Hexo这种静态博客而言，部署其实就是推送页面到Github而已，整体难度并没有太高。最后，我平时更新博客都是手动推送页面，因为我不喜欢用Hexo提供的部署功能，现在我想让自己专注在内容写作上，而一切都可以在我的控制范围内。这正是我所想，如果能让一切更好一点，我都愿意去尝试和努力。</p><p>&emsp;&emsp;关于Hexo这类静态博客生成器搭建博客的原理，我这里不想在赘述，因为我愿意相信，懂得搭建博客的人，一定是了解Git、Github Pages和Markdown等等的概念的，关于配置相关的细节大家可以参考官网。这里想着重介绍下TravisCI，TravisCI是一个在线的、分布式的持续集成服务，可以用来构建和测试托管在Github上的代码，并且其本身就是开源的。TravisCI提供了主流编程语言如C#、Java、JavaScript、Ruby、PHP、Node.js等的支持，相比Jenkins而言，它是一个轻量级的持续集成平台，它会在每次提交代码后，根据配置文件来创建一个虚拟机，并执行用户定义的Build任务，这个虚拟机提供版本控制(<strong>Git</strong>)、项目构建(<strong>Node.js</strong>)等，在此前提下，我们下面着手Hexo的自动化部署。</p><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>&emsp;&emsp;Hexo博客实际上可以分成两部分，即博客源代码和静态页面。其中博客源代码主要是指Hexo及其相关模块、博客内容(<strong>source</strong>)、博客主题(<strong>theme</strong>)，而静态页面由Hexo动态生成，通常放置在<strong>public</strong>目录中。对Hexo来讲，我们最终部署需要的是这些静态页面，所以我们设计得一个方案是，将静态页面存放在master分支，将博客源代码存放在blog分支。当用户提交代码到blog分支后，会触发TravisCI中定义的一系列操作，它会首先从blog分支拉取博客源代码，然后在TravisCI中完成静态页面的生成，最后将其提交到master分支以完成博客的更新，整个过程非常优雅，终于让我彻底摆脱了手动更新博客的过去，而更重要的是，从此写博客不再受地点的制约，因为写博客就是提交代码，生成静态页面以及部署到Github Pages，现在全部交给了TravisCI.</p><h2 id="配置TravisCI"><a href="#配置TravisCI" class="headerlink" title="配置TravisCI"></a>配置TravisCI</h2><p>&emsp;&emsp;TravisCI是一个轻量级的持续集成方案，其轻量级主要体现在它的配置文件，即使用TravisCI并不需要我们安装任何软件，我们仅仅需要提供一个.travis.yml文件即可，该文件通常被放置在项目根目录里。和Jenkins这样的持续集成工具不同，我们在这个文件中即可定制Build任务，下面给出一个基本的配置文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">language</span>: node_js</span><br><span class="line"><span class="attribute">node_js</span>: stable</span><br><span class="line"></span><br><span class="line"># S: Build Lifecycle</span><br><span class="line"><span class="attribute">install:</span></span><br><span class="line">  - npm install</span><br><span class="line"></span><br><span class="line"><span class="attribute">script:</span></span><br><span class="line">  - hexo clean</span><br><span class="line">  - hexo generate</span><br><span class="line"></span><br><span class="line"><span class="attribute">after_script:</span></span><br><span class="line">  - cd ./public</span><br><span class="line">  - git init</span><br><span class="line">  - git config user.name "qinyuanpei"</span><br><span class="line">  - git config user.email "qinyuanpei@163.com"</span><br><span class="line">  - git add .</span><br><span class="line">  - git commit -m "Update Blog"</span><br><span class="line">  - git push --force --quiet "https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;" master:master</span><br><span class="line"># E: Build LifeCycle</span><br><span class="line"></span><br><span class="line"><span class="attribute">branches:</span></span><br><span class="line">  only:</span><br><span class="line">    - blog</span><br><span class="line">    </span><br><span class="line"><span class="attribute">env:</span></span><br><span class="line"> global:</span><br><span class="line">   - GH_REF: github.com/qinyuanpei/qinyuanpei.github.io</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果大家熟悉Jenkins的使用，就会发现这里定义的Build任务似曾相识。在这里我们首先指定了项目构建语言，即这是一个node.js的项目，然后我们会通过npm安装所有依赖，我们注意到在根目录里有一个package.json文件，该文件定义了整个项目依赖的项目。如果你使用过Nuget，你会发现这一切都是如此的合理。那么当整个环境准备就绪以后，我们就可以着手博客的构建啦，和平时一样，我们会执行hexo clean和hexo generate命令，这样Hexo会帮助我们生成所有的静态页面，现在我们通过Git将其推送到master分支，通常基于Github Pages托管的页面都是存放在gh-pages分支的，可是对Hexo而言，我们放在master分支是没有问题的，这就是TravisCI构建整个博客的具体过程。</p><h2 id="关联TravisCI"><a href="#关联TravisCI" class="headerlink" title="关联TravisCI"></a>关联TravisCI</h2><p>&emsp;&emsp;到目前为止，我们定义好了TravisCI将会在虚拟机中执行的Build任务。我们知道，这里TravisCI是需要访问我们托管在Github上的代码仓库的，所以我们必须将这个代码仓库和Travis关联起来，这样它就具备了从代码仓库拉取代码(<strong>Pull</strong>)和向代码仓库推送(<strong>Push</strong>)代码的能力。印象中公司是给每一个Jenkins服务器关联了一个Github账户，这样需要持续集成的项目只需要添加这个账号，并为其赋予基本的读写权限即可。在这里是类似的，我们有两种方案来关联TravisCI，即为TravisCI虚拟机添加SSH-Key和使用Github提供的Personal Access Token。</p><p>&emsp;&emsp;前者和我们平时使用Git时配置SSH-Key是一样的，但考虑到公开密钥产生的安全性问题，TravisCI建议我们使用官方的一个工具来对密钥进行加密，这是一个基于Ruby开发的命令行工具，加密后的内容可以在TravisCI中解密，这种方案需要安装Ruby，博主选择放弃。如果你要问我为什么放弃Ruby，大概是因为我忘不了曾经被Jekyll支配的恐惧感。而后者的原理是将Github生成的Token作为一个环境变量存储在TravisCI中，我们在定义TravisCI中的Build任务时可以引用这些环境变量，我们只需要在执行Git命令时带上这个Token就可以了。显然这种方式更合我的胃口，它的缺点是对此Github采用了粗放式的权限控制，即这个Token时可以访问所有代码仓库的，这一点大家自己可以根据自身情况来决定要使用哪一种方式。</p><p>&emsp;&emsp;我们在Github中的Setting-&gt;Developer Settings找到Personal Access Token，然后选择所有repo相关的权限，生成这个token后将其复制下来备用，因为它只有在这个地方是可见的。接下来我们打开<a href="https://www.travis-ci.org" target="_blank" rel="noopener">TravisCI</a>，在使用Github登录后我们就可以在这里看到所有的项目，如图是我个人的TravisCI界面：</p><p><img src="http://img.blog.csdn.net/20171028234101618" alt="TravisCI主界面"></p><p>大家可以注意到，这里我开启了qinyuanpei.github.io这个仓库的持续集成服务，如果大家没有在这里看到项目列表，可以点击”Sync account”按钮进行同步。好了，现在我们继续配置：</p><p><img src="http://img.blog.csdn.net/20171028234224795" alt="配置TravisCI"></p><p>在这里我们配置了名为CI_TOKEN的环境变量，该值对应.travis.yml文件中的${CI_TOKEN}。现在我们在本地提交代码到blog分支，就会触发TravisCI执行Build任务，在这里Build任务是从blog分支拉取博客内容及主题，通过npm安装依赖的nodejs模块，最终Hexo生成的静态页面会被推送到master分支，这样就完成了整个自动化构建的流程。下面是TravisCI执行Build过程中的日志界面：</p><p><img src="http://img.blog.csdn.net/20171029001105352" alt="TravisCI日志"></p><p>&emsp;&emsp;从计划写这样一篇文章，到我一边写博客一篇将它发布在网络上，前后花了大概我3天左右的时间。这段时间发生了太多太多的事情，所以写东西受难免受到情绪影响，你现在看到这篇由TravisCI自动生成的博客，大概无法想象屏幕前的我有着怎样复杂的心绪，有时候我告诉自己要沉下心来学点什么，有时候我会觉得此时的我和过去没有什么区别。转眼间忙忙碌碌一年到头，可会想起来顿时觉得时间像虚度一般，有人说，当你对未来不再有什么期许的时候，就是你开始衰老的迹象，可我真的老了吗？我不是只有25岁吗？好啦，夜深人静，该去睡觉了，这篇文章就是这样子啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;曾经听到过这样一句话，”不要用战术上的勤奋掩盖战略上的懒惰”，所以战术和战略更像是抽象类和具体类，而面向对象设计实际上是现实等级制度的一种映射。因此我们注意到，决策者通常关注的是战略层面的抽象概念，而执行者通常更关注战术层面的具体实现，正如在代码的架
      
    
    </summary>
    
      <category term="开发工具" scheme="http://qinyuanpei.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Hexo" scheme="http://qinyuanpei.github.io/tags/Hexo/"/>
    
      <category term="Travis" scheme="http://qinyuanpei.github.io/tags/Travis/"/>
    
      <category term="CI" scheme="http://qinyuanpei.github.io/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>不如归去</title>
    <link href="http://qinyuanpei.github.io/2017/10/21/it-would-be-better-to-return.html"/>
    <id>http://qinyuanpei.github.io/2017/10/21/it-would-be-better-to-return.html</id>
    <published>2017-10-21T22:31:48.000Z</published>
    <updated>2017-12-24T08:21:25.717Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;独自一个人在火车上望着窗外出神，而这种情景我再熟悉不过，或许风景会因为季节而不同，或许时间会因为年龄而不同，但对我而言，这个过程熟悉得就像一个我讲了无数遍的故事，从开篇布局到故事脉络都清楚到严丝合缝。印象中是从初中时候就开始寄宿生活，所以这种漂泊的感觉成为我生命里重要的烙印，而从那一刻起，我最期待的是寒暑假期，因为这象征着一段漂泊旅程的结束。大概是因为双子座属于风象星系，所以每次回家的旅程都伴随着忧愁风雨，我喜欢将这个过程理解为，生命不经意的装点。风有质而无形，或飞沙走石，或拈花弄叶；雨有质而无形，或坠散成珠，或凝聚成流。大概都是在世间漂泊的浪子，每一刻都摇曳不定。</p><p>&emsp;&emsp;有人说，放假回家是学生时代做的事情，因为那时我们还没有脱离父母的庇护。可当我工作了以后，当我同他们的距离不再是学校和家的距离，当我同他们打电话不再是因为生活费告拮，我忽然发现我同他们交换了这场漂泊里的角色，从前是我期待着假期，因为我可以见到他们；现在则是他们期待着假期，因为他们可以见到我。我忽然发现我一年中我陪他们的日子屈指可数，从前向往远方觉得在那里能找到我的梦，现在越发地觉得他们一天天老去，想努力长大成熟，让他们能够放心，可更怕因为距离而疏远了他们，古人说『树欲静而风不止，子欲养而亲不待』，这个世界固然不再是古人所认识的世界，这种感情却超越了时间和空间轮回至今。</p><p>&emsp;&emsp;国庆本来打算不回家的，因为即使无人可约无人可陪，我一个人同样可以给自己放假。我从来都是这样，如果有人愿意陪我做一件事情，我会很乐意接纳这番好意，并尝试用最好的状态去让彼此享受这个过程。如果没有人愿意陪伴我做一件事情，我不会勉强更不会因此而沮丧，因为当你习惯了一个人去面对所有事情，你会发现你从来不缺乏做一件事情的动力。可当家里人问我国庆要不要回家的时候，我突然心软得像融化了的雪，我意识到是我心底涌出的一股暖流，快速地打开微信买回家的火车票，结果发现15号的时候票就没有了，妈妈发微信给我说，『如果实在买不到火车票，就买机票回来吧，不用太心疼钱，人回来了就好』。</p><p>&emsp;&emsp;我记得以前他们都不大会用这类IM产品的，但现在他们学会了怎么发消息发朋友圈。记得过年的时候，我教妈妈怎么样发红包，虽然只有三块钱这样来回发着玩，但她玩得比我都开心，或许父母就是这样，曾经青春期叛逆时觉得他们的世界和自己格格不入，等他们老去的时候依然在努力着融入我们的世界。小时候他们紧紧追逐着我们，是怕我们在成长路上摔倒；长大了他们依然紧紧追逐着我们，是怕我们的世界里没有了他们。可他们在一天天地老去，如果有一天他们追不动了，我们是否愿意停下来等等他们呢？窗外的若明若暗的，像极了我往常回家路上数过的每一盏灯，可是我最喜欢的那一盏，是来自那个叫做家的地方，它或许并不璀璨耀眼，但向来不吝于为你释放光和热，永远为你指示着家的方向。</p><p>&emsp;&emsp;早上去北客站取票坐车，就接到朋友从中卫打来的电话，询问我国庆是不是要回家，这种感觉就像家里人一直记挂着你。我经常会想起高中时候，有时同朋友出去玩到很晚回家，常常会到朋友家里借宿，两个人寝则同床食则同桌，到今天我们依然是特别特别好的朋友。我幸运的是一直被朋友这样照顾着，即使我们两个在毕业后天各一方，我这个人不大懂得经营感情，被这样的朋友一直照顾着，我该是有多幸运啊。因为没有买到直达的车票，所以坐动车到兰州去转车，然后遭遇了人生中第一次火车晚点。火车晚点近三个小时，第一次迫切地感觉离家好远好远，每次回家都是披星戴月，或者在夜深人静时，或者在曙光初现时，让家人和朋友等我，我总是过意不去的。大概他们都太了解我，知道我会永远都是这副『长不大』的样子，可我总要长大成熟啊！</p><p>&emsp;&emsp;我记得以前还在父母身边时，我脑子里想的是『父母在，不远游，游必有方』，我一位同学曾问我，何谓有方，当时的我真的是不知道该怎么样回答。后来，一个人去西安发展，终于明白，以前公司里一个女生所说的，在哪里都一样。想到父母孤零零地待在家里，想到每年屈指可数的回家次数，曾几何时，我们想去更广阔的世界寻找诗和远方，可父母逐渐蹒跚的步履注定无法，陪伴我们去那些遥远的地方。诗经里说『青青子衿，悠悠我心，纵我不往，子宁不来』，如果他们不能再紧紧追随我们的步伐，我们为什么不停下甚至转身回去去看望他们呢？以前和我徒弟聊天，她说男生都不大喜欢和家里人联络，我本来就是沉默寡言的性格，从初中时候就不主动和家里人联络，现在我想改变这种想法，因为我想有空就陪陪家里人。</p><p>&emsp;&emsp;我喜欢在漫长的旅途中看书，这种习惯在我有了Kindle以后变得更为明显。早上看到这样一句话，『你懂得越多，就越觉得自己像这个世界里的孤儿』，人生而孤独，父母总有一天会离开我们，但他们教会我们如何去爱这个世界，我希望我可以用他们教会我的，在他们有生之年做些在他们眼里不再『孩子气』的事情，虽然在他们眼里我们永远都是孩子，我觉得真正的成熟并不是变得冷酷麻木，而是你知道这个世界有黑暗的一面，依然愿意相信那些温暖的事情。我到现在依然不喜欢听别人讲“道理”，因为我觉得人生最奇特的地方就在于，即使别人讲得这些“道理”都对，别人依然无法代替你去体验整个生活。每个人都是生活这片大海里的一朵浪花，为了不被岁月冲上荒凉寂寞的沙滩，我们唯有追逐巨浪努力生存。有那么一瞬间，我想和我喜欢的姑娘生活在一个城市里，等有空了就带上她回家陪陪父母。</p><p>&emsp;&emsp;或许有些地方有比故乡更广阔的天空，或许有些地方有比故乡更湿润的土壤，或许有些地方有比故乡更精彩的旅程，我想说的是，不论你是在追求诗和远方，还是在忍受眼前的苟且，如果你觉得累了，请停下忙碌的脚步，找找回家的路，那里永远有人在等你！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;独自一个人在火车上望着窗外出神，而这种情景我再熟悉不过，或许风景会因为季节而不同，或许时间会因为年龄而不同，但对我而言，这个过程熟悉得就像一个我讲了无数遍的故事，从开篇布局到故事脉络都清楚到严丝合缝。印象中是从初中时候就开始寄宿生活，所以这种漂泊的感
      
    
    </summary>
    
      <category term="人生感悟" scheme="http://qinyuanpei.github.io/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="成长" scheme="http://qinyuanpei.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="回家" scheme="http://qinyuanpei.github.io/tags/%E5%9B%9E%E5%AE%B6/"/>
    
      <category term="亲情" scheme="http://qinyuanpei.github.io/tags/%E4%BA%B2%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>秋风劲似去年时</title>
    <link href="http://qinyuanpei.github.io/2017/09/25/autumn-wind-like-one-time.html"/>
    <id>http://qinyuanpei.github.io/2017/09/25/autumn-wind-like-one-time.html</id>
    <published>2017-09-25T00:56:50.000Z</published>
    <updated>2017-12-24T08:21:25.713Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;连续数日的秋雨绵绵，依然固执地不肯转身离开，而之所以选择在国庆节前徘徊，或许是为了让离开家的人，多些同江湖风雨漂泊的味道。印象中这样的日子常常是相似的，譬如穿行在骤雨中被来往车辆溅得一身水，或者行走在上班的路上抬头看见第一场雪，或者是倚靠在公交车窗边上看风景转眼即逝，这些再熟悉不过的场景对我熟悉而又陌生，我惊异于记忆常常像盗梦空间般重叠，我感概于时间常常像钟表指针般流连。我不知道这个世界上是不是有平行世界，但我知道我再回不去曾经某一个时刻，我一直想写下这段时间的状态，可当我准备下笔时才发现，它需要我努力想好多事情，我依然还是曾经的我，风景依稀还是曾经的风景，到底是谁在一直变化呢？</p><p>&emsp;&emsp;我不知道要从什么时候回忆这些事情，这种感觉就像是你期待了许久之后，在触碰到她的那一刻都不复存在了。我曾经答应过一个人要去看望她，如果你读过《一个人的朝圣》这本书，或许就会明白这是一种怎么样的执念，即使在明明知道一切再无法挽回的时候，这种执念还是让我想要达成这个愿望。我一直不知道两个人怎么就自然而然地在一起了，那种感觉如果一定要用语言来形容，我觉得是一种熟悉到灵魂里的默契。你想要牵着她的手的时候，她假装挣扎下后就一直让你牵着，那种娇羞中透着可爱的神情，在四目相对的时候眼睛里都是闪着光的。我忘不了在人潮中牵着她的手穿过整条街市，我忘不了抱着她的时候街市两边灯笼通红。有时候觉得人生充满了遗憾，好像错过她花光了我这辈子的好运气，从那以后我总是重复着昨天的故事。</p><p>&emsp;&emsp;其实我自己都不清楚，我到底喜欢什么样的女孩子，甚至有时候我喜欢的是，我心中她最美好的样子。一个人少不经事的时候，大概会喜欢对女孩子说甜言蜜语，可当他经历过失去以后，他变得不再轻易许诺，这就好像我小时候是一个特别喜欢说话的人，在经历过因为紧张而变得口吃以后，我终于变成了今天这副沉默寡言的样子。有时候会陡然间觉得自己并没有怎么变，或许是因为她说过她喜欢我这个样子，所以我就固执地不肯改变，因为我怕有一天她回来的时候认不出我来，即使这是我脑补的一个剧情。曾经看过一个电影《这个男人来自地球》，当我们熟知的宗教历史变成一个人的回忆，这种超越哲学意义上的时间我认为是荒凉的。曾经的小伙伴Alex、Sandy、Kent、Andy、Kent、Kavin和Joe都渐行渐远，到底是我停留在原地还是我超越了时间？</p><p>&emsp;&emsp;不知道该怎么样描述这种感觉，或许我就是一个不擅长联络感情的人，生命中有太多太多东西，我眼睁睁看它离我远去而又无可奈何，想要安慰我的人总是劝我同昨天告别。但像我这样太看重感情的人，无论外表多么风平浪静，内心永远不肯残忍地删除回忆。所以，我记得Jackson、Lynn、Candy他们陪我度过的二十五岁生日，我记得Candy问我当时暗自许了什么样的愿望，坦白来讲，我没有想着脱单这样离我很遥远的愿望，我只想时间能够永远定格在那一刻，大家都可以开开心心地直到永远。你一定觉得我幼稚或者是不成熟啦，我问过人家要怎么样变得成熟，人家说你去找一个女朋友就好啦，然后就会在喜欢的人面前紧张甚至自卑，我曾一度很讨厌下雨天，因为我怕两个人遇到一起，我既没有伞亦没有外套。</p><p>&emsp;&emsp;二十五岁的我，喜欢一个人还是和从前一样无所顾忌，我还是学不会那些复杂的套路，不喜欢单方面付出，不喜欢卑微地爱一个人，每一次都会因为喜欢某个女孩子而尝试改变，想和她站在一起的时候不会被她的光芒完全覆盖，想和她待在一块的时候不让她觉得我这个人枯燥，想和她抱在一起的时候给她讲我从书里看到的某个故事……我一直在想，如果我们的感情不是以异地恋这种方式会不会有不一样的结局，我喜欢《星月神话》这首歌，是因为我们的确呼吸着同一片天空的气息而注定无法再相遇，就像两条相交的直线一样从陌生到熟悉再到陌生。我现在再看《嫌疑人X的献身》这部电影，我总在想，如果那天我们看的是这部电影会怎么样，此时的我比上大学时候胖了许多，大概一开始我在她心目中的样子，应该是张鲁一这样温润如玉的谦谦君子吧！生命就是这般离奇玄妙，你不能假设更无从假设应该发生什么，因为每一天都是无法重现的Case，你觉得它相似，仅仅是因为相似而已。</p><p>&emsp;&emsp;我喜欢穿裙子的女孩子，这一点完全是因为受到她的影响，虽然她一再告诉我，是我喜欢这样的女孩子，而她恰好喜欢穿裙子而已，可这些淹没在风声里的话语，谁会去盘问孰是孰非呢，如果她此刻愿意同我争论这个问题，我直接认输就好啦，我对输赢看得并不重要，这就像在工作中，没有人在意做的产品是不是好用，大家关注的是始终是它能节省多少个FTE，所以为了达到这些光鲜亮丽的指标，没有人会在意工程师的代码被改成什么样子，我们所追求的东西是否显得舍本逐末，我们所在意的东西到底是否真正发自你我的本心。以前觉得两个人在一起简单，是因为我们没有想那么多；现在觉得两个人在一起困难，是因为我们习惯性想太多。你有没有在脑海中设想过，和一个人走完一生是种什么样的体验，我想说那是一个很美好的想象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;连续数日的秋雨绵绵，依然固执地不肯转身离开，而之所以选择在国庆节前徘徊，或许是为了让离开家的人，多些同江湖风雨漂泊的味道。印象中这样的日子常常是相似的，譬如穿行在骤雨中被来往车辆溅得一身水，或者行走在上班的路上抬头看见第一场雪，或者是倚靠在公交车窗边
      
    
    </summary>
    
      <category term="人生感悟" scheme="http://qinyuanpei.github.io/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="回忆" scheme="http://qinyuanpei.github.io/tags/%E5%9B%9E%E5%BF%86/"/>
    
      <category term="感悟" scheme="http://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="年华" scheme="http://qinyuanpei.github.io/tags/%E5%B9%B4%E5%8D%8E/"/>
    
  </entry>
  
  <entry>
    <title>从React专利事件看开源软件许可</title>
    <link href="http://qinyuanpei.github.io/2017/09/20/talk-about-open-source-software-licensing-via-react-parent-event.html"/>
    <id>http://qinyuanpei.github.io/2017/09/20/talk-about-open-source-software-licensing-via-react-parent-event.html</id>
    <published>2017-09-20T23:06:45.000Z</published>
    <updated>2017-12-24T08:21:25.725Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;各位朋友，我是Payne，大家好，欢迎大家关注我的博客，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。最近前端技术圈因为React专利事件再次被大家关注，印象中Angular和Vue的纷争刚刚过去不久，果然前端技术圈对”造轮子”和”搞事情”有着近乎执著的追求。作为一个在知乎吃瓜的伪前端工程师，我对这凑热闹这种事情从来都是是颇为喜欢的。如果说Angular和Vue冲突主要来自大漠穷秋和尤小尤的个人战场，那么这次React专利事件则是商业公司之间对社区主导力量的一次争夺和抗衡。开源是一种近似乌托邦般的理想社会，它倡导的”人人为我，我为人人”这种近乎大同社会的观念，在面临商业化浪潮洗礼的时候难会和商业利益发生冲突，譬如Google因为使用Java而和甲骨文纠纷不断，最终不得不选择Kotlin作为Android开发的主力语言。所以这篇文章我想和大家通过React专利事件来聊聊开源软件许可，以及我们如何在商业化和开源社区间找到一个平衡点。</p><h1 id="事件始末"><a href="#事件始末" class="headerlink" title="事件始末"></a>事件始末</h1><p>&emsp;&emsp;其实React专利事件由来已久，如果不是在知乎上看到<a href="">“百度要求内部全面停止使用React/React Native”</a>的问题，我是完全没有意识到事态居然发展到如此严重的。每次前端技术圈”搞事情”的时候，基本上都会在我的知乎首页刷屏，可是对我这样的伪前端工程师而言，我仅仅是关注了”Web开发”这个话题而已。忽略知乎首页推荐算法的缺陷，这的确动侧面说明了目前前端领域非常热门的事实，可它不能说明某些前端工程师的技术水平有多高，在引入前后端分离和前端构建工具以后，前端开发的基础设施渐渐地丰富起来了，可是前端开发目前经历着的一切，无一不在后端开发中涉及到，我没有想要成为全栈工程师的野心，在讨论这个事件以前我认为有必要了解下整个事件的始末：</p><ul><li>2016年7月，Facebook在React.js的开源许可协议中添加的附加专利条款首次在社区中引发广泛讨论。</li><li>2016年11月，Facebook发布官方问答，对附加专利条款进行了澄清，强化了其BSD许可证 + 专利许可证的概念。</li><li>2017年4月，Apache Cassandra项目正在考虑是哟过Facebook开源的数据库RocksDB作为存储引擎，可是考虑到专利授权的问题，Jeff Jirsa向Apache法律社区寻求帮助。</li><li>2017年6月，Apache 法律社区开始讨论Facebook Patents License协议专利授权的不对称问题，且该协议与Apache Software License，即Apache 2.0等不兼容。</li><li>2017年7月15日，Apache软件基金会正式发表声明称：Facebook BSD + Patense License正式被列入”Category X”列表，因此Apache项目中将不能含有或者依赖任何该协议的代码，而已发布的代码必须在8月31日前完成替换。</li><li>2007年8月19日，Facebook对Facebook BSD + Patense License有了新的解释，解释指出，专利许可证的存在是为了防御无量的专利诉讼，Facebook增加专利许可证是为了保护核心技术。</li><li>2017年9月16日，百度内部全面禁止使用React/React Native的消息在知乎上引发热烈讨论。</li><li>2017年9月17日，Wordpress官方称因为React专利问题而停止在博客程序Wordpress中使用React技术。</li><li>2017年9月23日，Facebook迫于社区压力对外宣称将在数周后将React授权许可修改为MIT。</li></ul><h1 id="主流软件许可"><a href="#主流软件许可" class="headerlink" title="主流软件许可"></a>主流软件许可</h1><p>&emsp;&emsp;其实作为一名软件工程师，这些和法律息息相关的内容，原本是不需要我们去关注的，因为即使公司在使用这些开源软件中发生法律纠纷，通常都会有法务人员协助公司去解决相关事宜，无论如何都轮不到我们这些人来关心的。不过这个事件的现实意义是，我们在做技术选型时，专利等可能引起法律纠纷的问题，一样是需要纳入考虑范围的。因为如果是个人性质或者纯玩性质的项目，我们的确无需在意太多。而如果你是商业性质项目、或者是公司自营项目，或者是服务于甲方，那么你必须考虑你使用开源软件的方式是否符合相关的软件许可。国内因为盗版软件盛行的原因，大家在心底里好像都不认同软件许可，但是像外企或者是对信息安全比较重视的企业，通常要么对许可证书比较看重，要么对开源软件不太感冒，所以像最近的WePhone创始人自杀这种事件，都在告诉我们一个道理，程序员不要整天都关注技术层面上的东西，虽然技术世界有很多纯粹而美好的事情，但当它和人类联系在一起、和政治联系在一起的时候，它就完全不在我们的控制之中了，所以我觉得我们有必要了解些法律相关的事情，那么从何处开始呢？我们不妨就来说说主流的开源软件许可吧！</p><p>&emsp;&emsp;这个世界上的开源软件许可证书大约有<a href="http://www.gnu.org/licenses/license-list.html" target="_blank" rel="noopener">上百种</a>，我们不可能也没有必要了解所有的开源软件许可证书。对于主流的开源软件许可，我们有GPL、BSD、MIT、MPL、Apache和LGPL，相信大家都没有兴趣去阅读这些晦涩深奥的License，所以我们不打算在这里逐一介绍它们，事实上搞清楚它们在具体限制上的差异是件非常困难的事情。我们希望用最简洁的语言来描述这些开源软件许可：</p><ul><li>GPL： 即GNU通用公共授权(<strong>GNU General Public License</strong>)，其出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但是不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这就是为什么我们能用免费的各种包括商业公司在内的Linux版本，以及Linux上各种各样的由个人、组织和商业软件公司开发的免费软件。</li><li>BSD： 即<strong>Berkly Software Distribution</strong>， 基本上是一个给予使用者极大自由空间的一种开源协议，使用者可以自由地对代码进行使用、修改和二次发布，该协议鼓励代码共享，其出发点是尊重代码作者的著作权，要求保留原代码中的BSD协议，保留创作者署名权利，即不得以开源软件作者/机构的名义进行市场推广。</li><li>MIT： 即<strong>Massachusetts Institute of Technology</strong>，这是一个完全给予使用者自由空间的 简短而宽泛的授权协议，作者唯一的诉求是保留版权，使用者可以复制、修改、合并、发布、分、授权和销售软件副本，并根据程序的需要适度修改授权条款，唯一的要求是必须在发行版里附加原许可协议的声明，无论是以源代码还是二进制形式发布。</li><li>MPL：即<strong>The Mozilla Public License</strong>，该协议同GPL和BSD基本一致，差异主要体现在：源代码提供者不能提供已经受到专利保护的源代码、要求再发布者必须提供对代码程序修改的说明、允许通过MPL许可获得的源代码同其他类型源代码进行混合(第二条献给那些不好好在Git里写注释的同学)。</li><li>Apache：即著名的非盈利开源组织Apache采用的协议，该协议和BSD类似，同样<strong>鼓励代码共享和尊重原作者的著作权，同样允许代码修改，作为开源或商业软件再发布</strong>，主要关注点有：（1）需要给代码的用户一份Apache License；（2）如果改动代码需要在被修改文件中做出说明；（3）衍生代码必须保留原有协议、商标、专利或者说明等；（4）不得对Apache协议进行修改。</li><li>LGPL：LGPL，即GPL V2，是GPL的一个为主要为类库使用设计的开源协议，和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(<strong>link</strong>)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码，可以被商业软件作为类库引用并发布和销售的同时，保障作者的知识产权，避免有人利用源代码复制并开发类似产品。</li></ul><p>&emsp;&emsp;好了，相信到这里大家就能够明白，为什么这次React专利事件能在社区里引起轰动。我认为主要的原因有两点：</p><p>&emsp;&emsp;第一，React在BSD协议许可的基础上增加的专利许可，对许可证书授权方和被授权方而言，存在待遇上的不对等性。实际上在React为前端带来虚拟DOM、单向数据流和不可变对象等一系列函数式编程的概念的同时，Facebook在开源社区中的话语权同样越来越大，Facebook在开源协议中夹藏私货的确让人有种”挟天子以令诸侯”的感觉，曾几何时，社区指责微软没有开放全部的OpenXML标准，因为大家都觉得按照这个标准实现的Office文档和微软家的存在差异，可是面对这种和自家产品紧密联系的项目要开源，我觉得这不单是Facebook会有所提防，恐怕所有的商业公司都会有类似的想法吧，所以在这个事件中，隐含的一个点就是，一旦当使用React的公司和Facebook发生业务上的竞争，React将成为Facebook获得诉讼胜利的一个重要筹码，因为根据React的专利协议，Facebook有权在开展诉讼时从被授权方手中收回React的使用权，所以我们不难理解为什么百度和Wordpress都宣称要停止使用React，除了不想受制于人以外，像百度这种未来可能会和Facebook在AI等领域发生竞争的公司，宁可自己造一套轮子而不愿让自家专利被对方使用的做法，我觉得是可以理解的。</p><p>&emsp;&emsp;第二，React在开源协议中附加专利许可的做法，从商业公司自我保护的角度来看，的确是无可厚非，不过这种做法未免会给开源社区带来不好的风气。我们都知道开源软件并不等同于免费软件，因为开源软件通过许可证书来保证开源软件代码是以一种合理的方式被使用。在很久很久以前，MySQL是我非常喜欢的一个数据库，因为它可以让我摆脱SQLServer臃肿的体积。什么？你说.NET技术体系中怎么会出现MySQL？可这正是.NET选择开源、选择了跨平台，我们才有机会在更广阔的世界里去做些有趣的事情不是吗，我们必须承认开源对这个世界的重要意义，当你发觉你身边的同事都在重复写些垃圾的代码时候，你或许就会意识到，其实在这个世界上有很多东西，我们是可以站在巨人的肩膀上看得更远的。当你因为目光短浅而小心谨慎地维护着那些破旧的代码的时候，我们除了一天天老去别无所获。自从MySQL被甲骨文收购以后，我觉得这个世界开始缺少些有趣的东西，甲骨文和Google关于Java的官司让Google最终选择了Kotlin，所以你可以看到开源这件事情对这个世界是绝对有利的，很多人担心这些代码开源到互联网上对商业公司不利，其实我们都清楚，没有环境和生态的代码基本不会有人关心，我们是不是该重新审视下开源？</p><p>&emsp;&emsp;OK，我知道现在大家都在思考一件事情，既然开源对这个世界的进步是有利的，那么是否开源就不应该成为我们思考的问题，我们真正应该考虑的问题是，如何选择一个合适的开源软件许可证书，在商业化和开源间找到一个平衡点。对于这个问题，我想大家一定会犯选择困难症，不过没有关系啦，我想下面这张图可以帮到大家：</p><p><img src="http://image.beekka.com/blog/201105/free_software_licenses.png" alt="如何选择开源软件许可证书"></p><h1 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h1><p>&emsp;&emsp;或许在数日前，你还在为React专利事件而苦恼，或者考虑在Preact的基础上实现一个新的React，或者考虑转向Angular和Vue这两个框架，此时此刻Facebook宣布将React的开源协议修改为MIT，或许这算是开源社区的一次胜利，或许这算是整个专利事件的尘埃落定，或许有人继续担心Facebook搞其他事情，可是这个世界原本就是在每天都发生变化着的，对于未来我们常常是无从得知它的足迹会在哪里。人生本来就是一个人的逆旅，要想在这充满变化的世界里获得安全感，唯有努力让自己处于不败之地，技术何尝不是这样呢，想想这20年间我们经历了多少技术的变革，从来没有一门框架可以让我们一劳永逸，所以对于小公司而言，大可不必担心Facebook会因为专利问题和你产生法律上的纠纷，该用什么就用什么框架，因为没有绝对完美的框架，能结合业务场景选择合适的框架，为这个世界带来一点点微小的变化，这样子我们就足够开心啦！而对于BAT这样的互联网大厂，则应该考虑走自主研发的差异化路线，因为如果你不想受制于人，最好的方法就是让别人依赖你，而不是去努力依赖别人。作为一个伪前端工程师，我觉得不管什么时候，我们都要努力打好基础，而不是在一堆框架中疲于奔命，对热衷于搞事情和造轮子的前端技术圈来说，下一次的讨论热点会是什么，你我都未必能想到，这个时候还有什么比努力更重要的事情呢。好了，这篇文章就是这样了，希望大家能够喜欢，我们下一篇见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;各位朋友，我是Payne，大家好，欢迎大家关注我的博客，我的博客地址是&lt;a href=&quot;https://qinyuanpei.github.io&quot;&gt;https://qinyuanpei.github.io&lt;/a&gt;。最近前端技术圈因为React专利事件
      
    
    </summary>
    
      <category term="人生感悟" scheme="http://qinyuanpei.github.io/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="前端" scheme="http://qinyuanpei.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://qinyuanpei.github.io/tags/React/"/>
    
      <category term="开源" scheme="http://qinyuanpei.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存技术学习系列之Lua脚本</title>
    <link href="http://qinyuanpei.github.io/2017/09/17/redis-cache-technology-learning-series-04.html"/>
    <id>http://qinyuanpei.github.io/2017/09/17/redis-cache-technology-learning-series-04.html</id>
    <published>2017-09-17T10:49:07.000Z</published>
    <updated>2017-12-24T08:21:25.721Z</updated>
    
    <content type="html"><![CDATA[<p>  各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。想起来大概有一个月没有更新博客啦。或许是因为这中间发生了太多的事情，想来人生原本就充满曲折和变数。在微信群里得知家中舅爷去世的消息，突然意识到时间早已摧毁你我的一切。那个曾经同你有千丝万缕联系的人，会在某一刻同你彻底失去联系。所以我更珍视彼此在一起的时光，因为在这个世界上每天都面临着改变。有时候工作上遇到不开心的时候，会想着一个人去一个陌生的地方，我们就在不断地相聚和离别中慢慢老去。这段时间一直在学习做饭，为此特意买了本菜谱，结果发现，最难的并不是如何去做好一道菜，而是你为了做好一道菜需要准备各种食材，就像人与人交流并没有什么困难，真正困难的地方，是你找不到一个可以一直陪你说话的人。熟悉的店面会被拆迁转让，熟悉的人事会被错过改变，上帝想把世界煮成一锅粥，可味道的调配却由我们来掌控。</p><p>  好了，所谓“如人饮水，冷暖自知”，人生奇就奇在你没有办法用三言两语去描述它。这段时间面试过两三家公司，整体上感觉自己的生活太安逸了些，虽然我现在依然住在租来的房子里，转眼间2017年接近尾声啦，可是回想起来今年年初制定的计划，在广泛阅读和提升技术上都是不及格的状态，印象中打算研究Redis和MonogoDB这两种数据库的(因为没有购买为知笔记会员导致部分笔记损坏或者丢失)，然而到现在为止我还有研究完Redis。尤其当我面试的时候，我发现好多我写在简历上的内容，都会成为某种意义上的呈堂证供，这让我更加确信好多东西需要不断地去巩固，所以尝试在实际项目上使用Moq、考虑怎么写出更好的测试方法以及时刻保持自我的不可替代性，这些都是我最近在考虑的事情，有时候发脾气是因为觉得自己在浪费生命，可越是被这种无力感笼罩的时候，就越是要对自己狠一点儿，所以在这篇博客中，让我们重新拾起对Redis的学习兴趣，今天我们来说说Redis中的Lua脚本。</p><p>  熟悉我博客的朋友一定都知道，我曾经开发过Unity3D相关的项目，而Lua脚本正是Unity3D中主流的热更新方案。关于Lua脚本相关的文章，大家可以通过下面的链接来了解，在这里我们不再讲述Lua的基础内容，本篇文章所讲述的是如何通过Redis内置的Lua解释器来执行脚本，我们为什么使用脚本语言进行开发呢，因为这样可以降低开发的难度啊。</p><ul><li><a href="https://qinyuanpei.github.io/2015/02/03/programing-with-the-lua-base.html">脚本语言编程：Lua脚本编程入门</a></li><li><a href="https://qinyuanpei.github.io:4000/2015/04/16/building-lua5-3-with-visual-studio-2012-in-windows.html">在Windows下使用Visual Studio编译Lua5.3</a></li><li><a href="http://blog.csdn.net/qinyuanpei/article/details/39826323" target="_blank" rel="noopener">Unity3D游戏开发之Lua与游戏的不解之缘(上)</a></li><li><a href="http://blog.csdn.net/qinyuanpei/article/details/39910099" target="_blank" rel="noopener">Unity3D游戏开发之Lua与游戏的不解之缘(中)</a></li><li><a href="http://blog.csdn.net/qinyuanpei/article/details/40050225" target="_blank" rel="noopener">Unity3D游戏开发之Lua与游戏的不解之缘(下)</a></li><li><a href="http://blog.csdn.net/qinyuanpei/article/details/40213439" target="_blank" rel="noopener">Unity3D游戏开发之Lua与游戏的不解之缘终结篇：UniLua热更新完全解读</a></li></ul><p>  好了，既然我们已然了解到Redis是通过内置的Lua解释器来执行脚本，所以Redis中的Lua脚本其实可以理解为Lua语法 + Redis API。为了写作这篇文章，我不得不将我的操作系统切换到Linux，因为这样我可以随时在写作过程中使用终端，我写作的一个重要特点，就是所有的内容都尽量保证有测试覆盖，我知道有许多人都不喜欢写测试，测试虽然不能保证你没有BUG，可是有了BUG以后可以直接在测试中定位问题，这就是我们为什么要重视测试的原因所在。在Redis中我们有两类命令用以处理和脚本相关的事情：</p><h1 id="Eval系列"><a href="#Eval系列" class="headerlink" title="Eval系列"></a>Eval系列</h1><p>  熟悉JavsScript的朋友应该会更熟悉这个方法，因为Eval在JavaScript是个神奇的存在，它可以执行任何合法的JavaScript代码，我和我的同事就曾经在一个项目中写过两层嵌套的Eval方法，显然这是为了实现某种奇怪的需求。那么在Redis中有EVAL和EVALSHA两个命令可以使用，这两个命令是从Redis2.6.0版本开始的，通过内置的Lua解释器来实现对脚本求值。EVAL命令的基本格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure><p>  我们可以注意到在这里EVAL命令由三部分组成，即第一个部分，表示一段Lua脚本程序，并且这段脚本不需要更不应该定义函数；第二部分，表示参数列表，指在脚本中需要用到的键，因为Redis是一个键值数据库，这些键名可以通过全局变量KEYS来访问，默认索引将从1开始，事实上我们更推荐你使用这种方式来访问键名；第三部分，表示除建键名参数以外的附加参数，和第二部分类似，这里我们可以通过全局变量ARGV来访问，这里就不再赘述啦。我们一起来看下面的例子：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL <span class="string">"return &#123;KEYS[1],KEYS[2]&#125;"</span> <span class="number">2</span> <span class="keyword">ab</span> <span class="keyword">cd</span></span><br></pre></td></tr></table></figure><p>  此时我们会返回一个由KEYS[1]和KEYS[2]组成的集合，集合中的两个元素分别是ab、cd，注意到这里有一个参数2,它表示我们这里将有两个参数，事实上Redis将从这个位置开始解析参数，所以我们必须告诉Redis参数解析到什么位置结束，因为主要参数(KEYS)和附加参数(ARGV)是从解析的角度上是无法区分的，所以我们期望的结果会是：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"ab"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"cd"</span></span><br></pre></td></tr></table></figure><p>  现在我们来增加点难度，显然你明白我在说什么，请注意我要引入附加参数(ARGV)啦！</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL  <span class="string">"return &#123;KEYS[1]..ARGV[2] ,KEYS[2]..ARGV[1] &#125;"</span> <span class="number">2</span> <span class="keyword">ab</span> <span class="keyword">cd</span> <span class="keyword">ab</span> <span class="keyword">cd</span></span><br></pre></td></tr></table></figure><p>  这里我们尝试对KEYS和ARGV进行拼接，需要说明的是Lua中连接字符串使用的是. .，所以这里将得到结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"abcd"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"cdab"</span></span><br></pre></td></tr></table></figure><p>  好了，现在大家应该理解EVAL这个命令的使用方法啦，那么对EVALSHA命令来说，顾名思义，它就是使用了SHA1验证的EVAL方法，我们注意到现在脚本都是定义在EVAL命令的第一个参数上，假如我们需要复用一个脚本，而该脚本可以为我们提供Sum这样的功能，即它可以返回一组参数的和给我们，显然参数的个数是不同的，那么这个时候我们总不能每次都重复写这个脚本吧，所以Redis会为脚本创建一个指纹，我们使用EVALSHA命令来传入一个指纹，Redis将从缓存的脚本中找到这个脚本，并结合我们的参数来调用它，这样我们就可以获得脚本执行以后的结果，关于指纹的这种说法，大家可以结合Git提交代码时的感受进行理解，除此以外，它和EVAL在使用方法上是完全一致的，所以不再举例子说明啦。</p><h1 id="Script系列"><a href="#Script系列" class="headerlink" title="Script系列"></a>Script系列</h1><p>  好了，下面我们来介绍第二类和Lua脚本相关的API，相比Eval给人云里雾里的感觉，Script系列的命令处处洋溢着规范命名的美好气息，我们通过这些命令的名字基本上就可以知道它是做什么事情的，这告诉我们平时写代码的时候如何去写出优雅的代码。我们通过下面一组命令来了解Script系列命令的具体用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 载入一个脚本到缓存中 */</span><br><span class="line">SCRIPT LOAD "return 'Hello Redis'" </span><br><span class="line">/* Redis返回该脚本的指纹信息 */</span><br><span class="line">"e509eb0869056563287758d23146eb00e0518da5"</span><br><span class="line">/* 查询脚本是否存在于缓存中 */</span><br><span class="line">SCRIPT EXISTS "e509eb0869056563287758d23146eb00e0518da5"</span><br><span class="line">/* Redis返回1表示脚本存在，反之不存在 */</span><br><span class="line">1) (integer) 1</span><br><span class="line">/* 从缓存中清空所有脚本 */</span><br><span class="line">SCRIPT FLUSH</span><br><span class="line">OK</span><br><span class="line">/* 此时脚本在缓存中是不存在的 */</span><br><span class="line">SCRIPT EXISTS "e509eb0869056563287758d23146eb00e0518da5"</span><br><span class="line">1) (integer) 0</span><br></pre></td></tr></table></figure><p>  至此，我们了解到了Redis中对Lua脚本支持的主要特性，坦白地讲，我认为Lua脚本在这里的应用极其薄弱，完全达不到我们印象中Lua脚本的强大，甚至我对Redis中的KEYS和ARGV依然有些模糊，大概越想搞明白的事情有时候就越搞不清楚。这里我没有提到的一个SCRIPT系列的命令是SCRIPT KILL，这个命令的作用是杀死当前正在运行的脚本，并且当且仅当这个脚本没有执行过任何写操作时，这个命令才会生效，所以这个命令主要用于杀死长时间运行的脚本，执行完这个命令后，执行这个脚本的客户端将从阻塞的EVAL命令中退出，并收一个错误作为返回值，所以我们可以理解为这是一个强行终止脚本执行的方法，因为我这里这个脚本非常的简单，所以它执行起来非常快，而我没有这样一个足够长的脚本去验证这个命令，所以在上面的脚本示例中我没有去验证这个命令，对此感兴趣的朋友可以自行去研究啦。</p><h1 id="Lua脚本应用"><a href="#Lua脚本应用" class="headerlink" title="Lua脚本应用"></a>Lua脚本应用</h1><p>  通过本文前面两个部分，我们基本了解了Redis中Lua脚本是如何工作的，在演示示例脚本的时候，我是直接在终端下运行redis-server和redis-cli的，并且所有的命令都是在终端下手动键入的，难道在实际的使用中我们要这样子玩Redis吗？想起来都觉得好可怕是不是？所以我们下面来通过一个具体的案例，来演示Redis怎么去和一个Lua脚本脚本进行交：</p><p>  首先，我们来定义一个简单的Lua脚本文件<strong>script01.lua</strong>，该脚本将对集合中的元素进行求和：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> length = redis.call(<span class="string">"LLEN"</span>,key)</span><br><span class="line"><span class="keyword">local</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (index &lt; length)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  sum = sum + redis.call(<span class="string">"LINDEX"</span>,key,index)</span><br><span class="line">  index = index + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>  现在我们在终端中执行这个脚本，为了方便起见，我们这里将其放在redis-3.2.8目录下的scripts目录。我们首先在Redis中准备些数据来做好准备，在终端中执行命令：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LPUSH data <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line">src/redis-cli --eval ~/文档/redis<span class="number">-3.2</span><span class="number">.8</span>/scripts/script01.lua data</span><br><span class="line">(<span class="type">integer</span>) <span class="number">30</span></span><br></pre></td></tr></table></figure><p>  好了，我们下面来解释下这段脚本，我们向Redis中键名为<strong>data</strong>的集合中添加了5个元素，注意这句脚本是在执行<strong>src/redis-cli</strong>后执行的，这部分内容我们在前面讲解Redis中的数据结构的时候提到过，博主表示在写这篇文章的时候依然要去看文档，总之现在我们有一个集合，并且这个集合中有5个元素，与此同时呢，我们编写了一个Lua脚本文件<strong>script01.lua</strong>，这个脚本的作用是对集合中的元素进行求和。在这里我们注意到，我们可以通过redis.call()这个方法来调用redis中的命令，具体到这里我们使用LLEN命令获取了集合的长度，使用LINDEX命令获取了集合中的元素。我们在前面提到两个全局变量KEYS和ARGV，可以完全当作Lua脚本中的两个变量来处理，从编程角度来讲，我们可以将其直接在脚本中写死。可是考虑到Redis是一个键值数据库，所以我们很容易想到键名应该对外暴露出来，以满足复用Lua脚本的目的。这里我们直接用redis-cli来运行EVAL命令，所以我们注意到它的传参方式有点不一样，事实上KEYS和ARGV中间使用逗号隔开即可。</p><p>  所以我们可以想到一种Lua脚本自动管理的思路，即通过命令行读取指定目录下的Lua脚本文件，通过SCRIPT LOAD方法获得其在Redis中的SHA1指纹，然后我们将脚本名称或者ID和这个指纹关联起来并将其存储在Redis中，此时我们只需要传入脚本名称和参数即可返回脚本执行后的结果，这样是不是感觉非常优雅呢？虽然Redis是一个键值性数据库，它不具备传统关系型数据库的查询能力，但是现在我们有了Lua脚本以后一样可以通过脚本来定制出查询，而到此时此刻我或许才真正明白Redis中Lua脚本是一种怎样神奇的存在。我们心怀敬畏，同时对这个世界永远充满期待，因为我们从来不知道人类潜能开发的极限在哪里。我们创造了太多不可思议的事情，有时候甚至连我们自己都怀疑，为什么我们会走到今天这一步。在脚本语言里我最喜欢的编程语言是Lua和Python，如果说我喜欢Lua源于我对游戏开发的兴趣，喜欢Python源于我对编写网页爬虫的兴趣，那么我很庆幸今天我又多了一个使用Lua的原因。世上美好的事情莫过于，你喜欢一样东西，恰好有人和你一样喜欢，可惜那是很久以前的事情啦。</p><p>  我们现在可以了解到，Redis提供了一种机制可以让Lua脚本同Redis进行交互。可是事实上Redis和Lua在数据结构定义上存在一定差异。所以，下面我们来了解下这两种数据结构是如何进行转换的，了解完这些我认为这篇文章就可以结束啦，因为现在接近1点钟啦而明天还要上班。在Lua脚本中调用call()或者pcall()方法来执行Redis命令时，Redis命令执行的结构会被转换为Lua中的数据结构。同理，当Lua脚本在终端中执行时，Lua脚本的返回值会被转化为Redis的协议并经由EVAL返回给客户端。关于call()和pcall()这两个方法，一个显著的区别是前者在出错时返回的是错误信息，而后者返回的是经由Lua table包装后的结果。我们知道table在Lua语言中是一个非常强大的数据结构，显然后者对调用者更为友好些啦。通常在处理类型转换时我们有以下原则：</p><ul><li>Lua table结构中不能含有nil，否则Redis将从第一个为nil的位置返回</li><li>Lua number结构中不能区分浮点类型，默认会转换为整型并舍弃小数部分，如果需要保留小数部分请返回string类型</li><li>Lua boolean结构在Redis中会被转换为0和1的取值</li><li>Redis提供了redis.error_reply()和redis.error_status()两个辅助方法来完成Lua-&gt;Redis的转换</li></ul><p>  好了，这篇博客就是这样子啦，关于为什么使用Lua脚本这个问题，我认为可以从减少网络开销、原子性和脚本复用三个角度来考虑，尤其是第二点，因为Redis执行脚本的时候是整体的、阻塞的执行，中间不会被插入新的命令，因此它完全可以不用担心出现竞态或者事务相关的问题，可是即使这样我们还是建议编写短小精悍的Lua脚本。以上就是这篇博客的全部内容啦，感谢大家关注，欢迎在博客留言及讨论相关技术问题，谢谢大家。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://segmentfault.com/a/1190000007892988" target="_blank" rel="noopener">Xbynet - Redis与Lua及Redis-py应用Lua</a></li><li><a href="http://www.cnblogs.com/yourarebest/p/5987438.html" target="_blank" rel="noopener">一路向前走 - 【原】Redis基本操作</a></li><li><a href="http://www.cnblogs.com/dgcx/p/4967175.html" target="_blank" rel="noopener">小咚 - Redis Lua 总结</a></li><li><a href="http://www.redis.net.cn/tutorial/3516.html" target="_blank" rel="noopener">Redis中文网 - Redis 脚本</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是&lt;a href=&quot;https://qinyuanpei.github.io&quot;&gt;https://qinyuanpei.github.io&lt;/a&gt;。想起来大概有一个月没有更新博客啦。或许是因为这中间发生了
      
    
    </summary>
    
      <category term="数据存储" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="数据库" scheme="http://qinyuanpei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="缓存" scheme="http://qinyuanpei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>基于特性(Attribute)的实体属性验证方案设计</title>
    <link href="http://qinyuanpei.github.io/2017/08/21/validate-properties-of-entity-via-attribute-in-csahrp.html"/>
    <id>http://qinyuanpei.github.io/2017/08/21/validate-properties-of-entity-via-attribute-in-csahrp.html</id>
    <published>2017-08-21T14:25:41.000Z</published>
    <updated>2017-12-24T08:21:25.725Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;各位朋友，我是Payne，大家好，欢迎大家关注我的博客，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。在这篇文章中，我想和大家探讨下数据校验的相关问题，为什么我会对这个问题感兴趣呢？这其实是来自最近工作中相关需求场景，而这篇文章其实是我在去年就准备要写的一篇文章，这篇文章一直存放在草稿箱里没有发布出来，所以结合这段时间项目上的思考，对当初的设计方案进行了改进，所有就有了大家现在看到的这篇文章，我始终认为思考是一个持久的过程，就像我们对这个世界的理解，是会随着阅历的变化而变化的。我们知道现实通常都会很残酷，不会给我们太充裕的时间去重构。可是思考会是人生永远的功课，当你忙碌到无暇顾影自怜的时候，不妨尝试慢下来抬头看看前方的路，或许原本就是我们选择了错误的方向呢，因为有时候作出一个正确的选择，实在是要比埋头苦干要重要得多啊。</p><p>&emsp;&emsp;好啦，既然我们提到了思考，那么我们来一起看一个实际项目中的业务场景，在某自动化项目中，用户会将大量数据以某种方式组织起来，然后藉由自动化工具将这些数据批量上传到一个系统中，该系统实际上是一个由各种表单组成的Web页面，并且这些Web表单中的控件都有着严格的验证规则，当数据无法满足这些验证规则时将无法上传，因此为了提高自动化工具上传的成功率，我们必须保证用户组织的这些数据是合法的，假设我们的用户是一个仅仅会使用Office三件套的普通人，他们可以想到的最好的方式是将这些数据录入到Excel中，而Excel中的数据有效性验证依附在单元格上，一旦验证规则发生变化，我们就不得不去维护这个Excel文件，这绝对不是一个软件工程师该做的事情好吗？我们当然是需要在提交数据前做验证啦，然而我看到Excel中100多列的字段时，我瞬间就不淡定了，这么多的字段难道我们要逐个写if-else吗？不，作为一个提倡少写if-else的程序员，我怎么可能会去做这种无聊的事情呢？下面隆重推出本文的主角——Attribute。</p><h1 id="你的名字是？"><a href="#你的名字是？" class="headerlink" title="你的名字是？"></a>你的名字是？</h1><p>&emsp;&emsp;如你所见，本文的主角是Attribute，那么当它出现在你面前的时候，你是否会像《你的名字。》里的泷和三叶一样，互相问候对方一句：你的名字是？因为我们实在不知道应该叫它特性还是属性。可事实上这篇文章的标题暴露了这个问题的答案，这里我们应该叫它特性。好了，按照数学理论中的观点，任何问题都可以通过引入一个中间层来解决，现在我们有了一个新的问题，Attribute和Property到底有什么区别？虽然这两者都可以翻译为”属性”，可实际上它们表达的是两个不同层面上的概念，一般我们倾向于将Attribute理解为编程语言文法上的概念，而将Property理解为面向对象编程里的概念。</p><h2 id="Attribute-特性"><a href="#Attribute-特性" class="headerlink" title="Attribute/特性"></a>Attribute/特性</h2><p>&emsp;&emsp;我们将Attribute称为特性，那么我们在什么地方会用到特性呢？两个个非常典型的例子是超文本标记语言(HTML)和可扩展标记语言(XML)。首先这两种标记语言都是结构化、描述性的标记语言。结构化表现在节点间可通过父子或者兄弟的关系来表示结构，描述性表现在每个节点都可以附加不同的描述来丰富节点。例如下面的XML文件中，我们使用了描述性的特性来提高元素间的辨识度，即特性为元素定义了更多的额外信息，而这些额外信息并不作为元素数据结构的一部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"COOKING"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"CHILDREN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个例子中，bookstore节点由两个book节点组成，而每个book节点则由title、author、year和price四个节点组成，显然这些节点描述的是一种结构化的数据，而这些数据同时附加了相关描述性的信息，例如book节点有category信息，title节点有lang信息。在XML中最基本的一个内容单元我们称之为元素，即Element，而描述这些元素的最基本内容单元我们称之为特性。所以，这种在语言层面上进行描述而与实际抽象出的对象无关的概念就称为”特性”，人们认知和描述一个事物的方式会有所不同，所以在XML中会有这样一个历史遗留问题，我们应该使用Element还是Attribute，而产生这个问题的根源在于我们认识这个世界，是通过语言描述还是通过概念抽象。</p><p>&emsp;&emsp;如果我们了解GUI相关技术的演进过程，就会发现历史总是如此的相似。为什么微软会在XML的基础上扩展出XAML这种专门为WPF而设计的界面设计语言呢？因为历史告诉我们GUI中的大量特性都应该使用声明式的、描述式的语法来实现，从苹果的Cocoa、微软的XAML、Qt的QML、Android的XML等无一不证明了这个观点，而采用过程式的MFC、WinForm、Swing等，我们常常需要为它们编写大量的交互性的逻辑代码，今天我们会发现前端领域的声明式编程、MVVM、组件化等技术点，其实都是这种思想的无限延伸，我们可以使用jQuery去直接操作DOM，但面向过程的命令式代码一定不如声明式容易理解。虽然在面向对象编程的世界里，我们最终还是需要将这些描述性的语法结构，转化为面向对象里的类和属性，可这已然是一种进步了不是吗？</p><h2 id="Property-属性"><a href="#Property-属性" class="headerlink" title="Property/属性"></a>Property/属性</h2><p>&emsp;&emsp;我们认识这个世界的过程，恰恰折射出这两者截然不同的风格，从孩提时代理解的“天空是蓝色的”到学生时代认识到“大气是由氮气、氧气和稀有气体组成”，这种转变从本质上来看其实是因为我们认识世界的角度发生了变化。《西游降魔篇》里玄奘寻找五行山，第一次是风尘仆仆“看山是山”，第二次是由“镜花水月”启发“看山不是山”，第三次借“儿歌三百首”降伏孙悟空后“看山还是山”。面向对象编程(OOP)的一个重要思想是抽象，而抽象即是我们从描述性的语言中对事物属性进行构建的一个过程。例如现实生活中的汽车会有各种各样的数据信息：长度、宽度、高度、重量、速度等等，而与此同时汽车会有启动、刹车、减速、加速等等的行为，所以将事物的“数据”和“行为”提取出来进行抽象和模拟的过程，就是面向对象编程，我们在这个过程中可以注意到一点，所有的这一切都是针对对象而言的，所以Property是针对对象而言的。</p><p>&emsp;&emsp;这里提到的一个重要概念是抽象，什么是抽象呢？我认为它恰好和具体相对的一个概念。所谓具体，即相由心生，你看到什么就是什么，与此同时通过一组描述性的语言将其描述出来，我以为这就是具体。例如”火辣辣的太阳挂在天上”，这是具体到太阳颜色和温度的一种描述；所谓抽象，即返璞归真，我们看到的并非世间阴晴圆缺的月亮，而是这浩瀚宇宙中国一颗遥远的行星，此时此刻我们将行星具备的特点概括出来，推而光之，我以为这就是抽象，所以对我们而言，属性是事物抽象后普遍具有的一种特征，它首先要达到一种抽象的层次，其次它要能表现出事物的特性，我更喜欢将Property称之为属性，它和我们在面向对象编程中的概念是完全统一的。</p><h1 id="方案设计及其实现"><a href="#方案设计及其实现" class="headerlink" title="方案设计及其实现"></a>方案设计及其实现</h1><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ul><li>免除配置开箱即用：无需任何配置文件，直接在实体上添加Attribute即可实现验证</li><li>非侵入式验证设计：验证与否对实体结构无任何副作用，可以随时添加验证或卸载验证</li><li>扩展灵活高度复用：可以自由派生自定义特性，通过泛型来支持不同实体类型的验证</li></ul><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>&emsp;&emsp;所有校验相关的Attribute都派生自ValidationAttribute这个父类，其核心方法是Validate()方法，该方法被声明为一个虚方法，因此所有的子类都必须对这个方法进行重写，它将返回一个叫做ValidationResult的结构，这是一个非常简单的数据结构，它仅仅包含Success和Message两个属性，前者表示当前校验是否成功，后者表示验证失败时的错误信息。显然，一个实体结构中将包含若干个不同的属性，所以在对一个实体结构进行验证的时候，会通过反射遍历每一个属性上的ValidationAttribute并调用其Validate()方法，所以最终返回给调用者的应该是由一组ValidationResult组成的集合，为此我们设计了ValidationResultCollection这个类，该类实现了ICollection接口，在此基础上我们增加了一个Success属性，当集合中所有ValidationResult的Success属性为true时，该属性为true反之为false。我们将数据校验的入口类EntityValidation设计成了一个静态类，它提供了一个泛型方法Validate<t>()方法，所以对整体设计而言，它的灵活性和扩展性主要体现在：(1)通过派生自定义特性来增加验证规则；(2)通过泛型方法来支持不同类型的校验。下面给出UML类图供大家参考，最近刚刚开始学习UML，有不足之处请大家轻喷哈：</t></p><p><img src="http://img.blog.csdn.net/20170927223615167" alt="UML类图"></p><h2 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h2><p>&emsp;&emsp;首先，在.NET中特性的基类是Attribute，Attribute从表现形式上来讲类似Java中的注解，可以像标签一样添加在类、属性、字段和方法上，并在运行时期间产生各种不同的效果。例如[Serializable]标签表示一个实体类可以序列化，[NonSerializable]标签则可以指定某些属性或者字段在序列化的时候被忽略。而从本质上来讲，Attribute是一个类，通常我们会将派生类以Attribute结尾，而在具体使用的时候可以省略Attribute，所以[Serializable]标签其实是对应.NET中定义的SerializableAttribute这个类。在我们定义Attribute的时候，一个需要考虑的问题是Attribute的作用范围，在.NET中定义了AttributeUsageAttribute这个类，它可以是Class、Property、Field、Method等，所以Attribute本质上是在运行时期间为元素提供附加信息的一种机制，即Attribute可以添加元数据。我们知道元数据是(MetaData)实际上是程序集(Assembly)中的一部分，显然这一切都是在编译时期间定义好的，所以Attribute的一个重要特征是在运行时期间只读(Readonly)。Attribute必须依附在指定目标上，当当前目标与AttributeUsage定义不符时，将无法通过编译。Attribute的实例化依赖于目标实例的实例化，无法直接通过new完成实例化。通常我们需要配合反射来使用Attribute，在运行时期间做些有意义的事情，例如ORM中实体字段与数据库字段的绑定、Unity中配合AOP使用的ExceptionHnadler等等，都是非常典型的Attribute的应用。</p><p>&emsp;&emsp;了解了Attribute是什么东西，接下来我们要考虑的就是如何访问Attribute，在.NET中主要有两种方式来获取Attribute，即通过Attribute类提供的静态方法获取Attribute和通过Attribute依附的对象实例的元数据来获取Attribute。下面我们来看一段简单的代码实例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static T GetAttribute&lt;T&gt;(<span class="keyword">this</span> PropertyInfo propertyInfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> attrs = propertyInfo.GetCustomAttributes(typeof(T), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span>(attrs == <span class="literal">null</span> || attrs.Length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> atts[<span class="number">0</span>] <span class="keyword">as</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这段代码展示了如何通过反射访问附加在属性上的Attribute，事实上除了PropertyInfo以外，它还可以从任何支持附加Attribute的元素，例如MethodInfo、FieldInfo、ConstructorInfo等。Attribute类提供了类似的静态方法，第一个参数可以是这些元素中的任何一个，第二个参数和第三个参数和这里的示例代码一致，分别是返回的Attribute的类型，以及是否要搜索父类的Attribute，它的返回值类型为Attribute[]。在这个方案中，我们通过下面的方式来对实体属性进行验证：<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static ValidationResultCollection Validate&lt;T&gt;(T entity)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> type = entity.GetType();</span><br><span class="line">  <span class="keyword">var</span> properties = type.GetProperties();</span><br><span class="line">  <span class="keyword">var</span> results = <span class="keyword">new</span> ValidationResultsCollection();</span><br><span class="line">  foreach(<span class="keyword">var</span> <span class="keyword">property</span><span class="string"> in properties)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> propertyValue = <span class="keyword">property</span><span class="string">.GetValue(entity</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">var</span> validationAttributes = <span class="keyword">property</span><span class="string">.GetCustomAttributes(typeof(ValudationAttribute)</span>,fasle);</span><br><span class="line">    <span class="keyword">if</span>(propertyValue == <span class="literal">null</span> &amp;&amp; (validationAttributes == <span class="literal">null</span> || valudationAttributs.Length &lt;= <span class="number">0</span>)) <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//优先验证RequiredAttribute</span></span><br><span class="line">    <span class="keyword">var</span> requiredAttributes = <span class="keyword">property</span><span class="string">.GetCustomAttributes(typeof(RequiredAttribute)</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(requiredAttributes.Length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> requiredResult = (requiredAttributes[<span class="number">0</span>] <span class="keyword">as</span> ValidationAttribute).Validate(propertyValue);</span><br><span class="line">      results.Add(requiredResult);</span><br><span class="line">      <span class="keyword">if</span>(propertyValue == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其次验证ValidationAttribute</span></span><br><span class="line">    foreach(<span class="keyword">var</span> validationAttribute <span class="keyword">in</span> validationAttributes)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(propertyValue != <span class="literal">null</span> &amp;&amp; !validationAttribute.GetType().Equals(<span class="keyword">typeof</span>(RequiredAttribute)))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> validationResult = (validateAttribute <span class="keyword">as</span> ValidationAttribute).Validate(propertyValue);</span><br><span class="line">        results.Add(validationResult);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在这里我们注意到在对ValidationAttribute进行处理的时候，优先验证了RequiredAttribute，因为如果它验证失败意味着下面的验证都不需要了，所以当一个Property上附加了RequiredAttribute并且它的值为null的时候，我们将不会进行下面的验证，这是在设计过程中发现ValidationAttribute的优先级不同而做出的一个简单地调整。关于ValidationAttribute，我们提到这是所有自定义特性的基类，实际在使用中我们会有各种各样的派生类，我们这里以RegexAttribute为例来看看它具体怎么实现：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> RegexAttribute : ValidationAttribute</span><br><span class="line">&#123;</span><br><span class="line">  private string regexText;</span><br><span class="line">  private string defaultMessage = "value is required to match a Regex rule &#123;<span class="variable">$regex&#125;</span>;</span><br><span class="line">  </span><br><span class="line">  public RegexAttribute(string regexText,string message = null)</span><br><span class="line">  &#123;</span><br><span class="line">    this.regexText = regexText;</span><br><span class="line">    this.message = message == null ? defaultMessage : message;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public VelidationResult Validate(object value)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">var</span> regex = new Regex(regexText);</span><br><span class="line">  <span class="keyword">var</span> match = regex.<span class="built_in">match</span>(value.<span class="keyword">ToString</span>());</span><br><span class="line">  <span class="keyword">var</span> success = match.Success;</span><br><span class="line">  <span class="keyword">if</span>(!success)</span><br><span class="line">  &#123;</span><br><span class="line">      message = message.<span class="keyword">Replace</span>(<span class="string">"&#123;$regex&#125;"</span>,regexText);</span><br><span class="line">      <span class="keyword">return</span> new ValidationResult()&#123;Success = success, Message = message&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> new ValidationResult()&#123;Success = success&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;好了，以上就是整个校验设计中关键的技术点啦，我认为整体上没有多少难点，因为这是我在项目上造的一个简单的轮子，相比ASP.NET  MVC 中的校验要简单很多，相信大家可以根据这些内容轻松地实现一个自己的版本，虽然不主张”重复造轮子”，可博主在很多时候都是通过”造轮子”来学习的啊，哈哈。</p><h1 id="数据校验示例"><a href="#数据校验示例" class="headerlink" title="数据校验示例"></a>数据校验示例</h1><p>&emsp;&emsp;下面我们来通过一个简单的示例来了解，如何在实际项目中使用这个验证方案：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">  [<span class="meta">Required</span>]</span><br><span class="line">  [<span class="meta">Regex(<span class="meta-string">"(\d+)&#123;3&#125;-(\d+)&#123;1&#125;-(\d+)&#123;6&#125;"</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> CardNumber &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">  </span><br><span class="line">  [<span class="meta">Required</span>]</span><br><span class="line">  [<span class="meta">MaxLength(20,<span class="meta-string">"AccountNumber is required within 20 characters"</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> AccountNumber &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">  </span><br><span class="line">  [<span class="meta">Values(<span class="meta-string">"FCY,DCP,ATM"</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> TransactionType&#123;<span class="keyword">get</span>；<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里使用了三种验证规则，Required表示该字段不可以为空，Regex表示字段值要匹配指定的正则表达式，MaxLength表示字段长度不能超过指定长度，Values表示字段允许的取值范围，在实际使用中我们可以通过派生定义更多的验证规则，每一种验证规则都可以设置一个验证失败的信息，例如当AccountNumber的长度超过20时，将会返回指定的错误信息。我们可以通过下面的代码来验证Foo这个实体中的属性：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="attr">foo</span> = new Foo();</span><br><span class="line">foo.<span class="attr">CardNumber</span> = <span class="string">"234-7-4567"</span>;</span><br><span class="line">foo.<span class="attr">AccountNumber</span> = <span class="string">"12345678900"</span>;</span><br><span class="line">foo.<span class="attr">TransactionType</span> = <span class="string">"DCP"</span></span><br><span class="line"></span><br><span class="line">var <span class="attr">results</span> = EntityValidation.Validate&lt;Foo&gt;(foo);</span><br><span class="line"><span class="keyword">if</span>(!result.Success) results.ToList().Foreach(<span class="attr">r</span> =&gt; </span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine(r.Message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>#本文小结<br>&emsp;&emsp;本文首先讲述了特性和属性两者在概念上的不同，即特性是编程语言文法上的概念，而属性是面向对象编程里的概念。接下来，我们针对.NET中的Attribute的表象和具象进行了讨论，Attribute从表象上看是和Java中的注解类似，可以像使用标签一样附加在类、方法、属性或者字段等元素上，而从具象上看Attribute提供了一种在运行时期间通过元数据访问附加信息的能力，Attribute是附加在类、方法、属性或者字段等元素上的一个类，需要继承自Attribute，它的实例化必须依赖这些附加对象的实例化，并且Attribute在运行时期间是Readonly的，Attribute通常需要配合反射来使用。在具备这些基础知识以后，我们开始和大家分享这个验证方案的设计思路及其技术要点，所谓抛砖引玉，本文的目的是想让大家借鉴这种思路，努力让业务代码更干净些，因为只有我们在乎这件事情，我们才会努力去将它做好。好了，今天这篇文章就是这样啦，谢谢大家关注！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;各位朋友，我是Payne，大家好，欢迎大家关注我的博客，我的博客地址是&lt;a href=&quot;https://qinyuanpei.github.io&quot;&gt;https://qinyuanpei.github.io&lt;/a&gt;。在这篇文章中，我想和大家探讨下数据校
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C#" scheme="http://qinyuanpei.github.io/tags/C/"/>
    
      <category term="校验" scheme="http://qinyuanpei.github.io/tags/%E6%A0%A1%E9%AA%8C/"/>
    
      <category term="特性" scheme="http://qinyuanpei.github.io/tags/%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>《大护法》—— 花生镇里的成人童话</title>
    <link href="http://qinyuanpei.github.io/2017/07/30/a-story-never-seen-before.html"/>
    <id>http://qinyuanpei.github.io/2017/07/30/a-story-never-seen-before.html</id>
    <published>2017-07-30T20:38:22.000Z</published>
    <updated>2017-12-24T08:21:25.713Z</updated>
    
    <content type="html"><![CDATA[<p>  猛然间驻足回首这些错落的旧时光，我渐渐意识到我已经有三个月没有写博客了。如果一定要我说出这是种什么样的感觉，大概就是你永远都不会知道永远到底有多远。或许你会喜欢上一个陌生的人，源自不经意间的惊鸿一瞥；或许你会开始厌倦一个熟悉的人，源自不经意间的怅然若失。时间如风起云涌，一边熟悉着一边陌生着，永远像极了一场你追我赶的拉力赛。从办公室里走出来被热风吹袭的一瞬间，我居然有种久违的暖人肺腑的感觉。每个人都像一粒炭火，都知道要通过抱团来取暖，可是有谁会愿意燃烧自己呢？所以孤独是人类如宿命一般的社会属性。我一位朋友曾向我讲述过，这种若即若离的感觉，而此时此刻，我想将这种感觉结合一部电影来说出来。</p><p>  这段时间好像看了挺多电影的，借我一位朋友的话说就是，“两只单身狗跑到电影院里去找刺激”。而对于《大护法》这部电影，我是选择了一个人去看的，因为我觉得这部电影的主题是“反乌托邦式”的，所以我宁愿自己独自去消化这些内容，而不是将消极悲观的情绪在观影时传播给别人。对这部电影我将其看作是一个成人童话，因为它的确不适合带小孩子去观看，而这部电影恰恰采用了PG-13的影片分级。我喜欢这个电影，某种意义是因为它在现有体制内，讲述一群被奴役的“花生人”，如何在外人的帮助下，从愚昧麻木转变为意识清醒，并最终产生自我意识推翻统治者暴政的故事，所以这其实是一个关于觉醒和反抗的故事。</p><p>  而这基本上是人类历史里永恒的话题啦，熟悉苹果公司历史的朋友一定知道，乔布斯当年曾经拍摄过一部名为《1984》的广告片，这部广告片取材自乔治.奥威尔的同名小说，该书中刻画了一个令人窒息的恐怖世界，在假想的 未来社会中，独裁者以追求权利为最终目标，自由被彻底剥夺，思想被严酷控制，人民被迫屈从于“老大哥”的统治。而将书中这个背景对应到苹果公司，我们就部难理解乔布斯是在用“老大哥”来影射当时的IBM公司，在这则广告片中“老大哥”被铁锤击碎后缓缓消失，此时旁白平静地念道：“1月24日，苹果电脑公司将推出麦金塔电脑，你将明白为什么1984不会变成《1984》”，这段传奇故事在《硅谷传奇》和《乔布斯》两部电影中均有反映，对此感兴趣的朋友可以自己去了解，显然乔布斯在当时试图向世界证明，苹果公司是唯一一家有希望打败IBM的公司。</p><p>  因此在很长一段时间里，我一直有想要通读《1984》的愿望，这种行为在某些人看来是矫情和装逼，可事实上连周星驰都表示没有读完《演员的自我修养》这本书，我就不明白这个想法为什么会遭人厌恶。这个世界上最令人厌恶的事情就是，我们所有人都生活在一个被道德和法律约束的世界，我们从出生就在适应接受某一种意识形态或者社会法则，可总有人试图告诉你生活是这样或者那样，并且出自尊重你必须接受和感谢这种建议，因为这些人最后会说我是为了你好。那么在导演不思凡的视角里，这种回归哲学意义上的最为追根溯源的问题，即我是谁，是如何通过电影表现出来的呢？欧阳吉安，即花生镇村名眼中的老神仙，他说鬼蘑菇是一种可怕的传染病，一旦花生人长了鬼蘑菇就必须被立即处死，花生人不能开口说话，即使他们都贴着假眼睛和假嘴巴，花生人不能拥有意识和思考，一旦说出事实就会被认为染了疯病必须被立即处死，所有的村民都循规蹈矩地听着老神仙的话，可事实上鬼蘑菇根本就不是传染病，它是花生人成熟的标志，老神仙这样一个统治者，从来不会将花生人视为人，它们活着的唯一意义就是等死后，由庖卯从脑袋里取出黑石头。古话说：流言止于智者，可在这个荒诞诡异的世界里，流言会因为恐惧而掩盖真相，村民始终生活在一种令人窒息的恐怖阴影里。</p><p>  故事开篇即点明主旨，即奕卫国大护法，即故事主角“红冬瓜”为寻找太子下落，而来到了充斥着腐烂气息的花生镇，虽然主角对这些像人而又不像人的“花生人”表示了反感，因为在大护法沿着山路来到小镇的时候，经过了一个类似拱门的建筑，可细思恐极的是这个拱顶堆满了花生人的头颅，而且头颅上的眼睛是真正的眼睛，而散落在地面上的贴纸其实是假的眼睛，联想整个故事情节，在花生镇敢于揭露真相、寻找真相的人都被杀鸡儆猴地处理掉了，这可以说是故事开篇埋下地一个伏笔了，可是为了寻找太子的下落，大护法不得不去向这些村民打探消息。可是大护法很快就发现，在花生镇这样一个奇怪的地方，随时随地都会有人杀戮村民和外来者，这些人被称为刑法者，负责帮助老神仙欧阳吉安杀死“该死”地村民，所以在故事一开始大护法在村子里就遭到了袭击，可是说起大护法来，这是一个战斗力爆表的反差萌系设定，而通过故事我们知道，这些刑法者由一个称为罗单的人管理，他不属于花生镇，和欧阳吉安这些人类不一样，他对彩这个神秘女子有种强烈的占有欲，他偷看她洗澡被发现便转身离开，可当他发现下属产生感情的时候，他毫不留情地杀死了他们，所以大概到现在为止，我们所认识的世界存在着严格的等级区分，整个故事从此定性，罗单压抑着自己的情欲，却不允许下属产生情欲，所以当他杀死欧阳吉安的时候，我们不会感到太意外，因为他心里隐藏了太多东西。</p><p>  太子是整个故事里，唯一一个清楚知道自己想要什么的人。他不喜欢朝廷里的纷争，便遁走江湖寄情山水，去寻找自己真正喜欢的事情。从来没有人将花生人当作人，他却视小姜为花生镇里最好的朋友。可我们都知道这样一句话：哪有什么岁月静好，不过是有人负重前行。在整个故事设定中，大护法的爷爷的爷爷起就一直是弈卫国的大护法，所以大护法的职责就是要保护太子，在故事安排上这部电影相对枯燥，因为后期基本上一直在找太子，所以太子有这样的机会，去选择做自己想做的事情，其实是因为有大护法在一直保护他，相反普通人可能不会有这样的机会，这一点我们稍后会提到。太子除了承担整部电影的笑点以外，我个人认为最出彩的地方是，他在被庖卯打得头破血流时，亲眼目睹了小姜的死，从那一刻开始，我相信他终于明白了身为帝王的那种担当，他不再是以前那个避世逃脱的太子，所以这种成长的感觉会非常好，他在看到大护法以后重复了两次“杀了他”，而在此之前他是坚决反对杀人的。</p><p>  小姜是唯一一个自我意识觉醒的花生人，他通过隐婆了解到自己是怎么来到这个世界上的，了解到毒蘑菇到底是怎么一回事情，了解到花生人来自蚁猴子却又以蚁猴子为食的真相，这里有一个有趣的设定，花生人是以蚁猴子作为食物的，这就好像喂猪的泔水里会有猪肉一样，想通了这一点，或许人吃猪肉和人吃人并没有本质的区别。小姜会说话这件事情，让欧阳吉安和疱卯都感到异样，前者是担心危及到自己的统治，后者是对自己的职业产生了怀疑。小姜最终还是死了，就像被庖卯杀死的那些花生人一样，不同的是那颗石头不再是黑石头，而是晶莹剔透的宝石。这让我想起蚌这种可以孕育出珍珠的海洋生物，普通的砂砾经过时间的磨洗可以变成美丽的珍珠。或许答案会是什么，更多的是因为你想要什么，内心贫瘠的土壤寸草不生，内心肥沃的土壤鲜花遍地。小姜内心善良所以懂得回报太子，但现在这个世界善良越来越被人忽视，小姜被老神仙视作圈养的猪啰，可太子会把他当作好朋友，所以说选择非常重要啦，遵从内心的选择更重要。</p><p>  庖卯这个角色其实挺悲哀的，他代表是那一类被理想绑架而失去自我的人。“庖”在古代就是指厨师这一类职业，我们熟悉的庖丁解牛这个词就是出自这里。可在影片中颇为讽刺的是，一个想成为厨师的人的最大理想，居然是想要一刀取人心脏，我们不能说这种想法不是一份理想，用大护法的话说就是“你的理想，杀气这么重，怕是实现得一天，会是你的终年”。我们注意到卯和丁一字之差，所谓“丁是丁，卯是卯”，当你被仇恨蒙蔽双眼的时候，看到的东西和实际相比大概会相差很多吧！庖卯在听见花生人说话以后就开始呕吐，这种感觉让他开始思考，自己每天屠杀的到底是些什么东西。试想我们每天吃的这些食物开口说话的话，我们同样会感到恐惧的吧，或许我们想和疱卯一样成为一名绝世大厨，但现实给我们的却是一份杀人的差事，我想坚持初心，知道自己从哪里来要到哪里去，就不会在路上迷失方向，他的死作为一种解脱，在这个故事里算是善终了吧。</p><p>  说了这么多，始终没有提到我们的大护法，个人感觉这个角色给我的印象确实不够深刻，它是一个古龙式的侠客形象，拥有和外表极不相称的武力值，这是一个用生命在战斗的人，从故事开头一直战斗到故事结尾，主角光环让它在断了数根肋骨后依然可以活到最后一刻，它是什么样子的呢？一个喜欢朗诵诗歌、自带莎士比亚腔调的文艺大护法，从台词的角度来讲，整部电影深刻中带着些许中二，但这部电影吸引的我，恰恰是这些硬伤很突出的地方，它整体的画风给人一种怪诞和虚无，可它的故事在国内审查体制下让人耳目一新，电影里说“假眼睛、假嘴巴都说贴着难受为什么还要贴？都摘掉它们会怎么笑话我？就因为怕被笑话，所以我们活成了笑话”，或许这是一部给成人看的童话，但透过这部电影多一点思考、多一点想象，大概是我们回报导演不思凡的最好方式之一，因为他想说的或许就是我们想说的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  猛然间驻足回首这些错落的旧时光，我渐渐意识到我已经有三个月没有写博客了。如果一定要我说出这是种什么样的感觉，大概就是你永远都不会知道永远到底有多远。或许你会喜欢上一个陌生的人，源自不经意间的惊鸿一瞥；或许你会开始厌倦一个熟悉的人，源自不经意间的怅然若失。时间如风起云涌，
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="大护法" scheme="http://qinyuanpei.github.io/tags/%E5%A4%A7%E6%8A%A4%E6%B3%95/"/>
    
      <category term="童话" scheme="http://qinyuanpei.github.io/tags/%E7%AB%A5%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>基于过滤器实现异常处理的探索</title>
    <link href="http://qinyuanpei.github.io/2017/05/20/research-for-exception-handling-based-on-filter.html"/>
    <id>http://qinyuanpei.github.io/2017/05/20/research-for-exception-handling-based-on-filter.html</id>
    <published>2017-05-20T20:10:28.000Z</published>
    <updated>2017-12-24T08:21:25.721Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;正如你所看到的那样，今天我想和大家聊聊异常处理这个话题。对于异常处理这个话题，我相信大家都有各自的方法论。而我今天想和大家探讨的这种异常处理方案，我将其称之为基于过滤器的异常处理。我不知道这种定义是否准确，我们的项目上在要引入AOP的概念以后，我们对异常处理的关注点就从<strong>try-catch</strong>转向<strong>Interceptor</strong>。虽然首席架构极力推荐，使用Unity框架来拦截代码中的各种异常，可从我最初纠结于”return”和”throw”的取舍，到现在我可以灵活地使用和捕捉自定义异常，对我而言老老实实地实践异常处理的经典做法，比使用AOP这样一种高大上的概念要有意义地多，因为我相信在某些情况下，我们并不是真正地了解了异常处理。</p><h1 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h1><p>  或许是因为人类对机器时代充满了近乎苛刻的憧憬，我们的计算机程序在开始设计的时候，就被告知不允许出现错误，甚至我们的教科书上会用一种充满传奇色彩的口吻，来讲述一个因为粗心的工程师计算错了小数点而导致航天飞行器机毁人亡的故事。可是人类常常会对自己选择宽容，而对他人则选择严格，这种观点在整个数字时代更为凸显，当我们无法容忍一个糟糕的应用程序的时候，无论曾经人们为此付出过多少努力，在这一瞬间他们的价值都将不复存在。我们的这种苛刻迫使我们不允许软件出现错误，我们尝试通过各种各样的测试来避免错误发生，可是事实上软件工程实践最终会演变为一个妥协的产物，这意味着我们任何的形式化方法最终都会失败，没有人可以保证一生都不会犯错，而软件工程师同样是人，为什么我们一定要求他们不可以犯错呢？</p><p>  我们不得不承认软件产品是一个持续演进的过程，如果抛开商业意义上的<strong>Deadline</strong>来说，实际上软件是永远没有写完的那一天的，这就是为什么工程师都有点理想主义的原因，不考虑外界环境因素的变化，而期待软件永远不会有新的问题产生，这实在是一种苛刻地要求。好了，我们在这里频繁地提到错误，那么在软件工程学意义上的异常和错误分别是指什么呢？具体来讲，异常是指我们可以明确预测到它会发生并且需要我们进一步处理的流程，而错误是指我们无法明确预测到它会发生并且它会程序流程中断而导致程序崩溃，所以我认为区分”异常”和”错误”最直观、最简单粗暴的方法就是，如果你捕捉到了一个异常并处理了这个异常，那么它就是异常。反之，如果任由异常导致程序Crash，那么它就是错误。如果我们因为畏惧异常而给所有方法增加try-catch，我不得不遗憾得告诉你，你还没有真正明白什么是异常。</p><p>&emsp;&emsp;在早期的Win32 API中，微软大量使用了错误码来表示方法执行过程中发生的错误，这样就引出异常处理中的第一个问题，我们到底是应该是使用错误码还是异常来表示方法执行中发生的错误？事实上这两者在程序的表达能力上等价的，它们都可以向调用者传达”异常发生“这个事件，譬如我们在集合中查找一个元素，如果元素不存在则返回-1，这其实就是一个使用错误码来表示”错误“的经典案例，显然这种从C/C++时代遗留下来的传统解释了Win32 API为什么会选择这样的设计方式，换言之，选择哪种方式，本质上是一种从API风格、代码风格和性能指标等方面综合考虑后的结果，错误码这种方式的缺陷主要在于，错误码不能明确地告诉调用者到底发生了什么错误，除非我们定义更多的错误代码，而且在没有引入可空类型以前，我们没有办法避免错误码污染返回值的值域，比如在这个例子，如果集合中恰好有一个元素-1，那么通过-1这个返回值我们是没有办法判断出，这个-1到底是不是因为方法内部发生了错误而返回-1.</p><p>&emsp;&emsp;好了，现在我们来说说异常，异常在主流的编程语言里基本上是一个标配。异常可以保存从异常抛出点到异常捕获点间的相关信息，所以异常相比错误码可以持有更多的信息，或许你可以尝试去设计一种数据结构来让返回值更丰富:)。我们常常听到”使用异常会降低程序性能”这样的说法，可这部分性能上的差异仅仅是因为，我们需要在抛出异常的时候给调用者更多的信息，所以这是一个非常公平的事情。第二个问题，我们是不是在所有情况下都使用异常？使用异常的好处是它可以让我们以一种更安全的方式去处理异常，可一旦发生了异常程序的性能就会降低，所以我们可以看到.NET中提供TryParse这样的方法，这其实是在告诉我们：如果预测到异常一定会发生，正确的策略不是去捕捉它而是去回避它。在《编写高质量的C#代码》一书中曾建议：不要在foreach内部使用try-catch，就是这个道理，即采用防御式编程的策略来回避异常，而不是总是抛出异常。</p><p>&emsp;&emsp;那么，总结下行文至此的观点：异常是强类型的，类型安全的分支处理技术，而错误码是弱类型的，类型不安全的分支处理技术。元组等可以让函数返回多个返回值的技术，从理论层面上可以模拟异常，即将更多的细节信息返回给调用者，可是这种方式相比由运行时提供支持的异常机制，在性能指标和堆栈调用上都存在缺陷。异常在被运行时抛出来的时候，程序性能是下降的，这是因为调用者需要更多的细节信息，所以不建议在所有场合都抛出异常，建议使用防御式编程的策略去回避异常，直到确定程序没有办法处理下去的时候再抛出异常。理论上所有自定义的异常都应该去捕捉并处理，否则定义这些自定义异常是没有意义的。异常处理应该拥有统一的入口，在代码中到处try-catch和记日志是种非常丑陋的做法，理论上应该坚决摒弃。</p><h1 id="Checked-Exception"><a href="#Checked-Exception" class="headerlink" title="Checked Exception"></a>Checked Exception</h1><p>  最近垠神写了一篇新的文章<a href="http://www.yinwang.org/blog-cn/2017/05/23/kotlin" target="_blank" rel="noopener">《Kotlin和Checked Exception》</a>，在这篇文章中垠神提到了Checked Exception这种针对异常处理的设计，而恰好我这篇文章写的同样是异常处理，并且我在下面提到的基于过滤器的异常处理方案，实际上就是为了解决这种Checked Exception的问题，虽然在.NET中不存在Checked Exception。</p><p>  要了解什么是Checked Exception，要从Java中的异常机制说起。Java中的异常类全部继承自Throwable，它有两个直接子类Error和Exception，通常情况下Error是指Java虚拟机中发生错误，所以Error不需要捕捉或者抛出，因为对此表示无能为力；而Exception则是指代码逻辑中发生错误，这类错误需要调用者去捕捉和处理。那么在这样的分类下，Java中的异常可以分为Checked Exception(<strong>受检查的异常</strong>)和Unchecked Exception(<strong>未受检查的异常</strong>)，前者需要需要方法强制实现throws声明或者是使用try-catch，如果不这样做编辑器就会直接报错，后者就相对宽容啦，没有这样霸道的条款，可是诡异的是RuntimeException是一个UncheckedException，可它居然是继承自Exception而不是Error，这实在令人费解，Java的设计模式果然博大精深。</p><p>  那么对一个Checked Exception，Java的处理方式是十分地霸道的，我们一起来看下面这段代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="built_in">string</span> fileName)</span> throws FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(...) <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以注意到Java强制让Foo()方法实现了throws声明，原因是在该方法内部可能会引发FileNotFoundException，如果我们不遵从这一”霸王条款”，那么我们的代码将无法通过编译，而在调用者层面上，Java的霸道则体现在要求调用者使用try-catch结构处理这种异常，或者继续使用throws声明来使异常继续向上传递，我更喜欢将这种设计称之为一种理想状态下的异常处理机制，比如我们读写一个文件的时候，除了FileNotFoundException以外，可能还会遇到FileLoadException、PathTooLongException、EndOfStreamException等等的异常，如果这些异常在业务层面上是无差别的，那么我认为将异常细分到如此精细的程度是没有意义的，因为对用户而言这个时候它关心的是否成功读写了这个文件，具体的异常原因用户并不想真的知道，可是Java的Checked Exception在面对这种处境的时候，整体而言是显得力不从心的，因为我们不得不在方法从声明该方法会引出哪些异常，这对方法的编写者和方法的调用者来说都很痛苦。</p><p>&emsp;&emsp;垠神这篇文章其实在说一个问题，Checked Exception鼓励开发者主动告知调用者来捕获特定异常，这种思路完全是没有问题的，问题是调用者如何能够知道它需要捕获哪些异常，我们不可能每次都通过”转到定义”功能去看一个方法会引发哪些异常，垠神从PL的角度出发，想到了通过代码静态分析的方法来处理异常，垠神吐槽的其实是不分青红皂白滥用try-catch的做法，实际上Java标准库里对异常处理相当混乱，虽然官方鼓励使用Checked Exception，但是标准库实现和工程实践上不乏将异常包装为RuntimeException来规避Check的做法，我认为Checked Exception在工程学意义上最大贡献是，在开发阶段该抛出什么异常就应该抛出异常，因为这样可以方便我们快读定位问题，而到了发布阶段则应该将这些异常都catch住即可，这样用户就不会看到这些奇葩的异常。换句话说，我们不必在程序中去处理所有的异常，而是将异常机制作为我们定位问题的工具，去捕获那些有可能出现的异常即可。</p><p>&emsp;&emsp;C#中其实是由类似Checked Exception的概念存在的，不过所有的Check都不是强制去实现的，我们知道.NET中一个方法会抛出哪些异常完全是由注释来说明的，XML注释中的exception节点表示该方法会引发何种异常，我们一起来看下面的例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref="MasterFileFormatCorruptException"&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref="MasterFileLockedOpenException"&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReadRecord</span>(<span class="params"><span class="keyword">int</span> flag</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MasterFileFormatCorruptException();</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MasterFileLockedOpenException();</span><br><span class="line">     <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以注意到C#采用的是一种相对温和的策略，即文档会明确告诉你，某个方法是否会引发异常以及引发哪些异常，但是是否要捕获这些异常则完全由调用者决定，我认为这是C#之父Hejlsberg在权衡后在工程实践上选择的一种妥协，因为Java的Checked Exception理想主义色彩稍重，并不是在所有场景下我们都需要去处理所有的异常，所以Checked Exception带来的问题是，即使在只需要捕获基类异常的情况下，我们依然不得不去捕获各种子类异常，这难道不有点矫枉过正的感觉吗？事实上所有工程实践中，不分青红皂白直接捕获Exception父类的做法，就是因为调用者完全不想关注发生得异常细节，这是垠神在文章中吐槽的”糟糕的代码”，C#相对Java在异常处理上好的一点就是，优秀的工程师会自觉地处理异常，如果他们清楚地知道异常会发生就一定会去捕获异常。你不能强迫他们去做他们不喜欢做的事情。</p><h1 id="让异常处理更优雅"><a href="#让异常处理更优雅" class="headerlink" title="让异常处理更优雅"></a>让异常处理更优雅</h1><p>&emsp;&emsp;好了，现在我们来考虑这样一个问题，设计Checked Exception的初衷是为了让我们处理业务逻辑中不同的具体的异常，当这些异常在业务逻辑层面上无差别的时候，其实我们可以完全忽略这些异常的细节，因为不管是哪种具体的异常，在业务逻辑层面都被认为是任务执行失败，这种情况下我们直接捕获基类异常即可，例如在读写文件的例子中我们关注IOException即可。那么如果这些具体异常在业务逻辑层面上存在差异呢？这种情况下我们就应该向Checked Exception方向靠拢，下面我们来一起听一个实际的故事。</p><p>&emsp;&emsp;我们的项目上需要从多个相互独立的系统中抓取数据并生成报表，因为这些系统在设计上都存在缺陷，所以在抓取数据的过程中非常容易出现错误，所以我们必须非常谨慎地处理这些异常，用户要求我们必须一种视觉友好的方式将报表输出出来，当异常发生时我们需要将抓取失败的数据高亮显示出来，并输出相关的错误信息来提醒用户来Check这些信息，而事实上每种异常发生的时候其处理逻辑是完全不同的。为此我们定义了将近10种的自定义异常，并为用户设计了完善的操作日志记录机制，这一切听起来非常不错，最终写出来的代码大概是下面这个样子：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  Foo()</span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionA ex)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionB ex)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionC ex)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;carch(ExceptionD ex)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></p><p>  相信在Java的相关工程实践中，这种教科书般的代码基本上是异常处理的金科玉律啦，可是这种代码实现写起来会让人感觉头重脚轻，因为我们所有重要的逻辑都写在了catch块里，这让我非常不喜欢这种”臃肿”的代码，而且事实上在这个案例中catch块里的代码具备可重用的可能，所以我决定以一种更优雅的方式来重构这段代码。数学领域中有一个不变的真理，即任何问题都可以通过引入一个新的问题来得到解决，这个理论在编程中同样适用，因为在公司里受到同事Wesley的影响，我对Ioc和AOP都从思想上有了一定认识，公司在推行Unity的过程中我并没有看到多少实际的意义，所以我对”道”的重视远远超过对”术”的追求，因为我相信框架学习起来并不会花费多少实践，可怕的是你从来不试图去了解框架背后的秘密，所以我借由AOP中拦截器和MVC中过滤器的概念，想到了我接下来要说的这种异常处理的方案。</p><p>  其实我们在这里的核心目的是为了消除分支，所以采用多态是我们重构这部分代码的第一步。我们首先定义一个针对Foo方法的异常基类ExceptionBase，然后让这里的ExceptionA、ExceptionB、ExceptionC等全部继承自ExceptionBase，这样我们就可以将这些具体的异常子类向上转型为ExceptionBase统一进行处理。与此同时，我们注意到处理各种异常子类的逻辑各不相同，虽然我们可以直接将处理异常的逻辑写到异常中(通过一个虚方法来实现)，可这样会造成异常子类里的职责负荷，我更希望异常子类是一个朴素的贫血模型，所以我们这里引入过滤器的概念(不知道这样叫是否合适)，Filter全部继承自FilterBase，它有一个Invoke的方法，我们最终会在这里实现异常处理的方法，为此我们需要定义各种各样的Filter，然后通过Attribute将每一种Filter和特定的Exception关联起来，比如我们希望在所有异常的地方打日志，那么我们只需要实现一个LoggerFilter，然后给所有的Exception添加Attribute，这可以显著改善我们的代码。</p><p>  现在，我们只需要给ExceptionBase类提供一个GetFilter()方法，该方法的返回值类型为FilterBase，我们将通过反射来创建一个Filter并将其返回，所以我们写出来的代码会是下面这个样子：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ExceptionFilter(FilterName = <span class="meta-string">"FilterA"</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">ExceptionA</span> : <span class="title">ExceptionBase</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExceptionFilter(FilterName = <span class="meta-string">"FilterB"</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">ExceptionB</span> : <span class="title">ExceptionBase</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExceptionFilter(FilterName = <span class="meta-string">"FilterC"</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">ExceptionC</span> : <span class="title">ExceptionBase</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>此时此刻，我们的关注点就从一堆catch块中转移到了不同的filter中，虽然我们编写代码的工作量没有减少，但这样的做法无疑增强了代码的可维护性，因为我们只需要到不同的Filter里去修改逻辑即可，我在书上看到这样一句话，无论什么时候合并代码总是比拆分代码要容易，当你不确定某个功能是否要放在特定模块中的时候，最好的解决方案就是将他们完全独立设计。降低代码的耦合度是一件我们常常挂在嘴边的事情，可是如何去真正地降低代码耦合度，这件事情需要我们一直思考下去。好了，现在我们完成了分支结构上的精简，而最终调用的代码会是：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">  Foo()</span><br><span class="line">&#125;catch(ExceptionBase ex)</span><br><span class="line">&#123;</span><br><span class="line">  var<span class="built_in"> filter </span>= ex.GetFilter();</span><br><span class="line">  filter.Invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的代码是不是比原来清新了好多呢？虽然这相比真正的AOP还是稍显稚嫩，可它的出现成功地让一段”丑陋”的代码变得优雅起来，我们不必再担心修改异常处理流程时会原来的代码产生副作用，如果需要增加新的处理逻辑我们继续派生异常类和过滤器即可，这就是代码设计上以不变应万变的道理，你要相信程序员都是非常懒惰的，如果有可以不用修改代码就适应变化的设计，他们是一定会喜欢的，因为这个世界对程序员并不友好，如果你不想你的代码被这个世界修改得面目全非，最好的选择就是不给它们这样的机会，他们说人长大一定会变成自己讨厌的样子，我想告诉这个世界永远不要忘记初心。</p><p>  好了，这篇文章唠叨到现在，写了大概5000多字，花了我整整两个下午的时间，我在向Paul和John询问这个问题的看法时，他们都告诉我这个问题没有好的解决方案或者是劝我不要做这样探索，可是事实上我只用了半天时间就完成了这个设计，在去年的时候我曾向房燕良前辈请教好异常处理的问题，当时我的关注点主要在使用错误码还是使用异常。在上一个项目中，我对于异常处理其实实践得并不好，因为我一直不知道哪里是捕获异常的入口，我个人并不认同直接捕获到异常直接throw这种做法，因为你在自定义异常的时候就应该想清楚，哪些异常是需要捕获并处理的，哪些异常时可以直接让它Crash的，如果每个人都仅仅是抛出异常而不去拦截异常，那么异常机制设计得再好又有什么用呢，关于Java的异常有一个梗，是说Java的异常给出了详细的堆栈信息，可就是不直接告诉你到底是哪里异常了，事实证明我设计的这个方案运行的很好，其实我很想吐槽操作日志真的有存在的必要吗？很多时候，我们要学会遵从自己内心的声音，所谓世间难道不就是我们吗？真正绑架我们的永远都只有别人，让我们时刻谨记：万物为虚，万事皆允。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;正如你所看到的那样，今天我想和大家聊聊异常处理这个话题。对于异常处理这个话题，我相信大家都有各自的方法论。而我今天想和大家探讨的这种异常处理方案，我将其称之为基于过滤器的异常处理。我不知道这种定义是否准确，我们的项目上在要引入AOP的概念以后，我们对
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="设计" scheme="http://qinyuanpei.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="异常" scheme="http://qinyuanpei.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="架构" scheme="http://qinyuanpei.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>异步Lambda表达式问题的探索</title>
    <link href="http://qinyuanpei.github.io/2017/04/15/research-on-asynchronous-lambda-expression.html"/>
    <id>http://qinyuanpei.github.io/2017/04/15/research-on-asynchronous-lambda-expression.html</id>
    <published>2017-04-15T21:10:47.000Z</published>
    <updated>2017-12-24T08:21:25.721Z</updated>
    
    <content type="html"><![CDATA[<p>  各位朋友，大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是:<a href="http://qinyuanpei.com" target="_blank" rel="noopener">http://qinyuanpei.com</a>。今天博主想和大家探讨的是，.NET中异步Lambda表达式的问题。为什么要讨论这个问题呢，这或许要从公司首席架构推广内部框架这件事情说起。我其实很久以前就有这种在团队内部做技术演进的想法，即通过公共类库、团队Wiki和技术交流等形式逐步地推进和完善团队整体架构的统一，因为一个团队在业务方向和技术选型上基本是一致的，因此团队内的技术演进对提高开发效率和交付质量意义重大，所以我能理解首席架构在内部推广公共类库这件事情，因为除了KPI这种功利性的目标以外，从长远来看这些东西对一个团队来说是积极而有利的，可是我们都知道工程师是这个世界上最傲慢的人，如果一个东西设计得不好，他们一定会尝试去改进甚至重新设计，所以架构并非是一种虚无缥缈的、凭空想象出来的东西，它的存在必须是为了解决某种问题。</p><p>  所以我始终认为，架构设计必须由一线开发人员来提炼和抽象，因为只有真正经历过”坑”的人，才会清楚地知道团队里最需要解决的问题是什么，一个良好的架构绝对不是由某些所谓”专家”闭门造车的结果，你只有真正了解了一个问题，懂得如何去定义一个问题，你才会知道目前这个团队中最迫切需要去解决的问题是什么，虽然说团队里技术层次存在差异，一个技术选型必然会和普通社会学问题一样存在众口难调的情形，可是一个东西设计得不好它就是不好，你不能强迫团队成员必须去使用它，因为这实在有悖于”自由”和”分享”的黑客文化。我相信软件开发没有银弹可言，这意味着它没有一种一劳永逸的解决方案，即使它的抽象层次再高、代码鲁棒性再好，所以团队内部技术演进应该采取”自下而上”的方式，对待工程师最好的方式就是给他们充分的自由，”自上而下”的行政命令不适合工程师文化，自计算机文明诞生以来，那种来自内心深处的”极客思维”决定了我们的基因，所以啊，”请原谅我一生不羁放纵爱自由”。</p><p>  好了，现在回到这个问题本身，问题产生的根源来自ICommand接口，而我们都知道该接口主要承担命令绑定作用。通过ICommand接口的定义我们可以知道，ICommand接口的Execute方法是一个同步方法，因此常规的做法如RelayCommand或者DelegateCommand，基本上都是传入一个Action来指向一个具体方法，最终ICommand接口中的Execute方法执行的实际上是这个具体方法。截止到目前为止，这个策略在主流的场景下都实施得非常好，可是我们在引入Task、async/await这些新的概念以后，我们突然发现ICommand接口存在一个亟待解决的问题，即它缺乏一个支持异步机制的Execute方法，显然这是一个历史遗留问题。<br>  <br>  我开始关注这个问题是当我在同事John和Charles的项目中看到类似下面的代码，事实上他们都是非常优秀的高级工程师，在对这个问题理解和探讨的过程中，我要特别感谢他们愿意分享他们的想法。我们一起来看看下面的代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RelayCommand RunCommand</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">get</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RelayCommand(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">      <span class="comment">/* await awaitable */</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  请相信你的眼睛，因为你没有看错，让我倍感纠结的的正是这样一段简单的代码。这段代码让我迷惑的地方有两处，第一，RelayCommand实现了ICommand接口，而ICommand接口的Execute方法是一个同步的方法，为什么我们可以在这个里传入一个异步方法，并通过Action这种委托类型来对其进行包装；第二，Action是一个void类型，即无返回值的委托类型，我们这里显然使用async关键字修饰了一个无返回值的方法，因为我们在这个匿名方法内部使用了await语法。可是我们知道微软官方的建议是，使用async关键字来修饰一个返回值类型为Task或者Task<t>的方法。在我了解到async关键字还可以这样使用以后，对第二处疑惑我稍稍有些许释怀，因为事实上Charles就是正式通过这种思路来启发我，可我始终无法理解，为什么我们可以在一个同步的方法里执行一段异步代码，并试图去安慰自己说这段代码是异步的，在执行一个非常耗时的任务时界面不会阻塞。</t></p><p>  我们的项目需要在整个任务执行过程中输出操作日志，这意味着消息会实时地输出到界面上并且不会阻塞界面。我们在为此设计了一个基于观察者模式的消息队列，所有需要发送实时消息的模块被抽象为一个消息主题，而界面模块、日志模块等被抽象为消息观察者，所有订阅过的消息主题都会将消息推送到消息队列中，这一切目前在设计上是符合业务需求的。可是很快我们就会发现一个问题，使用await或者Wait()方法时，消息并不是实时地发送到界面上去的，因为我们知道await或者Wait()方法会一直等待一个异步任务执行完成，所以消息会在任务结束的一瞬间被全部发送到界面上，这显示是不符合我们的期望的，所以Execute()方法里执行的必然是一个同步方法，它不会因为我们传入了一个异步方法而改变，况且同步和异步是相对而言的，如果我们将await语法修改为Task.Run()，我们就会发现在异步任务执行完成前同步方法就开始执行了，而这正是我们想要的结果。</p><p>  在这里我更感兴趣的一个问题是，.NET框架中的委托、匿名方法、Lambda表达式和Task是不同时期.NET的产物，那么我们在这里使用一个async关键字来修饰一个匿名方法，编译器在处理它的时候到底会怎么做呢？因为我们知道委托会被编译成一个包装类，那么现在在这篇文章中的提到的这个问题背景下，它会有什么不同呢？我们一起来看下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">void</span> Main(<span class="built_in">string</span>[] args)</span><br><span class="line">&#123;</span><br><span class="line">  Action action1 = <span class="keyword">async</span> () =&gt; <span class="keyword">await</span> DoWorkAsync();</span><br><span class="line">  Action action2 = <span class="function"><span class="params">()</span> =&gt;</span> DoWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们注意到这里声明了两个Action，即两个没有返回值的委托类型，它们的不同点在于前者使用了async/await这两个关键字，而后者则是一个普通的同步方法，那么这两者生成的IL代码是否有区别呢？我们可以通过IL DASM或者是IL Spy这两个工具来查看IL代码：</p><p><img src="http://img.blog.csdn.net/20170521015438504" alt="查看IL代码"></p><p>  我们可以注意到两点，第一，两个委托类型生成的中间代码完全一致，都是<strong>CachedAnonymousMethodDelegate</strong>，这在某种程度上说明不管Action里包装的是一个同步方法还是一个异步方法，最终生成的IL代码应该都是相同的。第二，同匿名方法和扩展方法一样，async/await并未引入新的IL指令，async/await内部应该是在维护一个状态机，这一点和yield关键字应该是相似的，并且对于异步的匿名方法(指voild类型)，通过IL代码可知它是由<a href="http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.asyncvoidmethodbuilder.aspx" target="_blank" rel="noopener">AsyncVoidMethodBuilder</a>类来生成的，而对于异步的方法(指Task和Task<t>类型)，则是由<a href="http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.asynctaskmethodbuilder.aspx" target="_blank" rel="noopener">AsyncTaskMethodBuilder</a>类来生成，需要说明的是这两者在功能上相差无几，唯一的区别就在于异常处理。</t></p><p>  关于异步编程中异常的处理，老赵在其博客<a href="http://blog.zhaojie.me/2012/04/exception-handling-in-csharp-async-await-1.html" target="_blank" rel="noopener">关于C#中async/await中的异常处理（上）</a>和 <a href="http://blog.zhaojie.me/2012/04/exception-handling-in-csharp-async-await-2.html" target="_blank" rel="noopener">关于C#中async/await中的异常处理（下）</a>这两篇博客中做了非常详细的解释，建议大家有时间的话去阅读这两篇文章，我们在这里关注结论就好。<br>  <br>  具体来讲，async Task或者async Task<t>方法引发异常时，会捕获异常并将其放置在Task对象里，并且只有Task对象被await时会引发异常。特别地，在调用Task.WhenAll()方法时，一个Task对象中可能会含有多个异常，此时await仅仅会重新抛出第一个异常，但是在 Task 上使用 Task.Wait 或 Task.Result 同步阻塞时，所有异常都会用 AggregateException 包装后引发。对于嵌套的Task，即含有子任务的Task，应该采用AggregateException来获取和处理所有的异常。Task/Task<t>中未捕获的异常可以通过TaskScheduler.UnobservedTaskException来处理，这些异常不会继续向上抛导致程序异常退出。<br>  <br>  async void方法引发异常时，因为它没有Task对象来放置异常，因此它的异常SynchronizationContext上引发，而且因为<a href="http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.asyncvoidmethodbuilder.aspx" target="_blank" rel="noopener">AsyncVoidMethodBuilder</a>内部并没有使用TaskScheduler，因此对于async void方法来说，线程池中未捕获的异常将会一直向上抛并最终导致程序异常终止，虽然我们可以在AppDomain.UnhandledException这个事件中捕捉到这些”未处理的异常”，但这并不能阻止程序异常终止，通过我们可以通过注册这个事件来记录异常日志，以帮助我们快速定位问题。</t></t></p><p>  好了，现在我们回到这篇文章开始的问题，我们现在知道async Task和async Task<t>引发的异常，都不会是程序立即终止，除非我们显式地去await一个Task对象会引发异常，可是对async void来讲，一旦它引发异常，常规的try-catch时无法捕捉到异常的，这种”未处理的异常”会一直向上抛并最终导致程序异常终止。我为什么要说这个问题呢，因为我们在文章开始的时候写了一个异步的lambda表达式，最终它会被编译为async void，我们现在应该会了解到，async void非常容易引发未处理的异常并导致程序异常退出，所以这是微软官方最佳实践中不推荐使用async void的原因，因为使用async void就意味着我们要去捕获所有的异常。可是对标记为async的lambda表达式来讲，这个问题是非常隐蔽而且蛋疼的，或许不使用async void就是最为正确的选择了吧！</t></p><p>  最后，其实坦白讲，我自己是不清楚在这篇文章里我到底说什么的，因为这样一个在项目开发中遇到的问题，其实并不是一个特别重要的内容，因为它实在是太容易被我们给忽略啦。我最初关注这个问题完全是因为好奇，因为我从来没有见到过这种lambda表达式的写法，虽然纠结这样一个语法上的问题，和孔乙己讨论茴香豆的”茴”字由几种写法一样，都是一个相当迂腐不堪的表现，可我庆幸这份好奇让我了解到了更多的东西。其实总结下这篇文章中关注的点，主要有：</p><ul><li>由同步方法和异步方法包装的委托类型在IL层面上是无差别的，委托关注的是参数列表和返回类型，和是否有async关键字修饰没有关系。</li><li>匿名方法或者lambda最终依然会被编译为一个方法，在有async关键字修饰的情况下，建议使用Func而不是Action，因为前者可以生成async Task或者async Task<t>，而后者仅仅可以生成async void。</t></li><li>async Task/async Task<t>和async void在异常处理机制上存在差异，前者未处理的异常不会继续向上抛导致程序异常退出，而后者未处理的异常会继续向上抛并导致程序异常退出，因此如果坚持要使用async void，就一定处理各种异常。</t></li></ul><hr><p>参考文章：<br><a href="https://www.baidu.com/link?url=f9umAhHAgIYBz5X8dwyjUnu1g8w9RCPtJohhtnWsxDW8BdwLHKFVP0hA1sg0PwOTBF6zKP7AlEPZKiDYgLGleK&amp;wd=&amp;eqid=e9ff05d4000bd133000000035921a2ab" target="_blank" rel="noopener">Microsoft - async/await - 异步编程中的最佳做法</a><br><a href="http://www.cnblogs.com/TianFang/archive/2012/12/24/2831341.html" target="_blank" rel="noopener">TianFang - C# 5.0 async 函的提示和技巧</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  各位朋友，大家好，欢迎大家关注我的博客，我是Payne，我的博客地址是:&lt;a href=&quot;http://qinyuanpei.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://qinyuanpei.com&lt;/a&gt;。今天博主想和大家探讨
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程" scheme="http://qinyuanpei.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="异步" scheme="http://qinyuanpei.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Lambda" scheme="http://qinyuanpei.github.io/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存技术学习系列之发布订阅</title>
    <link href="http://qinyuanpei.github.io/2017/04/15/redis-cache-technology-learning-series-03.html"/>
    <id>http://qinyuanpei.github.io/2017/04/15/redis-cache-technology-learning-series-03.html</id>
    <published>2017-04-15T21:03:57.000Z</published>
    <updated>2017-12-24T08:21:25.721Z</updated>
    
    <content type="html"><![CDATA[<p>  各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是<a href="http://qinyuanpei" target="_blank" rel="noopener">http://qinyuanpei.com</a>。最近这段时间的天气可谓是变幻莫测，常常是周一到周五像夏天般热烈，而周六和周天像秋天般冷清。你不知道它到底会在何时下雨，即使你可以一直带着伞等雨落下来。但是对于没有伞的我来说，学会努力奔跑以至于不那么狼狈，或许是在这个世界上我唯一可以去做的事情。可是你知道一个人孤独的时候，即使是下雨这种再平常不过的事情，他都可以从雨声里听出孤独的感觉来，所以这个周末我决定继续研究Redis缓存技术，而今天我想和大家讨论的话题是Redis中的发布-订阅(Pub-Sub)，希望大家喜欢！</p><a id="more"></a><h2 id="从观察者模式说起"><a href="#从观察者模式说起" class="headerlink" title="从观察者模式说起"></a>从观察者模式说起</h2><p>  如果你熟悉常见的<a href="https://gof.quanke.name/" target="_blank" rel="noopener">设计模式</a>，就应该会知道在24种设计模式中，有一种称为<strong>观察者模式</strong>的设计模式，该模式又被称为<strong>发布-订阅模式</strong>。在正式讨论Redis中的<strong>发布-订阅</strong>特性前，我想先花点时间来为大家讲解下这种设计模式。观察者模式定义了一种一对多的依赖关系，让多个观察者同时监听同一个主题对象，当该主题对象在状态发生变化时，会通知所有观察者对象并使其自动更新自己。下面是该模式的UML类图：</p><p><img src="http://img.blog.csdn.net/20170416004605342" alt="设计者模式的UML类图"></p><p>  通常我们提到设计模式的时候，都认为实际模式是非常抽象而晦涩的概念，事实上设计模式是一种经过反复验证的编程经验。我们每天面对这个世界对其进行抽象并认识它，所以设计模式本质上是根植自生活的一种编程思想。以观察者模式为例，我们或许会在微信里订阅各种各样感兴趣的公众号，当这些公众号的内容发生更新时，就会主动向我们推送新的内容。在这里，我们订阅的公众号称为”主题”，而我们则称为”观察者”或者”订阅者”，而这正是观察者模式又被称为”发布-订阅模式”的原因所在，这种定义了一种一对多的依赖关系，让多个观察者同时监听同一个主题对象，当该主题对象在状态发生变化时，会通知所有观察者对象并使其自动更新自己的设计模式就被称为”观察者模式”。而通过这张图我们可以了解到，观察者模式试图解决的问题是，在不同的实例对象间相互协作的时候，如果在降低其各自耦合度的同时，维持这些示例对象间的一致性。在该模式中，主要存在四种角色，即：</p><ul><li><strong>抽象主题(Subject)</strong>：抽象主题将所有观察者对象的引用保存到一个集合里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加(Attach方法)和删除(Detach方法)观察者对象。</li><li><strong>具体主题(ConcreteSubject)</strong>：具体主题将在其内部定义相关状态，并将相关状态存入具体观察者对象。在具体主题内部状态发生变化时，通知所有注册过的观察者发出通知，即UML类图中定义的Notify()方法。</li><li><strong>抽象观察者(Observer)</strong>：抽象观察者将为所有具体的观察者定义一个接口，在获得主题更新通知时更新自己，即UML类图中定义的Update()方法，执行该方法后观察者与主题的状态实现同步。</li><li><strong>具体观察者(ConcreteObserver)</strong>：具体观察者将实现抽象观察者所定义的更新接口，来使得观察者自身的状态与主题状态协调，即具体观察者需要重写Update()方法并维护其内部状态同主题保持一致。</li></ul><p>  至此我们就从思想上理解了观察者模式，观察者模式本质上是在维护一种一对多的依赖关系，因为观察者与主题都是依赖于抽象而非具体，两者分别属于两个不同层次上的抽象，因此观察者和主题两者间是解耦的。可是当你去实现一个具体的主题或者具体的观察者的时候，你会发现这两者间依然存在一定的依赖，因为观察者和主题在接口设计上需要协调，因为两者分别作为消息的”接收方”和”发送方”存在。观察者模式虽然在解耦上效果显著，可这并不代表它就是完美的。事实上，当观察者数目特别多的时候，为了通知所有的观察者将花费大量的时间；其次，当观察者间存在依赖关系时，观察者模式将导致这些观察者出现循环调用；再者，当主题通过异步的方式来通知观察者时，需要考虑通知本身是以自洽的方式进行的；最后，观察者模式可以确保观察者捕捉到主题的变化，可是观察者模式机制本身不具备知晓主题如何变化的能力。好了，下面我们来讲解如何实现一个基本的观察者模式。</p><h2 id="观察者模式的实现"><a href="#观察者模式的实现" class="headerlink" title="观察者模式的实现"></a>观察者模式的实现</h2><p>  现在，我们已然了解到在观察者模式中主要有四类角色，即抽象主题、抽象观察者、具体主题和具体观察者。因此，要实现观察者模式，实际上就是要实现这四种不同的角色。回到我们最初讨论过的场景，即微信用户订阅公众号，假设博主希望在博客更新的时候，以邮件或者公众号的形式来通知读者朋友博客更新的内容，这是一个典型的一对多的依赖关系维护的问题，显然此时观察者模式是一个最佳的设计思路。在这个设计中，邮件和公众号是两个具体的观察者，而博客是一个具体的主题。参照观察者模式的UML类图，我们应该首先提取出来两个抽象类，即Subject和Observer。</p><p>  对Subject类而言，首先它需要提供一个订阅(Subscribe的方法和取消订阅(Unsubscribe)方法，这和我们在日常生活中订阅报纸是完全一样的；其次，它需要有一个更新(Update)的方法，该方法负责向所有的订阅者广播消息。为什么叫做广播呢？因为所有的订阅者都会收到这条消息，这种订阅者被动接受主题推送消息的方式我们称为”推送模式”，即在Update的时候，主题会主动推送”参数”给订阅者；而订阅者主动拉取主题消息的方式我们称为”拉取模式”，即在Update的时候，主题并不主动推送”参数”给订阅者，而是由订阅者通过注入的主题来获取消息。这两种方式我们都可以称之为观察者模式，在这里我们选择”推送模式”，代码实现如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> IList&lt;Observer&gt; observers = <span class="keyword">new</span> List&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attach</span>(<span class="params">Observer observer</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      observers.Add(observer);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deatch</span>(<span class="params">Observer observer</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      observers.Remove(observer);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"><span class="keyword">string</span> message</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      observers.ToList().ForEach(o =&gt; o.Update(message));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对Observer而言，它在观察者模式中承担着消息接收者的角色，所以我们需要为其定义好接收消息的接口，需要注意的是该接口必须与具体主题保持一致，这便是我在文章中提到的，主题和观察者存在一定程度依赖的问题。考虑到不同的观察者所做的事情是完全不同的，例如邮件和公众号采取两种不同的方式来推送消息，因此Update方法应该被声明为虚方法，以为不同的观察者提供重写的扩展能力。它的代码实现如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"><span class="keyword">string</span> message</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对具体观察者而言，我们需要做的就是继承Observer类然后重写Update方法，在这里我们需要实现两个不同的类EmailObserver和WechatObserver，它们分别来实现邮件和公众号接收到主题推送消息以后的逻辑，这里以EmailObserver为例，代码实现如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmailObserver</span>:<span class="title">Observer</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"><span class="keyword">string</span> message</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Console.WriteLine(<span class="string">"邮箱接收到订阅消息:&#123;0&#125;"</span>, message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  对具体主题而言，我们不再关心如何向所有的观察者发送消息，该功能在Subject父类中已然完成。我们可以为新的主题类添加更多的属性来描述其内部发生变化时的状态，例如文章数目、评论数目或者是内容更改等等。在这个例子中我们选择最简单的方式，即简单通知这两个观察者，因此我们直接继承Subject类即可。此时，完整的调用代码如下：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BlogSubject blog = <span class="keyword">new</span> <span class="type">BlogSubject</span>();</span><br><span class="line">blog.Attach(<span class="keyword">new</span> <span class="type">EmailObserver</span>());</span><br><span class="line">blog.Attach(<span class="keyword">new</span> <span class="type">WechatObserver</span>());</span><br><span class="line">blog.Notify(<span class="string">"Payne更新了Redis缓存技术学习系列文章"</span>);</span><br></pre></td></tr></table></figure></p><p>  好了，现在通过下面的截图，我们就可以看到两个观察者EmailObserver和WechatObserver，都接收到了来自主题Blog的消息推送。这就是观察者模式啦，看起来是不是非常简单。可是相信大家使用公众号以后就会发现一个问题，随着你订阅的内容越来越多，你的微信消息列表里出现的消息推送就越来越多，这个时候如果你不想接收消息推送该怎么办呢？答案好像只有一个，那就是取消订阅。这个场景可以看出”推送模式”让订阅者饱受消息骚扰，而为了解决这个问题，我们就有了”拉取模式”，此时主题仅仅是告诉观察者博客内容有更新，而更新的内容需要观察者自己去处理，这种模式大同小异，大家可以参照”推送模式”来自己实现。</p><p><img src="http://img.blog.csdn.net/20170416170034194" alt="观察者模式基本实例"></p><p>  这些就是观察者模式的核心内容啦，观察者模式的优点是它解除了主题和观察者间的耦合，并且使得这两者各自都依赖于抽象而非具体，观察者模式适用的场景是当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。在C#中我们可以通过委托、事件以及Observable接口这三种方式来更好、更快的实现观察者模式，自然这些都是后话啦，如果以后有机会我们可以继续进行探讨。</p><h2 id="Hey-Redis-Pub-Sub"><a href="#Hey-Redis-Pub-Sub" class="headerlink" title="Hey Redis Pub-Sub"></a>Hey Redis Pub-Sub</h2><p>  好了，了解完观察者模式即发布-订阅模式以后，我们现在就可以开始学习Redis中的发布-订阅模式啦。为什么我们要在开始学习Redis中的发布-订阅模式前，了解设计模式相关的概念呢？这是因为Redis中的发布-订阅模式和Gof设计模式一脉相承，譬如事件机制、消息机制等概念其实都是观察者模式的一种实际应用，一旦我们掌握了观察者模式的核心思想，即使这个世界充满了套路，可是这对你我而言又有什么不同呢？我们学习设计模式不是为了记住这些类图，而是能在最恰当的场景中合理使用这些模式来解决问题，这是我们学习的最终目的。</p><p>  Redis中的发布-订阅模式是一种消息通信模式，即发布者发布消息，订阅者接收消息。在Redis中客户端可以订阅任意个频道，当该频道内接收到一个新消息时，所有订阅该频道的客户端都会收到这条新消息。我们可以这样理解这种消息通信模式，我们每个微信账号都是一个客户端，每个客户端都可以订阅任意个微信公众号，当微信的后台服务上接收到某个微信公众号的请求消息时，所有订阅了该微信公众号的客户端都会收到该推送。一个简单的图示如下：</p><p><img src="http://img.blog.csdn.net/20170416180123359" alt="Redis中的消息模式"></p><p>  </p><p>  我们可以注意到这和我们在文章中提到的”观察者模式”非常相似，在这个通信模式下，客户端作为消息的订阅者，即观察者。而频道作为消息的发布者，即主题。在Redis中频道是一个字符串类型的值，你可以将其理解为一个Id。虽然我们在这篇文章中花费大量时间来讲观察者模式，事实上Redis中的发布-订阅是非常轻量并且强大的，下面是常见的命令：</p><ul><li><p>PSUBSCRIBE：该命令用于订阅一个或者多个符合模式匹配的频道</p></li><li><p>PUBSUB：该命令用于返回由活跃频道组成的列表，即可以查询订阅与发布系统的状态</p></li><li><p>PUBLISH：该命令用于发送消息到指定的频道</p></li><li><p>PUNSUBSCRIBE：该命令用于退订所有符合模式匹配的频道</p></li><li><p>SUBSCRIBE：该命令用于订阅一个或多个频道</p></li><li><p>UNSUBSCRIBE：该命令用于退订一个或多个频道</p></li></ul><p>  以上这些就是和发布-订阅相关的命令啦，从整体上而言它是相当简洁和紧凑的。在这篇文章中我们通篇都在说观察者模式，事实上Redis的发布-订阅从本质上来讲还是观察者模式，Redis内部会维护一个频道的字典，首先它会从频道字典中查找所有的客户端，如果字典中不存在该频道，则将订阅该频道的客户端列表添加到字典中，否则它会返回字典中已经存在的客户端列表。在获取到所有客户端列表以后，Redis将会遍历客户端列表中的客户端，然后给每个客户端发送消息，这部分代码的解读可以参考这篇文章：<a href="http://www.cnblogs.com/huangxincheng/p/5002794.html" target="_blank" rel="noopener">15天玩转redis —— 第九篇 发布/订阅模式</a>。好了，这篇文章暂时就是这样子啦，为什么感觉最近学习Redis没有动力了呢？这篇文章没有实际的命令演示，这是因为我是在Windows系统下写完的这篇文章，深夜啦，睡吧！</p><p>&emsp;&emsp;现在我们一起来看一个简单的示例，在这个示例中我们让两个客户端A和B，订阅同一个频道News，然后由客户端C来向这个频道News广播一条消息，理论上客户端A和客户端B都将会收到这条消息，需要注意此时服务端是开启的。首先，对于客户端A和客户端B，我们在两个不同的终端窗口中打开redis-cli，然后输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> SUBSCRIBE News</span></span><br></pre></td></tr></table></figure><p>在按下回车后，我们可以看到下面的信息：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"News"</span></span><br><span class="line"><span class="number">3</span>) (<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>好了，现在我们在客户端C中来广播一条消息：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">PUBLISH</span> <span class="selector-tag">News</span> "<span class="selector-tag">This</span> <span class="selector-tag">is</span> <span class="selector-tag">a</span> <span class="selector-tag">message</span> <span class="selector-tag">sent</span> <span class="selector-tag">by</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379"</span></span><br></pre></td></tr></table></figure><p>此时我们可以看到下图中所示的结果：</p><p><img src="http://img.blog.csdn.net/20170510224237465" alt="Redis中发布订阅模式"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是&lt;a href=&quot;http://qinyuanpei&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://qinyuanpei.com&lt;/a&gt;。最近这段时间的天气可谓是变幻莫测，常常是周一到周五像夏天般热烈，而周六和周天像秋天般冷清。你不知道它到底会在何时下雨，即使你可以一直带着伞等雨落下来。但是对于没有伞的我来说，学会努力奔跑以至于不那么狼狈，或许是在这个世界上我唯一可以去做的事情。可是你知道一个人孤独的时候，即使是下雨这种再平常不过的事情，他都可以从雨声里听出孤独的感觉来，所以这个周末我决定继续研究Redis缓存技术，而今天我想和大家讨论的话题是Redis中的发布-订阅(Pub-Sub)，希望大家喜欢！&lt;/p&gt;
    
    </summary>
    
      <category term="数据存储" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="Redis" scheme="http://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="缓存" scheme="http://qinyuanpei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="设计模式" scheme="http://qinyuanpei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存技术学习系列之事务处理</title>
    <link href="http://qinyuanpei.github.io/2017/04/08/redis-cache-technology-learning-series-02.html"/>
    <id>http://qinyuanpei.github.io/2017/04/08/redis-cache-technology-learning-series-02.html</id>
    <published>2017-04-08T21:46:40.000Z</published>
    <updated>2017-12-24T08:21:25.721Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在本系列的第一篇文章中，我们主要针对Redis中的“键”和“值”进行了学习。我们可以注意到，Redis是一个C/S架构的数据库，在我们目前的认知中，它是通过终端中的一条条命令来存储和读取的，即它是一个非常典型的“请求-响应”模型。可是我们知道在实际的应用中，我们要面对的或许是更为复杂的业务逻辑，因为Redis中不存在传统关系型数据库中表的概念，因此在使用Redis的过程中，我们要面对两个实际的问题，即如何更好的维护数据库中的”键“、如何在高效执行命令的同时保证命令执行成功。对于前者，我认为这是一个设计上的问题，而对于后者，我认为这是一个技术上的问题。所以，这篇文章的核心内容就是找到这两个问题的答案。带着这样的问题出发，我们就可以正式进入这篇文章的主题：Redis中的事务处理。</p><a id="more"></a><h2 id="从数据库事务说起"><a href="#从数据库事务说起" class="headerlink" title="从数据库事务说起"></a>从数据库事务说起</h2><p>​&emsp;&emsp;通常我们提及数据库都不可避免的要提到事务，那么什么是事务呢？事务是指作为单个逻辑工作单元执行的一系列操作。所以，首先事务是一系列操作，这一系列操作具有二态性，即完全地执行或者完全地不执行。因此事务处理可以确保除非事务单元内的所有操作的成功完成，否则不会永久更新面向数据的资源。我们这里举一个例子，数据库中除查询操作以外，插入(Insert)、删除(Delete)和更新(Update)这三种操作都会对数据造成影响，因为事务处理能够保证一系列操作可以完全地执行或者完全不执行，因此在一个事务被提交以后，该事务中的任何一条SQL语句在被执行的时候，都会生成一条撤销日志(Undo Log)，而撤销日志中记录的是和当前擦作完全相反的操作，比如删除的相反操作是插入，插入的相反操作是删除等。我们通常所说的事务回滚其实就是去执行这些插销日志里的相反操作，这同样告诉我们一个道理，只有事务中的一系列操作完全执行的情况下可以回滚，如果是在意外情况下导致事务中的一系列操作没有完全执行，这个时候我们是不能保证数据一定可以回滚的。</p><p>​&emsp;&emsp;在数据库相关理论中，一个逻辑工作单元想要成为事务，就必须满足ACID，即原子性、一致性、隔离性和持久性。(1)：原子性这个概念其实就是指，一个事务内的所有SQL操作都是一个整体，因此只有所有的SQL操作都完全执行成功，该事务方可以认为提交成功。如果在提交事务过程中某一条SQL语句执行失败，则整个事务必须回滚到事务提交前的状态。(2)：而一致性这个概念则是指，事务在完成的时候，必须要保证所有的数据都保持一致的状态，而落实到数据库的各个组成部分上，则要求开发人员能够保证数据、索引、约束、日志等在事务前后具备一致性。(3)：隔离性这个概念主要针对并发，其核心思想就是不同的并发事务对数据产生的修改必须是相互隔离的，假设有两个不同的事务A和B并发执行，那么对A来讲，它在执行前的状态只有两种，即B执行前和B执行后。同理，对B来讲同样是如此，这样的特性我们就称为隔离性。(4)：持久性相对简单，是指事务完成以后它对数据的影响是永久性的。</p><h2 id="Redis中的事务处理"><a href="#Redis中的事务处理" class="headerlink" title="Redis中的事务处理"></a>Redis中的事务处理</h2><p>​&emsp;&emsp;好了，截止到目前为止，我们对数据库中事务处理的相关理论有了一个基本的认识，或许这个世界上的数据库系统千差万别，但我相信在事务处理这个问题上它们最终会殊途同归，就像我们解决并发过程中的冲突问题，常规的做法依然是加锁一样，这是我之所以要花费精力去理解和解释这些理论知识的原因，技术可谓是日新月异，如果我们总是一味地为新技术而疲于奔命，那么或许我们会渐渐地失去对这个行业的热爱，我相信原理永远比框架更为重要，没有系统学习过计算机专业的课程，这件事情让我至今都颇为遗憾。Redis中的事务是可以视为一个队列，即我们可以通过MULTI开始一个事务，这相当于我们声明了一个命令队列。接下来，我们向Redis中提交的每条命令，都会被排入这个命令队列。当我们输入EXEC命令时，将触发当前事务，这相当于我们从命令队列中取出命令并执行，所以Redis中一个事务从开始到执行会经历<strong>开始事务</strong>、<strong>命令入队</strong>和<strong>执行事务</strong>三个阶段。下面是一个在Redis中使用事务的简单示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">MULTI</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">SET</span> <span class="selector-tag">Book_Name</span> "<span class="selector-tag">GIt</span> <span class="selector-tag">Pro</span>"</span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">SADD</span> <span class="selector-tag">Program_Language</span> "<span class="selector-tag">C</span>++" "<span class="selector-tag">C</span>#" "<span class="selector-tag">Jave</span>" "<span class="selector-tag">Python</span>" </span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">GET</span> <span class="selector-tag">Book_Name</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">EXEC</span></span><br><span class="line">1) <span class="selector-tag">OK</span></span><br><span class="line">2) (<span class="selector-tag">integer</span>) 4</span><br><span class="line">3) "<span class="selector-tag">GIt</span> <span class="selector-tag">Pro</span>"</span><br></pre></td></tr></table></figure><p>我们可以注意到Redis中的事务和通常意义上的事务基本上是一致的，即</p><ul><li>事务是由一系列操作组成的单个逻辑工作执行单元。特别地，因为在Redis中命令是存储在一个队列中，所以，事务中的所有命令都会按顺序执行，并且在执行事务的过程中不会被客户端发送的其它命令中断。</li><li>事务是一个原子操作，事物中的命令只有两种执行结果，即全部执行或者全部不执行。如果客户端在使用MULTI命令开启事务后因为意外而没有执行EXEC命令，则事务中的所有命令都不会执行。同理，如果客户端在使用MULTI命令开启事务后执行EXEC命令，则事务中的所有命令都会执行。</li><li>Redis中的事务可以使用DISCARD命令来清空一个命令队列，并放弃对事务的执行。如果命令在入队时发生错误，Redis将在客户端调用EXEC命令时拒绝执行并取消事务，但是在EXEC命令执行后发生的错误，Redis将选择自动忽略。</li></ul><p>&emsp;&emsp;我们知道，常见的并发控制方案主要有悲观锁和乐观锁两种方案，这里首先来解释下这两种概念。所谓悲观锁，顾名思义是一种悲观的策略，悲观锁认为：在对任何记录做修改前都应该加锁，如果加锁失败则表明该机录正在被修改，此时应该抛出异常；如果加锁成功则修改记录并在事务完成后解锁；如果有其它人修改则应该等待当前修改解锁或者是抛出异常。而所谓乐观锁，顾名思义是一种乐观的策略，乐观锁认为：每次从记录中查找数据别人都不会修改，因此这个过程中不需要加锁，但是在更新记录的时候，会通过版本号来判断别人是否修改过当前记录。</p><p>&emsp;&emsp;通常来讲，乐观锁适合在写冲突相对较少的场合下，悲观锁适合在写冲突相对较多的场合下。Redis中提供了一种称为check-and-set的机制，该机制主要通过WATCH命令来实现，其原理正是基于乐观锁的策略，Redis会在执行EXEC命令前检查被监视的键对应的值是否发生变化，如果该值发生变化表明有人修改过这个键中存储的值，此时Redis将会自动取消当前事务。我们来看这个简单的例子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH Record_Count</span><br><span class="line">val = <span class="builtin-name">GET</span> Record_Count</span><br><span class="line">val = val + 1</span><br><span class="line">MULTI</span><br><span class="line"><span class="builtin-name">SET</span> Record_Count <span class="variable">$val</span></span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个例子中，我们尝试在事务中对Record_Count做一个自增操作，这段代码在非并发的情况下是没有问题的，可是在并发的情况下，如果在执行EXEC命令前有一个用户修改了Record_Count的值，那么我们此时的结果就会比期望的结果小1，现在我们有了WATCH，Redis就会对Record_Count进行监听，当Redis监听到该值发生变化的时候，这个事务就会被自动取消，进而避免造成冲突。</p><h2 id="如何管理Redis的键"><a href="#如何管理Redis的键" class="headerlink" title="如何管理Redis的键"></a>如何管理Redis的键</h2><p>​&emsp;&emsp;其实从切题的角度来讲，这篇博客基本上说清楚了事务处理问题，因此这篇博客虽然没有给大家带来多少惊喜，却依然可以非常恰到好处的结题，可是因为之前有朋友在博客中留言并问到Redis的键管理的问题，所以博主决定在这里简单的讨论下这个问题，鉴于博主和大家一样都是感刚接触Redis，所以下面的观点仅仅是一家之言，如果有疑问可以在博客中留言，欢迎大家批评指正。我认为Redis中的键的管理，基本上有两种策略，即惰性删除和定期删除，而实际上这正是Redis默认的键删除策略：</p><blockquote><p>redis使用<code>惰性删除</code>和<code>定期删除</code>两种策略来删除过期的键：惰性删除策略在碰到过期键时方进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</p></blockquote><p>所以，基于这两种键删除策略，我们可以想到的做法有：</p><ul><li>对于临时变量可以采用临时键来存储，在数据库全局设定一个过期时间，由Redis在键过期后自动删除。</li><li>对于持久化数据可以采用普通键来存储，通过服务器和客户端间定义协议来由客户端主动删除键。</li><li>对于不同模块中的键采取统一规范的命名规则来命名键，从而解决Redis中键管理混乱的问题。</li><li>设计合理的键回收机制，避免Redis使用超过95%以上的内存，或者通过设置Redis中的最大内存容量及其内存策略来主动触发Redis对键的淘汰。具体可以参考：<a href="https://segmentfault.com/a/1190000004171731" target="_blank" rel="noopener">Sunnyxd - Redis学习笔记-事务、键空间的维护与性能</a></li></ul><p>&emsp;&emsp;好了，这篇文章就是这样了，希望大家喜欢，下篇见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在本系列的第一篇文章中，我们主要针对Redis中的“键”和“值”进行了学习。我们可以注意到，Redis是一个C/S架构的数据库，在我们目前的认知中，它是通过终端中的一条条命令来存储和读取的，即它是一个非常典型的“请求-响应”模型。可是我们知道在实际的应用中，我们要面对的或许是更为复杂的业务逻辑，因为Redis中不存在传统关系型数据库中表的概念，因此在使用Redis的过程中，我们要面对两个实际的问题，即如何更好的维护数据库中的”键“、如何在高效执行命令的同时保证命令执行成功。对于前者，我认为这是一个设计上的问题，而对于后者，我认为这是一个技术上的问题。所以，这篇文章的核心内容就是找到这两个问题的答案。带着这样的问题出发，我们就可以正式进入这篇文章的主题：Redis中的事务处理。&lt;/p&gt;
    
    </summary>
    
      <category term="数据存储" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="数据库" scheme="http://qinyuanpei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="缓存" scheme="http://qinyuanpei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>时间如灰烬般遥远</title>
    <link href="http://qinyuanpei.github.io/2017/04/03/I-don-t-like-ashes-of-time.html"/>
    <id>http://qinyuanpei.github.io/2017/04/03/I-don-t-like-ashes-of-time.html</id>
    <published>2017-04-03T00:25:21.000Z</published>
    <updated>2017-12-24T08:21:25.709Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;春天，常常是万物复苏的日子，是以这段时间喜欢去各种地方赏花阅景。相比起三月中旬里裹挟着清冷的青龙寺，此刻到处人山人海的景象，仿佛洋溢着某种热闹的气息。从前读朱自清的《荷塘月色》，一直不明白“热闹是他们的，我什么都没有”这句话该做何解。当你面对梨花胜雪、桃花人面的景致的时候，心中却是如灰烬一般孤独的时候，大概终于明白，为何在熙熙攘攘的人群中会感到一丝清冷，因为唯有行走在人群里的时候，你会发现原来你一个人走了这么久。天地间万事万物更迭交替，本来是自然界中最普通的规则，可是如果每年的这个时候，你都是一个人去看这山山水水，相比时空上的孤寂感，人的孤寂感会更为强烈，“良辰美景奈何天，赏心乐事谁家院”，外面的世界再纷繁多变，对你而言不过是活着的时间。</p><a id="more"></a><p>&emsp;&emsp;我常常像一个淡漠世情的路人，这个世界上发生什么都和我无关，路人纷纷成双入对，而我依然孑然一身，或许这就是我的生活。每天你会和不同的人相处，可每个人都在忙着自己的事情，我们和这个世界息息相关，与此同时，我们和这个世界毫无关联。我记得周五我帮Kent办理离职手续的时候，我一个人从七楼到十三楼再到十六楼，反复地奔波着。同事让他帮忙向公司归还一台笔记本，结果这台笔记本让整个过程都充满了落寞感。部门与部门间的相互推脱，同事与同事间的相互推诿，让我感到从未有过的窒息感：有一群人每天都坐在一起，每个人都看起来在努力工作，然而在你真正需要帮助的时候，你不能完全指望任何一个人。或许这和我外冷内热的性格有关，可是有那么一瞬间，我突然好想离开那个地方。</p><p>&emsp;&emsp;组里的人都走得差不多啦，现下终于剩下我一个人。自此项目上全凭我一个人做主，可对我而言却没有多少欢喜。我还是喜欢和大家在一起，虽然我时常让他们生气，像个孩子一样，可你知道我从来都不是无理取闹的。『射雕英雄传』我看了不下十遍，世人都道东邪黄药师行事乖张、狂傲不羁，可他对妻子冯蘅的深情世间谁人能及，夜夜笙箫相伴墓前，打造花船赴死沧澜，及闻爱女葬身大海，悲痛之际以玉箫扣舷而歌，其深情亦如此。没有人可以一直像个孩子，可以永远都不长大。前段时间看韩寒的电影《乘风破浪》，电影的主题曲从发布就被人吐槽直男癌，其实那仅仅是丈夫在妻子面前“撒娇”的心态，有句话说『在你身边我是个孩子，可你需要了，我就是无坚不摧的勇士』，人人都在说情商如何如何重要，可在真性情面前它的确有点虚伪。</p><p>&emsp;&emsp;Kent是坐周五晚上的火车离开，晚上两个人一块儿吃饭，聊到了家里的琐事，聊到了工作的想法，唯独没有提到离别，大概是我不愿意说起。结账的时候，两个人抢着付钱，老板娘笑着说两个人谁付都是一样的，反正以后还有的是机会。可是未来的事情有谁能够说得准呢？或许期望越高，失望就越大，就像我答应了她许多事情，即使我常常在脑海里想起，她现在都不会在乎了吧。可我总是很怀念那些日子，在这世上有那么一个人，绘画、舞蹈、诗文、书法无所不通，我如果能学会吹奏洞箫，为她跳舞时伴奏一曲可好？人生相识不易，或许不是我不愿意去认识别人，而是我知道知音难觅、知己难求，得不到的永远都是最好的。对Kent来说，他有根可寻，回去是最好的选择。而我则是无根枯蓬，风吹到哪里就在哪里。我知道我再难遇见那样的人，人生与我而言，离别总是常态，孤独是种绝症。</p><p>&emsp;&emsp;或许Kent说得是对的，这个世界上并没有那么多，真正看重技术的公司，这个世界上普通如你我的人，无一不在做着普通的事情。寻找一家新的公司，对目前的我来说，是件极具挑战的事情。虽然邹老师最后帮我推荐了简历，但是对方并没有适合的项目，这种处境既危险而困窘，我不能再像以前一样，我必须让自己拥有自信的生活，一个人如果不能做到爱自己，又怎么能够做到爱别人呢？可她永远不会再出现了，看到路人成双入对的时候，或许爱对我而言是件太困难的事情，佛门有“贪嗔痴”三戒，求而不得是为执，一个人孤零零地在这个城市里，从明天开始，我会经历更多的一个人，一个人吃饭，一个人工作，一个人游曳……长夜听雨，自今日始，你知道一个人数梅花该是何等的寂寞，你就会知道一个人听雨滴下该是何等的孤独，当然这对我而言是没有区别的。</p><p>&emsp;&emsp;有时候会在B站上看以前的影视剧，忽然发现原来一切都已然过去那么久。可当时的心性却不再回复，取而代之的是无限的回想，人生总是如此匆忙的别离，你每天都会认识不同的人，你每天都会错过不同的人，光影恍惚间，一切都仿佛是时间的灰烬爬上了镜子，这像什么呢？或许这就是世事无常，如白云苍狗；或许这就是人生不见，动如参商……时间啊，像极了爬满窗台的灰烬，我却还惦念着窗台外的爬山虎……</p><p>Payne, 于4月3日夜</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;春天，常常是万物复苏的日子，是以这段时间喜欢去各种地方赏花阅景。相比起三月中旬里裹挟着清冷的青龙寺，此刻到处人山人海的景象，仿佛洋溢着某种热闹的气息。从前读朱自清的《荷塘月色》，一直不明白“热闹是他们的，我什么都没有”这句话该做何解。当你面对梨花胜雪、桃花人面的景致的时候，心中却是如灰烬一般孤独的时候，大概终于明白，为何在熙熙攘攘的人群中会感到一丝清冷，因为唯有行走在人群里的时候，你会发现原来你一个人走了这么久。天地间万事万物更迭交替，本来是自然界中最普通的规则，可是如果每年的这个时候，你都是一个人去看这山山水水，相比时空上的孤寂感，人的孤寂感会更为强烈，“良辰美景奈何天，赏心乐事谁家院”，外面的世界再纷繁多变，对你而言不过是活着的时间。&lt;/p&gt;
    
    </summary>
    
      <category term="人生感悟" scheme="http://qinyuanpei.github.io/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="心情" scheme="http://qinyuanpei.github.io/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="孤独" scheme="http://qinyuanpei.github.io/tags/%E5%AD%A4%E7%8B%AC/"/>
    
      <category term="别离" scheme="http://qinyuanpei.github.io/tags/%E5%88%AB%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存技术学习系列之邂逅Redis</title>
    <link href="http://qinyuanpei.github.io/2017/03/30/redis-cache-technology-learning-series-01.html"/>
    <id>http://qinyuanpei.github.io/2017/03/30/redis-cache-technology-learning-series-01.html</id>
    <published>2017-03-30T23:31:40.000Z</published>
    <updated>2017-12-24T08:21:25.721Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;作为一个反主流的开发者，在某种程度上，我对传统关系型数据库一直有点“讨厌”，因为关系型数据库实际上和面向对象思想是完全冲突的，前者建立在数学集合理论的基础上，而后者则是建立在软件工程基本原则的基础上。虽然传统的ORM、序列化/反序列化在一定程度上解决了这种冲突，但是软件开发中关于使用原生SQL语句还是使用ORM框架的争论从来没有停止过。可是实际的业务背景中，是完全无法脱离数据库的，除非在某些特定的场合下，考虑到信息安全因素而禁止开发者使用数据库，在主流技术中数据库是一个非常重要的组成部分。为了弥补这个技术上的短板，从这篇文章开始，我将会学习一个经典的缓存技术：Redis。我们这里将Redis定性为一门缓存技术，这说明Redis和MySQL等主流的数据库存在本质上的区别，那么这些区别到底在哪里呢？或许在看完这个系列文章以后，你心中自然就会有了答案。</p><a id="more"></a><h1 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么?"></a>Redis是什么?</h1><p>&emsp;&emsp;Redis是什么?这是本文第一个问题。Redis是一个开源的使用ANSI C语言编写的、支持网络、 基于内存的、支持持久化的日志型、Key-Value数据库。从如此丰富的修饰语中，我们基本可以抽离出这些信息：</p><ul><li>Redis是一个Key-Value存储系统</li><li>Redis的数据全部缓存在内存里</li><li>Redis可以通过网络实现主从同步</li><li>Redis支持丰富的数据类型可实现持久化</li></ul><p>  那么该如何给Redis一个准确的定义呢？或许这个定义可以帮助我们更好的理解Redis，即Redis是一个高性能的Key-Value数据库。我们知道主流的数据存储方案，可以分为关系型数据库和非关系型数据库两大类。传统的Oracle、MySQL和SQLServer都是关系型数据库，关系型数据库将复杂的数据结构归结为二元关系，即二维表形式，而对数据的操作则建立在一个或多个关系表格中，并通过这些表格间的分类、合并、连接和选取等运算实现数据处理。如同天地万物，有阴影的地方就会有阳光。和关系型数据库相对应的，我们称之为非关系型数据库，这是一个泛指的概念。实际上非关系型数据库，根据设计原理的不同，具体可分为：键-值存储数据库、列存储数据库、文档数据库和图数据库四种。我们通常称非关系型数据库为NoSQL，即”Not Only SQL”，从这个概念我们或许可以明白，SQL和NoSQL并非是完全对立的两个世界，它们各自在其擅长的应用场景中发挥着重要的作用。</p><p>  所以我选择Redis这样一个非关系型数据库，从某种意义上来说，我是想说明一件事情，数据库技术并非绝对代表着关系型数据库和SQL，实际上SQL这门语言存在一定缺陷，就像我们提及Web技术常常想到是如何去做一个网站(MVC)，可你同样会意识到Web API是更为重要的Web技术。这个世界并非是一成不变的，每一天都是新的挑战。</p><h1 id="开始使用Redis"><a href="#开始使用Redis" class="headerlink" title="开始使用Redis"></a>开始使用Redis</h1><p>  好了，在了解了Redis是一个什么东西以后，现在我们来正式开始使用Redis。Redis作为一个开源的键-值数据库，我们可以从它的<a href="https://redis.io/" target="_blank" rel="noopener">官方网站</a>或者是从<a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Github</a>来获取。这里推荐从官方网站下载相对稳定的版本，这里博主选择的是3.2.8版本，需要注意我们这里从官方网站下载的是源代码版本，所以首先第一件事情就是编译源代码。如果你非常擅长在Window下编译类似项目，可以尝试在Windows下进行编译。博主这里推荐大家使用Linux或者MacOS来编译，因为主流开源项目使用的Makefile都是Unix世界里的产物，所以使用Linux或者MacOS能够为我们节省大量的时间。博主这里使用的是Elementary OS这个Linux发行版(对应Ubuntu14)，编译方法如下：</p><h2 id="Redis的编译与安装"><a href="#Redis的编译与安装" class="headerlink" title="Redis的编译与安装"></a>Redis的编译与安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-3.2.8.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-3.2.8.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-3.2.8</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>  在这里，除了make的步骤严格依赖命令行以外，其余的步骤都可以手动完成，所以因为惧怕命令行而不愿意接触Linux的世界，事实证明，对一个真正的程序员来讲，命令行是一个唯一可以让人不被外界所干扰的高效地工具，Git是这个世界上最好没有之一的版本控制工具，如果你喜欢Git，那么你更应该尝试去喜欢Linux。好了，在完成对Redis的编译后，我们就可以开始使用Redis了。Redis是一个C/S架构的键-值数据库，这意味着我们需要Redis的服务端程序和客户端程序。在完成编译以后，我们将得到redis-server和redis-cli这两个内置服务端程序和客户端程序。实际使用中我们会接触到不同语言下的redis客户端，在这里我们直接使用Redis内置的客户端：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启Redis服务</span></span><br><span class="line"><span class="symbol">$</span> src/redis-server</span><br><span class="line"><span class="comment">//开启Redis客户端</span></span><br><span class="line"><span class="symbol">$</span> src/redis-cli</span><br></pre></td></tr></table></figure><p>  需要注意的是在这里服务端和客户端，是在两个不同的终端窗口中运行的，当我们看到下面的窗口时，即表明Redis服务开启就绪，此时我们就可以通过客户端来输入各种命令来完成数据的存取，默认情况下Redis每次会随机分配一个端口，这里Redis采用6379端口进行通信：</p><p><img src="http://img.blog.csdn.net/20170401211921407" alt="Redis服务"></p><p>  Redis是一个采用键-值存储方案的数据库，因而传统关系型数据库里的SQL在这里将不再适用。你可以将Redis理解为一个字典，我们可以向这个字典中储存任何Redis支持的数据类型，并通过键名来获取字典中存储的对应数值。我们来看下面的例子，以下命令均在redis-cli中执行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> foo bar</span><br><span class="line">OK</span><br><span class="line"><span class="builtin-name">GET</span> foo</span><br><span class="line"><span class="string">"bar"</span></span><br></pre></td></tr></table></figure><h2 id="Redis中支持的数据类型"><a href="#Redis中支持的数据类型" class="headerlink" title="Redis中支持的数据类型"></a>Redis中支持的数据类型</h2><p>  这个例子演示了如何在Redis中存储和读取一个简单的字符串类型的值，看起来这一切都非常简单啊，的确Redis就是这样一个简单而高效的键-值数据库。我们在前面提到Redis支持各种各样的数据类型，那么它到底支持哪些数据类型呢？具体来讲，Redis支持5种基本的数据类型：</p><ul><li>字符串(Strings)：最基本的数据类型，使用SET/GET命令来存储和读取字符串类型的值。在Redis中最多可支持512兆字节的字符串长度，这意味着我们可以常见的数据类型序列化后再存储到Redis中。</li><li>散列/哈希(Hashes)：专门用来表示对象的数据类型。散列/哈希是键-值对的集合，可以维系字符串字段和字符串值间的映射关系，因此它主要用来表示对象。在Redis中可以使用HMSET、HMGET、HGET、HGETALL四种命令来存储和读取散列类型的值。</li><li>列表(Lists)：指按照插入顺序排序的字符串元素的集合，特别地，Redis中的列表是采用链表实现的，因为对数据库系统而言，一个非常重要的特性是可以支持在含有大量元素的集合中快速添加元素。常见的应用于列表的命令主要有LPUSH、RPUSH、LPOP、RPOP和LRANGE。</li><li>集合(Sets)：指不重复且无序的字符串元素的集合。针对列表，常见的命令主要有：SADD、SPOP、SCARD、SMEMBERS和SISMEMBER。例如SADD命令可以向集合中添加元素，SPOP命令可以从集合中删除元素，SCARD命令可以返回集合内元素个数，SMERMERS命令可以枚举集合的所有元素，SISMEMBER命令可以判断指定元素是否在指定集合内。</li><li>有序集合(Sorted Sets)：有序集合与集合相似，不同点在于集合中的每一个元素都会关联一个浮点型的数值，该数值称为score，事实上Redis正是根据score来对集合内的元素进行排序的。集合内的元素是不允许重复的，但是score是可以允许重复的。常见的命令有：ZADD、ZCARD、ZCOUNT、ZREM、ZSCORE等。</li></ul><h2 id="Redis中和键有关的命令"><a href="#Redis中和键有关的命令" class="headerlink" title="Redis中和键有关的命令"></a>Redis中和键有关的命令</h2><p>  我们知道Redis是一个键-值数据库，所以在了解了Redis中支持的数据类型，即“值”以后，现在让我们将关注点回归到“键”上面来，这是因为作为一个键-值数据库，键是我们从数据库中获取值的唯一方式，因此在这里说说Redis中那些和键有关的命令，这些命令基本都遵循下面的命名格式，常见的命令有：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">COMMAND</span> KEY_NAME</span><br></pre></td></tr></table></figure><ul><li>DEL：该命令将在键名存在时从数据库中删除指定键，成功则返回1，否则返回0。</li><li>DUMP：该命令将序列化指定键，并返回被序列化的值。</li><li>EXISTS：该命令用以判断指定键是否存在。</li><li>EXPIRE：该命令用以给指定键设置过期时间。</li><li>KEYS：该命令用以返回所有满足匹配模式的键。</li><li>PERSIST：该命令用以移除指定键的过期时间。</li><li>RENAME：该命令用以重命名指定键。</li></ul><p>​        好了，这就是这篇博客的内容了，自我感觉Redis中的内容相对分散，这种细小的知识点都隐藏在命令中，最初在介绍不同的数据类型的时候，在文章中均做了详细的介绍并辅以终端脚本，可是最后发现这样写下去还不如去看官方文档，像Redis这种即使学习了都不见得有机会使用的技术，当然我并不是说Redis不好啊，关系型数据库目前依然是主流的技术驱动力量，所以我觉得我们学习的时候最好是“观其大略”、“不求甚解”，首先注重整体知识体系上的理解，微枝末叶上的细节问题可以在使用的时候去查阅文档。在下面的文章中，我重点关注的内容是Redis的<strong>事务</strong>、<strong>脚本</strong>、<strong>发布/订阅</strong>及<strong>不同语言下Redis的使用</strong>，希望大家继续关注我的博客，本篇结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;作为一个反主流的开发者，在某种程度上，我对传统关系型数据库一直有点“讨厌”，因为关系型数据库实际上和面向对象思想是完全冲突的，前者建立在数学集合理论的基础上，而后者则是建立在软件工程基本原则的基础上。虽然传统的ORM、序列化/反序列化在一定程度上解决了这种冲突，但是软件开发中关于使用原生SQL语句还是使用ORM框架的争论从来没有停止过。可是实际的业务背景中，是完全无法脱离数据库的，除非在某些特定的场合下，考虑到信息安全因素而禁止开发者使用数据库，在主流技术中数据库是一个非常重要的组成部分。为了弥补这个技术上的短板，从这篇文章开始，我将会学习一个经典的缓存技术：Redis。我们这里将Redis定性为一门缓存技术，这说明Redis和MySQL等主流的数据库存在本质上的区别，那么这些区别到底在哪里呢？或许在看完这个系列文章以后，你心中自然就会有了答案。&lt;/p&gt;
    
    </summary>
    
      <category term="数据存储" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="数据库" scheme="http://qinyuanpei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="缓存" scheme="http://qinyuanpei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>使用C#开发HTTP服务器之支持HTTPS</title>
    <link href="http://qinyuanpei.github.io/2017/03/05/make-a-http-server-with-csharp-06.html"/>
    <id>http://qinyuanpei.github.io/2017/03/05/make-a-http-server-with-csharp-06.html</id>
    <published>2017-03-05T14:01:39.000Z</published>
    <updated>2017-12-24T08:21:25.717Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是<a href="http://qinyuanpei.com" target="_blank" rel="noopener">http://qinyuanpei.com</a>。本文是“使用C#开发HTTP服务器”系列的第六篇文章，在这个系列文章中我们实现了一个基础的Web服务器，它支持从本地读取静态HTML页面，支持GET和POST 两种请求方式。该项目托管在我的<a href="https://github.com/qinyuanpei" target="_blank" rel="noopener">Github</a>上，项目地址为<a href="https://github.com/qinyuanpei/HttpServer" target="_blank" rel="noopener">https://github.com/qinyuanpei/HttpServer</a>，感兴趣的朋友可以前往了解。其间有朋友为我提供了HTTPS的PR，或许这偏离了这个系列开发HTTP服务器的初衷，可是我们应该认识到普及HTTPS是大势所趋。所以在今天这篇文章中，我将为大家带来HTTPS相关知识的普及，以及如何为我们的这个Web服务器增加HTTPS的支持。</p><a id="more"></a><p>&emsp;&emsp;2017年我们听到这样一个声音，苹果将强制实施ATS，即App Transport Security。首先我们要了解的是ATS，它是苹果为了保证应用数据在网络中安全地传输而制定的一种规则，其核心是鼓励开发者使用安全的HTTPS协议和服务器进行通讯。在此之前考虑到大量的应用还在使用HTTP协议，所以苹果并未强制要求应用遵守这个规范，而此时苹果发出这样一种声音，我们终于意识到苹果这是在推广HTTPS啊！无独有偶，同样作为科技巨头之一的Google，宣布在新发布的Chrome 56中会将仅支持HTTP协议的网页标记为“不安全”。HTTPS到底是什么呢？为什么科技巨头纷纷开始对它青眼有加呢？这或许要从HTTPS协议说起。</p><p>&emsp;&emsp;HTTPS，即Hyper Text Transfer Protocol Over Secure Socket Layer的简称，是指以安全为目标的HTTP协议。我们可以将其理解为在HTTP协议的基础上增加了安全机制，这里的安全机制是指SSL,简单来讲HTTPS协议依然采用HTTP协议，不过它在HTTP和TCP间增加了加密/身份验证层，因此在保证数据传输安全的同时，为服务器提供了身份校验机制。任何采用HTTPS协议的网站，均可通过浏览器地址栏中的“锁”标志来查看网站的认证信息，或者是通过CA机构颁发的数字证书来查询。下图展示的是HTTPS协议中客户端和服务器端通信过程：</p><p><img src="http://img.blog.csdn.net/20170305153733865" alt="HTTPS协议中客户端和服务器通信过程"></p><p>从图中我们可以看出，在HTTPS协议中客户端和服务器端分为六步：</p><ul><li>客户端请求服务器，发送握手消息给服务器。</li><li>服务器端返回客户端加密算法、数字证书和公钥。</li><li>客户端对返回的数字证书进行验证，如果验证通过则产生一个随机数，否则提示验证失败。</li><li>客户端使用公钥对产生的随机数进行加密，然后将其发送给服务器端。</li><li>服务器对该随机数进行解密，并以此作为密钥发送握手信息给客户端。</li><li>客户端收到消息后对消息进行解密，如果解密成功则表示握手结束。</li></ul><p>&emsp;&emsp;这恰恰印证了我们最初的观点，即HTTPS协议依然采用HTTP协议(三次握手)进行通讯，不同的地方在于中间环节增加了加密处理，例如在客户端和服务器端相互验证的环节采用的是非对称加密，在客户端验证通过以后双方采用随机数作为密钥是对称加密，而三次握手以后验证消息是否被篡改则是采用HASH算法。所以我们应该可以注意到，HTTP协议和HTTPS协议的一个显著的区别是，前者采用明文来传输消息，而后者采用密文来传输消息，因此HTTPS协议比HTTP协议在通讯上更为安全。而详细来说，两者的区别主要有：</p><ul><li>HTTPS需要证书，而HTTP则不需要证书，证书由CA机构颁发。</li><li>HTTP采用明文来传输消息，C/S端无身份验证；HTTPS采用密文来传输消息，C/S端有身份验证。</li><li>HTTP默认采用80端口进行通信，而HTTPS默认采用443端口进行通信。</li></ul><p>&emsp;&emsp;好了，现在我们对HTTPS协议有了一个基本的认识：HTTPS协议相比HTTP协议增加了身份验证和消息加密的机制，因此HTTPS协议能够保证通讯过程中的数据传输安全。在今天这样一个数字时代，当个人隐私安全彻底地暴露在浏览器、应用程序面前，能够提供更安全的互联网服务无疑会让人更有安全感，我想这是苹果和谷歌这样的科技巨头公司，之所以要去努力推广HTTPS协议的原因吧！因为客户端需要对服务器的证书进行验证，所以这意味着在客户端拥有访问所有受信证书的能力，例如我们在使用传统网银产品时都需要安装网银证书，这其实就是为了让客户端在向服务器端发起请求时方便对服务器进行验证，因此如果客户端请求的URL遭遇劫持，被重定向到某个不被信任的站点上，那么客户端发起的请求就会被拦截。同样的道理，服务器端会对客户端的请求进行验证，所以这里就不再详细展开去说啦。</p><p>&emsp;&emsp;我们最初设计这个HTTP服务器的时候，没有考虑过要支持HTTPS协议。可是当我们了解了HTTPS协议后，我们发现，如果要让最初设计的Web服务器支持HTTPS协议，我们需要关注的是Security，即身份验证和数据加密，我们知道这里的Security指的是SSL，所以需要了解SSL相关的内容。其次，我们需要提供一个数字证书给服务器端，目的是在客户端发起请求的时候，将数字证书、加密算法和公钥返回，保证客户端可以完成证书校验。从这两点可以看出，我们首先需要从CA机构购买证书，这一点毋庸置疑。关于证书的购买及服务器的设置，我们通过搜索引擎可以找到相关参考。目前主流的服务器如Apache、IIS、Tomcat和Ngnix都可以非常方便地支持HTTPS，这些问题更像是一种基础设施，所以我会在文章末尾列举出相关文章供大家查阅。</p><p>&emsp;&emsp;这篇文章的核心是开发一个服务器，所以在保证这些基础设施完备的前提下，让我们将关注点落实到代码上面来。我们提到，HTTPS除了证书以外关键点是SSL，而在.NET中提供SSL相关的API，所以这里我们直接使用这些API就可以完成证书的创建、加载等工作。下面是相关的代码示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用OpenSSL.NET生成密钥</span></span><br><span class="line">RSA rsa = <span class="keyword">new</span> <span class="type">RSA</span>();</span><br><span class="line">BigNumber number = OpenSSL.Core.Random.Next(<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">rsa.GenerateKeys(<span class="number">1024</span>, number, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">CryptoKey key = <span class="keyword">new</span> <span class="type">CryptoKey</span>(rsa);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建X509证书，Subject和Issuer相同 </span></span><br><span class="line">X509Certificate x509 = <span class="keyword">new</span> <span class="type">X509Certificate</span>();</span><br><span class="line">x509.SerialNumber = (int)DateTime.Now.Ticks;</span><br><span class="line">x509.Subject = <span class="keyword">new</span> <span class="type">X509Name</span>(<span class="string">"CN=DOMAIN"</span>);        <span class="comment">//DOMAIN为站点域名 </span></span><br><span class="line">x509.Issuer = <span class="keyword">new</span> <span class="type">X509Name</span>(<span class="string">"CN=DOMAIN"</span>);</span><br><span class="line">x509.PublicKey = key;                            <span class="comment">//指定公钥 </span></span><br><span class="line">x509.NotBefore = Convert.ToDateTime(<span class="string">"2011-1-1"</span>); <span class="comment">//起始时间 </span></span><br><span class="line">x509.NotAfter = Convert.ToDateTime(<span class="string">"2050-1-1"</span>);  <span class="comment">//失效时间 </span></span><br><span class="line">x509.Version = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用私钥签名</span></span><br><span class="line">x509.Sign(key, MessageDigest.MD5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成CRT证书</span></span><br><span class="line">BIO x509bio = BIO.File(<span class="string">"CA.crt"</span>, <span class="string">"w"</span>);</span><br><span class="line">x509.Write(x509bio);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成PFX证书</span></span><br><span class="line"><span class="keyword">var</span> certs = <span class="keyword">new</span> <span class="type">OpenSSL</span>.Core.Stack&lt;X509Certificate&gt;();</span><br><span class="line">PKCS12 p12 = <span class="keyword">new</span> <span class="type">PKCS12</span>(<span class="string">"PASSWORD"</span>, key, x509, certs); <span class="comment">//PASSWORD为保护密钥 </span></span><br><span class="line">BIO p12Bio = BIO.File(<span class="string">"CA.pfx"</span>, <span class="string">"w"</span>);</span><br><span class="line">p12.Write(p12Bio);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载证书</span></span><br><span class="line"><span class="keyword">var</span> certifiate = X509Certificate.CreateFromCertFile(<span class="string">"CA.crt"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我们获得证书以后，我们就可以通过SSL对Socket通信过程中传递的消息进行加密了，一个基本的示例代码如下：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SslStream sslStream = <span class="keyword">new</span> <span class="type">SslStream</span>(clientStream);</span><br><span class="line">sslStream.AuthenticateAsServer(serverCertificate, <span class="literal">false</span>, SslProtocols.Tls, <span class="literal">true</span>);</span><br><span class="line">sslStream.ReadTimeout = <span class="number">10000</span>;</span><br><span class="line">sslStream.WriteTimeout = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">return</span> sslStream;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;个人感觉加密相关的问题深奥而晦涩，这篇文章中涉及到的相关概念和技术，都大大地超出了我目前的认知范围。不过既然这位朋友热心地提交了这个PR，我就将这个过程视为向别人的一次学习吧！我会继续去完善这个项目：<a href="https://github.com/qinyuanpei/HttpServer" target="_blank" rel="noopener">https://github.com/qinyuanpei/HttpServer</a>。这篇博客终于算是写完了，周末开心！</p><p><strong> 参考文章 </strong></p><ul><li><a href="http://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="noopener">Zery - HTTPS原理解析</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">阮一峰 - SSL/TLS协议运行机制的概述</a></li><li><a href="https://zh.wikipedia.org/zh-hans/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">维基百科 - 超文本传输安全协议</a></li><li><a href="https://cattail.me/tech/2015/11/30/how-https-works.html" target="_blank" rel="noopener">猫尾博客 - HTTPS工作原理</a></li><li><a href="https://support.microsoft.com/zh-cn/help/324069/how-to-set-up-an-https-service-in-iis" target="_blank" rel="noopener">MSDN - 如何在 IIS 中设置 HTTPS 服务</a></li><li><a href="http://www.cnblogs.com/dudu/p/iis_https_ca.html" target="_blank" rel="noopener">Dudu - 给IIS添加CA证书以支持https</a></li><li><a href="http://www.cnblogs.com/liaojiafa/p/6028816.html" target="_blank" rel="noopener">温柔易淡 - Apache配置HTTPS功能</a></li><li><a href="http://www.cnblogs.com/wanghaoyuhappy/p/5267702.html" target="_blank" rel="noopener">王浩宇 - 配置Tomcat使用https协议</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;各位朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是&lt;a href=&quot;http://qinyuanpei.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://qinyuanpei.com&lt;/a&gt;。本文是“使用C#开发HTTP服务器”系列的第六篇文章，在这个系列文章中我们实现了一个基础的Web服务器，它支持从本地读取静态HTML页面，支持GET和POST 两种请求方式。该项目托管在我的&lt;a href=&quot;https://github.com/qinyuanpei&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;上，项目地址为&lt;a href=&quot;https://github.com/qinyuanpei/HttpServer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/qinyuanpei/HttpServer&lt;/a&gt;，感兴趣的朋友可以前往了解。其间有朋友为我提供了HTTPS的PR，或许这偏离了这个系列开发HTTP服务器的初衷，可是我们应该认识到普及HTTPS是大势所趋。所以在今天这篇文章中，我将为大家带来HTTPS相关知识的普及，以及如何为我们的这个Web服务器增加HTTPS的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C#" scheme="http://qinyuanpei.github.io/tags/C/"/>
    
      <category term="HTTP" scheme="http://qinyuanpei.github.io/tags/HTTP/"/>
    
      <category term="服务器" scheme="http://qinyuanpei.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>愿浮萍乘风破浪</title>
    <link href="http://qinyuanpei.github.io/2017/02/04/a-movie-called-duckweed.html"/>
    <id>http://qinyuanpei.github.io/2017/02/04/a-movie-called-duckweed.html</id>
    <published>2017-02-04T22:31:33.000Z</published>
    <updated>2017-12-24T08:21:25.709Z</updated>
    
    <content type="html"><![CDATA[<embed src="//music.163.com/style/swf/widget.swf?sid=456185374&type=2&auto=1&width=320&height=66" width="340" height="86" allownetworking="all"><p>   或许是今年的贺岁档电影全部遭遇“滑铁卢”的缘故，在这种情况下，电影《乘风破浪》或许会成为拯救整个贺一个岁档的奇迹。同往常一样，我依然选择一个人去看电影，而庆幸的是韩寒真的没有让我们失望。虽然前期在微博上经常看到韩寒在为这部电影做宣传，但我一直想知道它会一种什么样的方式来讲述这个故事，我隐隐约约觉得徐太浪(邓超饰)、徐正太(彭于晏饰)、小花(赵丽颖饰)三个人之间的关系非同寻常，我甚至臆想这是一部俗套的三角恋的故事。可结果却是完全出人意料的，我很喜欢这个故事。</p><a id="more"></a><p>&emsp;&emsp;首先，电影一开头就项我们展示了一个非常常见的矛盾冲突，从小喜欢赛车的儿子徐太浪和坚决反对儿子以赛车作为职业的父亲徐正太。我们从小到大或许都会有这样的经历，我们曾经执著地喜欢过什么或是热爱过什么，可这种喜欢在父母眼中常常被视为叛逆。我大学四年里最反感的一件事情就是我的本科专业，我一直很喜欢计算机技术，确切地说是通过编程来理解这个世界，可是因为我高考成绩并不理想，当时在父亲的建议下选择了一个我不喜欢的专业，在这四年里我做过最多的事情，就是极力想要摆脱这个专业。我从那个时候开始将编程视为我主要的兴趣，我从大学时候就开始研究自己感兴趣的技术，开始在技术社区里撰写博客。</p><p>&emsp;&emsp;这段经历让我至今都难以忘怀，这件事情教会我一个道理，当你认准去做一件事情的时候，其实没有任何一个人可以左右你的选择，2016年上半年我经历了一段时间的失业。虽然周围人都在告诉我，考公务员或者选择我本专业或许会比我的选择更为光明，但那个时候我一直找不到喜欢的工作，我常常在心里问我自己：难道我注定不能去做我喜欢的事情吗？后来我独自一个人来到西安，我畏惧逃离北上广的那种无力感和孤独感，可其实一个人在西安同样是孤独的。父母自然是为了我们好，可这种两代人的矛盾不管什么时候都会持续下去，当徐太浪面对着镜头大声说出那些压抑在心底的话的时候，我们所看到的那个懦弱而苍老的父亲，或许在每个人身上都可以找到影子吧！</p><p>&emsp;&emsp;或许是因为太想在父亲面前证明自己，所以当徐太浪取得赛车比赛冠军时，他迫不及待地让父亲坐在自己的副驾驶位上，一如电影开头那呼啸而过的一抹车影，当赛车穿过蜿蜒的山路、穿过废旧的城镇，在恍惚间我好像看到了，在《平凡之路》中一直蔓延着的无尽的长路，当镜头和画面频繁切换着，你以为是时间穿越了历史，其实时间就静止在那里，我们所看到的不过是那些转瞬即逝的风景，所听到的不过是那些呼啸而过的风声。我特别喜欢徐太浪的赛车与货车擦肩而过时，一切变得支离破碎的那组慢镜头，它就像一层层地褪去外表华丽的油漆，直接让斑驳的纹理一点点地裸露出来，当车窗玻璃破碎并跌落在空气里，当庆祝成功的香槟和奖杯混杂在空气里。或许此时此刻所有的一切都不再重要了吧，我们说洗去铅华返璞归真，大概只有在这种情况下，当我们的灵魂完全变得纯净的时候，或许穿越这种影视表现手法才会真正起作用，我们注意到徐太浪在医院病床上醒来的时候，眼角是带着泪水的，所以对这个电影里所叙述的故事，我宁愿将其当作是徐太浪的一个梦吧！他因为从小没有见过母亲，所以想要努力知道母亲长什么样子，在死亡边缘成为了他的一种执念。影片为了刻意制造笑点，让徐太浪身上多了许多“穿越”的特质，其实对观众而言这仅仅是一种代入的符号，换句话说，“穿越”以后的这个人是不是徐太浪本身已经不再重要了，重要的是我们通过这个人了解了整个故事。</p><p>&emsp;&emsp;整个故事其实是一个解惑的过程，所有的线索都是为了让徐太浪明白，自己的父亲为什么会变成这个样子，而围绕这些线索，整理的冲突发生在以徐正太、六一、阿浪、小马为代表的“正太帮”和黄志强、罗力为代表的“黑社会”，双方的利益冲突交织在一间歌舞厅。我们知道徐正太的一个梦想是“歌舞厅里只唱歌，桑拿房里就洗澡”，而这是一种近乎乌托邦的存在，所以年轻的徐正太有理想和抱负，想成为杜月笙那样的老大，而这一切的初衷是为了让自己的妻子做歌舞厅的老板娘。而通过阿浪夜寻小花这个事情，我们同时知道，徐正太是一个可以因为朋友一句话就等对方一个晚上的人，这说明他是一个守信用的人，而导致徐正太坐牢的直接原因是他为朋友六一报仇，这是一个重义气的表现，那么他的局限性在哪里呢？他认为录像厅比电影院有前途，就大量购买录像带；他认为BP机代表了通信行业的未来，就大量囤积BP机。所以这个时候我们就会明白，他后来会对阿浪采取“棍棒教育”，其实是因为他的眼界就局限在这里，他在对待新事物上存在局限性，所以看不到世界的变化，他在天台上说的那句“世界是不会变的”就是最好的证明。六一代表了那种并不聪明但愿意为朋友两肋插刀的“傻气”，小马则代表了那种愿意去追逐梦想的“执着”，当OICQ这个名字从他口中说出来的时候，我就知道这个人的一生都将注定不平凡。黄志强代表的是商业利益既得者，而罗力则代表的是失去一切后迷途知返的回头浪子。</p><p>&emsp;&emsp;如果说男人们的故事都是这般粗犷的话，那么这部电影里女性角色则显得细腻。首先从小花说起，小花和阿浪一样，都是对自己的父亲怀有敌意的，因为作为飞行员的父亲舍弃了和家人在一起的时间，投入全部身心到飞行事业上去，以至于在她婚礼的时候，父亲都没有来参加。影片中一个细节是，最后徐正太和阿浪杀死黄志强以后，怀有身孕的小花匆匆赶来，将满身血污的徐正太紧紧抱在怀里，小花说徐正太有时候像个孩子，其实男人都会有像孩子的一面，所以小花其实代表的是一种母性的关怀吧！值得一提的是电影里佳怡和松子这个女性角色，虽然六一喜欢佳怡，可依琳说她有喜欢的人的时候，他默默地选择放手，即使他心里依然有她，而最终六一躺在太平间里，此时陪伴在他身边的，不过是哭成泪人地佳怡和那条巡回犬，大概我们都习惯了忽视身边人的爱吧，从父母到伴侣，影片中正太和小花从四岁结识从始自终，这大概就足以令人唏嘘了吧。顶风作案的罗力，承诺要给松子一方天地，然而等他从狱中出来，见到的却是坐在黄志强车上神色复杂的那个人，你说这个世界是会变的，可它会变成什么样我们永远无从得知，小马希望的是那个拨号上网频频掉线的时代诞生一款OICQ的软件，徐正太希望的是像杜月笙那样收“物业费”……我们期望着什么，我们等待着什么，其实都不重要，世界一直都在变化，而我们如浮萍，或随风漂泊，或乘风破浪，一切都在我们的选择。</p><p>&emsp;&emsp;电影结尾，阿浪和正太在同一个平行宇宙，一如影片开始，两个人坐在同一辆车上一样，阿浪问正太：“你的车技这么好是跟谁学的？”，正太回答：“天赋来的”。同样，正太问了阿浪相同的问题，阿浪说：“遗传来的”。其实到这里，我们看到的是父子间真正的握手言和，最终两个人互相理解了对方，电影开头两个人的矛盾冲突，以这样一种形式化解，是件让人欣慰的事情，如果那些被时代抛弃的BP机，或许你我都不再认同它们的价值，但那曾是父母眼中给我们的最好的爱，世界每天都在变化，而起风了，唯有努力生存。</p>]]></content>
    
    <summary type="html">
    
      &lt;embed src=&quot;//music.163.com/style/swf/widget.swf?sid=456185374&amp;type=2&amp;auto=1&amp;width=320&amp;height=66&quot; width=&quot;340&quot; height=&quot;86&quot; allownetworking=&quot;all&quot;&gt;

&lt;p&gt;   或许是今年的贺岁档电影全部遭遇“滑铁卢”的缘故，在这种情况下，电影《乘风破浪》或许会成为拯救整个贺一个岁档的奇迹。同往常一样，我依然选择一个人去看电影，而庆幸的是韩寒真的没有让我们失望。虽然前期在微博上经常看到韩寒在为这部电影做宣传，但我一直想知道它会一种什么样的方式来讲述这个故事，我隐隐约约觉得徐太浪(邓超饰)、徐正太(彭于晏饰)、小花(赵丽颖饰)三个人之间的关系非同寻常，我甚至臆想这是一部俗套的三角恋的故事。可结果却是完全出人意料的，我很喜欢这个故事。&lt;/p&gt;
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="韩寒" scheme="http://qinyuanpei.github.io/tags/%E9%9F%A9%E5%AF%92/"/>
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="青春" scheme="http://qinyuanpei.github.io/tags/%E9%9D%92%E6%98%A5/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程常用术语</title>
    <link href="http://qinyuanpei.github.io/2017/02/02/functional-programming-terminology.html"/>
    <id>http://qinyuanpei.github.io/2017/02/02/functional-programming-terminology.html</id>
    <published>2017-02-02T19:21:12.000Z</published>
    <updated>2017-12-24T08:21:25.717Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;近年来函数式编程这种概念渐渐流行起来，尤其是在React/Vuejs这两个前端框架的推动下，函数式编程就像股新思潮一般瞬间席卷整个技术圈。虽然博主接触到的前端技术并不算深入，可这并不妨碍我们通过类似概念的延伸来理解这种概念。首先，函数式编程是一种编程范式，而我们所熟悉的常见编程范式则有<strong>命令式编程(Imperative Programmming)</strong>、<strong>函数式编程(Functional Programming)</strong>、<strong>逻辑式编程(Logic Programming)</strong>、<strong>声明式编程(Declarative Programming)</strong>和<strong>响应式编程(Reactive Programming)</strong>等。现代编程语言  在发展过程中实际上都在借鉴不同的编程范式，比如Lisp和Haskell  是最经典的函数式编程语言，而SmartTalk、C++和Java则是最经典的命令式编程语言。微软的C#语言最早主要借鉴Java语言，在其引入lambda和LINQ特性以后，使得C#开始具备实施函数式编程的基础，而最新的Java8同样开始强化lambda这一特性，为什么lambda会如此重要呢？这或许要从函数式编程的基本术语开始说起。</p><a id="more"></a><h1 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h1><p>&emsp;&emsp;我们提到函数式编程是一种编程范式，它的基本思想是将计算机运算当作是数学中的函数，同时避免了状态和变量的概念。一个直观的理解是，在函数式编程中面向数据，函数是第一等公民，而我们传统的命令式编程中面向过程，类是第一等公民。为什么我们反复提到lambda呢？因为函数式编程中最重要的基础是lambda演算(Lambda Calculus)，并且lambda演算的函数可以接受函数作为参数和返回值，这听起来和数学有关，的确函数式编程是面向数学的抽象，任何计算机运算在这里都被抽象为表达式求值，简而言之，函数式程序即为一个表达式。值得一提的是，函数式编程是图灵完备的，这再次说明数学和计算机技术是紧密联系在一起的。虽然在博主心目中认为，图灵这位天纵英才的英国数学家，是真正的计算机鼻祖，但历史从来都喜欢开玩笑的，因为现代计算机是以冯.诺依曼体系为基础的，而这一体系天生就是面向过程即命令式的，在这套体系下计算机的运算实则是硬件的一种抽象，命令式程序实际上是一组指令集。因此，函数式程序目前依然需要编译为该体系下的计算机指令来执行，这听起来略显遗憾，可这对我们来说并不重要，下面让我们来一窥函数式编程的真容：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squares = map(lambda <span class="keyword">x</span>: <span class="keyword">x</span> * <span class="keyword">x</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  </span><br><span class="line">print squares</span><br></pre></td></tr></table></figure><p>这是使用Python编写的函数式编程风格的代码，或许看到这样的代码，我们内心是完全崩溃的，可是它实现得其实是这样一个功能，即将集合{0, 1, 2, 3, 4}中的每个元素进行平方操作，然后返回一个新的集合。如果使用命令式编程，我们注定无法使用如此简单的代码实现这个功能。而这个功能在.NET中其实是一个Select的功能：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[]<span class="built_in"> array </span>=<span class="built_in"> new </span>int[]&#123;0, 1, 2, 3, 4&#125;;</span><br><span class="line">int[] result = array.Select(m =&gt; m * m).ToArray();</span><br></pre></td></tr></table></figure><p>这就是函数式编程的魅力，我们所做的事情都是由一个个函数来完成的，这个函数定义了输入和输出，而我们只需要将数据作为参数传递给函数，函数会返回我们期望的结果。好了，下面再看一个例子：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = reduce(lambda <span class="keyword">a</span>, x: <span class="keyword">a</span> + x, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><p>即使我们从来没有了解过函数式编程，从命名我们依然可以看出这是一个对集合中的元素求和的功能实现，这就是规范命名的重要性。幸运的是.NET中同样有类似的扩展方法，我喜欢Linq，我喜欢lambda：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[]<span class="built_in"> array </span>=<span class="built_in"> new </span>int[]&#123;0, 1, 2, 3, 4&#125;;</span><br><span class="line">int result = array.Sum();</span><br></pre></td></tr></table></figure><p>考虑到博主写不出更复杂的函数式编程的代码示例，这里不再列举更多的函数式编程风格的代码，可是我们从直观上来理解函数式编程，就会发现函数式编程同lambda密不可分，函数在这里扮演着重要的角色。好了，下面我们来了解下函数式编程中的常用术语。</p><h1 id="函数式编程的常用术语"><a href="#函数式编程的常用术语" class="headerlink" title="函数式编程的常用术语"></a>函数式编程的常用术语</h1><p>&emsp;&emsp;函数式编程首先是一种编程范式，这意味着它和面向对象编程一样，都是一种编程的思想。而函数式编程最基本的两个特性就是不可变数据和表达式求值。基于两个基础特性，我们延伸出了各种函数式编程的相关概念，而这些概念就是函数式编程的常用术语。常用的函数式编程术语有高阶函数、柯里化/局部调用、惰性求值，递归等。在了解这些概念前，我们先来理解，什么是函数式编程的不可变性。不可变性，意味着在函数式编程中没有变量的概念，即操作不会改变原有的值而是修改新产生的值。举一个基本的例子，.NET中IEnumerable<t>接口提供了大量的如Select、Where等扩展方法，而这些扩展方法同样会返回IEnumerable<t>类型，并且这些扩展方法不会改变原来的集合，所有的修改都是作用在一个新的集合上，这就是函数式编程的不可变性。实现不可变性的前提是纯函数，即函数不会产生副作用。一个更为生动的例子是，如果我们尝试对一个由匿名类型组成的集合进行修改，会被提示该匿名类型的属性为只读属性，这意味着数据是不可改变的，如果我们要坚持对数据进行“修改”，唯一的方法就是调用一个函数。</t></t></p><h2 id="高阶函数-Higer-Order-Function"><a href="#高阶函数-Higer-Order-Function" class="headerlink" title="高阶函数(Higer-Order-Function)"></a>高阶函数(Higer-Order-Function)</h2><p>&emsp;&emsp;高阶函数是指函数自身能够接受函数，并返回函数的一种函数。这个概念听起来好像非常复杂的样子，其实在我们使用Linq的时候，我们就是在使用高阶函数啦。这里介绍三个非常有名的高阶函数，即Map、Filter和Fold，这三个函数在Linq中分别对应于Select、Where和Sum。我们可以通过下面的例子来理解：</p><ul><li><p>Map函数需要一个元素集合和一个访问该元素集合中每一个元素的函数，该函数将生成一个新的元素集合，并返回这个新的元素集合。通过C#中的迭代器可以惰性实现Map函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IEnumerable</span>&lt;<span class="type">R</span>&gt; <span class="type">Map</span>&lt;<span class="type">T</span>,<span class="type">R</span>&gt;(<span class="type">Func</span>&lt;<span class="type">T</span>,<span class="type">R</span>&gt; <span class="function"><span class="keyword">func</span>, <span class="title">IEnumerable</span>&lt;T&gt; <span class="title">list</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">foreach(<span class="type">T</span> item <span class="keyword">in</span> list)</span><br><span class="line">yield <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(item)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Filter函数需要一个元素集合和一个筛选该元素结合的函数，该函数将从原始元素集合中筛选中符合条件的元素，然后组成一个新的元素集合，并返回这个新的元素集合。通过C#中的Predicate<t>委托类型，我们可以写出下面的代码：</t></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;T&gt; Filter&lt;T&gt;(Predicate&lt;T&gt; predicate, IEnumerable&lt;T&gt; <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">foreach(T <span class="built_in">item</span> <span class="keyword">in</span> <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(predicate(<span class="built_in">item</span>))</span><br><span class="line">yield <span class="literal">return</span> <span class="built_in">item</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Fold函数实际上代表了一系列函数，而最重要的两个例子是左折叠和右折叠，这里我们选择相对简单地左折叠来实现累加的功能，它需要一个元素集合，一个累加函数和一个初始值，我们一起来看下面的代码实现：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">R Fold&lt;T,R&gt;(Func&lt;R,T,R&gt; func, IEnumerable&lt;T&gt; <span class="built_in">list</span>, R startValue = default(R))</span><br><span class="line">&#123;</span><br><span class="line">R <span class="literal">result</span> = startValue;</span><br><span class="line">foreach(T <span class="built_in">item</span> <span class="keyword">in</span> <span class="built_in">list</span>)</span><br><span class="line"><span class="literal">result</span> = func(<span class="literal">result</span>, <span class="built_in">item</span>);</span><br><span class="line"><span class="built_in">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>相信现在大家应该理解什么是高阶函数了，这种听起来非常数学的名词，当我们尝试用代码来描述的时候会发现非常简单。相信大家都经历过学生时代，临近期末考试的时候死记硬背名词解释的情形，其实可以用简洁的东西描述清楚的概念，为什么需要用这种方式来理解呢？为什么我这里选择了C#中的委托来编写这些示例代码呢？自然是同样的道理啦，因为我们都知道，在C#中委托是一种类似函数指针的概念，因为当我们需要传入和返回一个函数的时候，选择委托这种特殊的类型可谓是恰如其分啦，这样并不会影响我们去理解高阶函数。</p><h2 id="柯里化-Curring-局部套用"><a href="#柯里化-Curring-局部套用" class="headerlink" title="柯里化(Curring)/局部套用"></a>柯里化(Curring)/局部套用</h2><p>&emsp;&emsp;柯里化(Curring)得名于数学家Haskell Curry，你的确没有看错，这位伟大的数学家不仅创造了Haskell这门函数式编程语言，而且提出了局部套用(Currin)这种概念。所谓局部套用，就是指不管函数中有多少个参数，都可以函数视为函数类的成员，而这些函数只有一个形参，局部套用和部分应用息息相关，尤其是部分应用是保证函数模块化的两个重要技术之一(部分应用和组合<strong>(Composition)</strong>是保证函数模块化的两个重要技术)。众所周知，在C#中一个函数一旦完成定义，那么它的参数列表就是确定的，即相对静态。它不能像Python和Lua一样去动态改变参数列表，虽然我们可以通过缺省参数来减少参数的个数，可是在大多数情况下，我们都需要在调用函数前准备好所有参数，而局部套用所做的事情与这个理念截然相反，它的目标是用非完全的参数列表去调用函数。我们来一起看下面这个例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="keyword">add</span> = (x,y) =&gt; &#123;<span class="keyword">return</span> x + y;&#125;;</span><br></pre></td></tr></table></figure></p><p>这是一个由匿名方法定义的委托类型，显然我们需要在调用这个方法前准备好两个参数x和y，这意味着C#不允许我们在改变参数列表的情况下调用这个方法。而通过局部套用：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt; curriedAdd =&gt; (x) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (y) =&gt; &#123; <span class="keyword">return</span> x + y;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>实际上在这里两个参数x和y的顺序对最终结果没有任何影响，我们这样写仅仅是为了符合人类正常的认知习惯，而此时我们注意到我们在调用curriedAdd时会发生质的的变化：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//<span class="keyword">x</span>和y同时被传入<span class="keyword">add</span></span><br><span class="line"><span class="keyword">add</span>(<span class="keyword">x</span>,y)</span><br><span class="line">//<span class="keyword">x</span>和y可以不同时被传入curriedAdd</span><br><span class="line">curriedAdd(<span class="keyword">x</span>)(y)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>而如果我们将这里的函数用Lambda表达式来表示，则会发现：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt; add = (x,y) =&gt; <span class="keyword">return</span> x + y;</span><br><span class="line">Func&lt;<span class="built_in">int</span>,Fucn&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;&gt; curriedAdd = x = &gt; y =&gt; x + y;</span><br></pre></td></tr></table></figure></p><p>至此，对一般的局部套用，存在：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;...&gt; f = (part1, part2, part3, ...) =&gt; ... 可转换为：</span><br><span class="line">Func&lt;...&gt; cf = part1 =&gt; part2 =&gt; part3 ... =&gt; ...</span><br></pre></td></tr></table></figure></p><p>则称后者为前者的局部套用形式。</p><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>&emsp;&emsp;我们在前文中曾经提到过，在函数式编程中函数是第一等公民，而这里的函数更接近数学意义上的函数，即将函数视为一个可以对表达式求值的纯函数，所以我们这里自然而然地就提到了惰性求值。首先，博主这里想说说求值策略这个问题，求值策略通常有严格求值和非严格求值两种，而对C#语言来讲，它在大多数情况下使用严格求值策略，即参数在传递给函数前求值。与之相对应的，我们将参数在传递给函数前不进行求值或者延迟求值的这种情况，称为非严格求值策略。一个经典的例子是C#中的“短路”效应：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isTrue = (<span class="number">10</span> &lt; <span class="number">5</span>) &amp;&amp; (<span class="name">MyCheck</span>())</span><br></pre></td></tr></table></figure></p><p>因为在这里表达式的第一部分返回值为false，因此在实际调用中第二部分根本不会执行，因为无论第二部分返回true还是false，实际上对整个表达式的结果都不会产生影响。这是一个非常经典的非严格求值的例子，同样的，布尔运算中的”||”运算符，同样存在这个问题。所以，至此我们可以领会到惰性求值的优点，即使程序的执行效率更好，尤其是在避免高昂运算代价的时候，我们要牢记：懒惰是程序员的一种美德，使用更简洁的代码来满足需求，是一名游戏程序员的永恒追求。我们可以联想那些在代码片段中优先return的场景，这大概勉强可以用这种理论来解释吧！例如我们强大的Linq，原谅我如此执著于举Linq的例子，Linq的一个特点是当数据需要被使用的时候开始计算，即数据是延迟加载的，而在此之前我们所有对数据的操作，从某种意义上来讲，更像是定义了一系列函数，这好像和数据库中的事务非常相近啦，其实这就是在告诉我们，懒惰是一种美德啊，哈哈！</p><h1 id="函数式编程的利弊探讨"><a href="#函数式编程的利弊探讨" class="headerlink" title="函数式编程的利弊探讨"></a>函数式编程的利弊探讨</h1><p>&emsp;&emsp;好了，现在让我们从函数式编程的各种术语中解放出来，高屋建瓴般地从更高的层面上探讨下函数式编程的利弊。当你讨论一种东西的利弊时，一种习惯性的做法是找一种东西来和它作比较，如果Windows和Linux、SQL和NoSQ、面向对象和函数式…等等，我们常常关注一件事物的利弊，而非去寻找哪一个是最好。可惜自以为是的人类，常常以此来自我设限，划分各自的阵营，这当真是件无聊的事情，就像我一直不喜欢SQL和正则表达式，所以我就去了解数据库的设计、模式匹配相关内容，最终感觉颇有一番收获，我想这是我们真正的目的吧！好了，下面我们说说函数式编程有哪些优缺点？首先，函数式编程极大地改善了程序的模块化程度，高阶函数、递归和惰性求值让程序充分函数化，函数式让编程可以以一种声明式的风格来增强程序语义。当然，函数式编程的缺点是，我们这个现实世界本来就不是纯粹的，函数式编程强调的数据不可变性，意味着我们无法去模拟事物状态变化，因此我们不能为了追求无副作用、无锁而忽视现实，这个世界上总有些肮脏的问题，无法让我们用纯函数的思维去解决，这个时候我们不能说要让设计去适应这个世界，任何技术或者框架的诞生归根到底是为了解决问题，而函数式编程或者是面向对象编程，本质都是一种编程思想，我们最终是为了解决问题，就像这个世界有时候并不是面向对象的，我们用面向对象来描述这个世界，或许仅仅是我们自己的理解，这个世界到底是什么样子的，大概只有上帝会知道吧！  </p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文主要对函数式编程及其常见术语进行了简要讨论，主要根据《C#函数式程序设计》一书整理并辅以博主的理解而成。首先，函数式编程中强调无状态、不可变性，认为函数是一等公民，并且在函数式编程中每一个函数都是一个纯函数，它是数学概念咋计算机领域的一种延伸，和冯.诺依曼计算机体系不同，函数式编程的核心思想是以lambda演算为基础的表达式求值，并且函数式编程强调无副作用。本文对函数式编程中的常见术语如高阶函数、局部套用/柯里化、惰性求值等结合C#语言进行了简单分析。或许对我们而言，函数式编程是一个新鲜事物，可正如我们第一次接触面向对象编程时一样，我们并不知道这样一种编程思想会持续到今天。我不认为函数式编程会彻底替代面向对象编程，就像Web开发无法彻底替换原生开发一样，函数式编程会作为面向对象的一种延伸和补充，所以本文对函数式编程的理解实际上是非常肤浅的，可这个世界本来就是在不断变化的，希望我们可以在恰当的场景下去权衡选择什么样的技术，对这个世界而言，我们永远都是探索者，或许永远都不存在完全能满足现实场景的编程范式吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;近年来函数式编程这种概念渐渐流行起来，尤其是在React/Vuejs这两个前端框架的推动下，函数式编程就像股新思潮一般瞬间席卷整个技术圈。虽然博主接触到的前端技术并不算深入，可这并不妨碍我们通过类似概念的延伸来理解这种概念。首先，函数式编程是一种编程范式，而我们所熟悉的常见编程范式则有&lt;strong&gt;命令式编程(Imperative Programmming)&lt;/strong&gt;、&lt;strong&gt;函数式编程(Functional Programming)&lt;/strong&gt;、&lt;strong&gt;逻辑式编程(Logic Programming)&lt;/strong&gt;、&lt;strong&gt;声明式编程(Declarative Programming)&lt;/strong&gt;和&lt;strong&gt;响应式编程(Reactive Programming)&lt;/strong&gt;等。现代编程语言  在发展过程中实际上都在借鉴不同的编程范式，比如Lisp和Haskell  是最经典的函数式编程语言，而SmartTalk、C++和Java则是最经典的命令式编程语言。微软的C#语言最早主要借鉴Java语言，在其引入lambda和LINQ特性以后，使得C#开始具备实施函数式编程的基础，而最新的Java8同样开始强化lambda这一特性，为什么lambda会如此重要呢？这或许要从函数式编程的基本术语开始说起。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://qinyuanpei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="编程" scheme="http://qinyuanpei.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书" scheme="http://qinyuanpei.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="函数式编程" scheme="http://qinyuanpei.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于Mono和VSCode打造轻量级跨平台IDE</title>
    <link href="http://qinyuanpei.github.io/2016/11/18/make-a-light-ide-with-visual-studio-code-and-mono.html"/>
    <id>http://qinyuanpei.github.io/2016/11/18/make-a-light-ide-with-visual-studio-code-and-mono.html</id>
    <published>2016-11-18T20:23:44.000Z</published>
    <updated>2017-12-24T08:21:25.721Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近Visual Studio推出Mac版本的消息迅速在技术圈里刷屏，当工程师们最喜欢的笔记本电脑Mac，邂逅地球上最强大的集成开发环境Visual Studio的时候，会碰撞出怎样精彩的火花呢？在微软新任CEO纳德拉的“移动为先、云为先”战略下，微软的转变渐渐开始让人欣喜，从.NET Core、VSCode、TypeScript再到近期的Visual Studio For Mac，这一系列动作让我们感觉到，微软的技术栈越来越多地向着开源和跨平台两个方向努力。我们曾经固执地认为，微软的技术栈注定永远无法摆脱Windows的束缚，而事实上这个世界每天都在发生着变化。或许这次Visual Studio推出Mac版这件事情，本质上是微软收购的Xamarin公司旗下产品Xamarin Studio的一次改头换面。可是这件事情说明，微软正在努力让.NET技术栈融入更多的应用场景。对我而言，我是没有钱去买一台Mac的，所以在这篇文章中，我们将在Linux下通过Mono和VSCode来打造一个轻量级的IDE。而据说Mono会和Xamarin一样，将来会成为.NET基金会的一部分。</p><a id="more"></a><p>&emsp;&emsp;好了，我们首先在Windows世界里进行彩排，在开始下面的内容以前，请保证你的计算机上安装了Mono和VSCode。假如你经常关注我的博客，你应该会知道Mono在这里的作用是什么？，简而言之，Mono为我们提供了编译器环境和运行时环境，在这个基础上VSCode这个天生带着Visual Studio基因的编辑器，则可以为我们提供基础的代码调试功能，这是我们这篇文章写作的关键因素。如果你还对Mono一无所知，下面的两篇文章可以帮助你快速了解：</p><ul><li><a href="http://qinyuanpei/2016/03/06/make-dotnet-run-in-cross-platform-with-mono.html" target="_blank" rel="noopener">使用Mono让.NET程序跨平台运行</a></li><li><a href="http://qinyuanpei.com/2016/03/25/build-light-weight-runtime-for-dotnet-with-mono.html" target="_blank" rel="noopener">使用Mono打造轻量级的.NET运行时</a></li></ul><p>&emsp;&emsp;在我们了解了Mono以后，就可以考虑将Mono作为VSCode的运行时环境，这意味着我们可以在使用VSCode的同时直接编译代码。目前在VSCode中内建的运行时支持为Node/Node2，所以如果我们希望在VSCode中调试更多的语言，我们就必须要为VSCode安装相应的插件。因为事实上在VSCode中编译代码我们可以直接通过Task来完成编译，但当我们希望在VSCode中对代码进行调试的时候，我们就必须借助插件来完成调试任务，这或许从侧面印证了VSCode的产品定位就是一个文本编辑器。</p><p>&emsp;&emsp;而对于微软推出的这样一款产品，我们或许会疑惑，为什么这个编辑器提供的内建支持居然是Node，而不是我们所熟悉的.NET技术体系。这个原因非常容易理解，如果你听说过Github出品的编辑器Atom，或者是使用过Electron/Node-Webkit相关技术，那么你一定会深刻地理解，VSCode本质上和Atom一样，都是采用Web技术来构建跨平台应用，而Node天生就具备Web属性加成，所以我们就不难理解为什么VSCode内建的支持是Node而非.NET技术体系。同样地，为了实现跨平台的目标，在对C#语言的支持这个问题上，微软选择了OminiSharp这样一个跨平台的代码自动补全工具，而非我们在Visual Studio中所熟知的Intellisense技术。在.NETCore推出以后.NET跨平台不再是梦想，我们对技术的探索就不应该再局限在Windows平台上。</p><p>&emsp;&emsp;博主关注Mono始于Unity3D引擎，因为Mono真正实现了.NET技术的跨平台，而Unity3D引擎最为人所称道的当属其强悍的跨平台能力，在这一点上Mono功不可没。在此之前收费的Xamarin让人望而却步，所以Mono自然而然地就成为了我的选择。因为博主的计算机上安装了Mono，所以在一开始使用VSCode的时候，就先入为主地认为在不安装插件的情况下，应该就可以直接在VSCode中编译和调试代码了。首先我们在VSCode中创建一个C#代码文件，既然在程序世界里万事万物都从Hello World说起，那么我们这里依然遵循这个原则。在创建该代码文件以后，我们将其所在的目录在VSCode中打开，这是因为：</p><blockquote><p>在VSCode中仅支持以目录方式打开的文件的编译和调试</p></blockquote><p>所以这个时候我们在VSCode中的界面应该是如图所示：</p><p><img src="http://img.blog.csdn.net/20170226162907539" alt="在VSCode中编写代码"></p><p>好了，下面我们直接按下Ctrl+Shift+B来编译代码，此时VSCode将提示我们“配置任务运行程序”，这里需要说明的是，在VSCode中你可以感受到微软对命令行和配置文件的偏执，这让适应了Visual Studio这样功能强大的我们相当不习惯，按照VSCode的提示或者是通过Ctrl+Shift+P打开命令面板，VSCode将在当前工作目录下为我们创建.vscode目录和tasks.json文件，在VSCode中任何和项目相关的配置信息都会存储在这里啦。此时我们配置tasks.json:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="comment">// 该命令需要在系统变量内定义</span></span><br><span class="line">    <span class="string">"command"</span>: <span class="string">"mcs"</span>,</span><br><span class="line">    <span class="comment">// 或者使用完整的可执行路径</span></span><br><span class="line">    <span class="comment">// "command: "C:\Program Files\Mono\bin\mcs.exe"</span></span><br><span class="line">    <span class="string">"isShellCommand"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"args"</span>: [<span class="string">"*.cs"</span>],</span><br><span class="line">    <span class="string">"showOutput"</span>: <span class="string">"always"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里需要说明的是一个<strong>tasks.json</strong>中可以通过tasks属性来配置多个任务运行程序，例如我们的项目中有Python和C#两种代码需要编译，那么我们就可以配置两个task，VSCode将在运行程序的时候让用户由哪一个task来编译代码。如果你看过我在前面介绍过的两篇文章，就应该知道这里的mcs.exe其实是Mono提供的C#编译器，它负责将我们的C#代码编译为IL文件，然后IL文件再交由CLR来转换为本机代码。Mono提供的C#编译器可以将C#代码编译为.exe或者是.dll，可是在VSCode中好像默认都是编译为.exe，所以如果有知道如何在这里配置编译输出项的朋友，希望可以告诉我怎么去实现。</p><p>&emsp;&emsp;现在，我们应该会得到一个MainClass.exe的文件，最初博主尝试直接去配置launch.json，发现直接填写type为mono在VSCode中是无法识别的，最后决定去安装mono-debug的插件，安装插件在VSCode中是非常简单的，按下Ctrl+Shift+X打开插件界面，可以在这里查看最流行的插件列表、官方推荐的插件列表等等，我们直接搜索mono-debug然后安装插件即可。可是我不曾想到的是，我猜中故事的开头，却没有猜中故事的结尾，<strong>这个插件是不支持Window平台的</strong>，<strong>这个插件是不支持Windows平台的</strong>，<strong>这个插件是不支持Windows平台的</strong>。</p><p>&emsp;&emsp;好吧，现在看起来Linux是我唯一可以去尝试的平台了，博主这里选择的是颜值最高的Elementary OS，这是一个衍生自Ubuntu的Linux发行版。在VSCode正式版发布以后，在Linux下用VSCode来编程是我一直在尝试的事情，请不要说Linux系统使用起来会非常困难，博主在安装这些软件的过程中可以说是相当顺利。建议大家在Linux平台下安装C#、Mono-Debug和Python这3个插件，需要说明的是C#和Mono-Debug在第一次使用的时候，需要在网络环境下下载相关依赖。下面是博主目前的插件安装情况：</p><p><img src="http://img.blog.csdn.net/20170226164256843" alt="VSCode中插件安装界面"></p><p>&emsp;&emsp;我们现在按F5进行调试，和编译时一样，如果用户没有为当前项目配置“任务调试程序”，VSCode会提示我们去创建一个配置文件launch.json，我们这里选择mono，该选项在安装Mono-Debug插件以前是没有的，该配置文件如下，我们注意到这里需要修改program属性为MainClass.exe:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Launch"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"mono"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;/MainClass.exe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span>,</span><br><span class="line">            <span class="attr">"preLaunchTask"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"runtimeExecutable"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"env"</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Attach"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"mono"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"attach"</span>,</span><br><span class="line">            <span class="attr">"address"</span>: <span class="string">"localhost"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">5085</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里有一个小插曲，在博主运行这个简单的程序的时候，提示Mono的版本和Mono-Debug插件的版本要求不一致，因为Mono-Debug插件使用的是最新版本的Mono。所以，果断卸载目前的mono，然后安装最新的mono，安装方法为：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install <span class="built_in">mono</span>-complete</span><br></pre></td></tr></table></figure></p><p>这样我们就可以看到眼前的成果啦，我们成功地在VSCode运行了一个C#程序：</p><p><img src="http://img.blog.csdn.net/20170226163208634" alt="VSCode中调试代码"></p><p>&emsp;&emsp;虽然我很想在这篇博客中搞点干货出来，但是当我折腾数天以后，我大概就能够写出这样一篇相当零碎的文章，到目前为止我还是没有搞明白，为什么我在调试地过程中，VSCode不会在我设置了断点地地方停下来，希望知道这个原因的朋友可以告诉我啊。这个过程最有意义的地方在于让我进一步熟悉了Linux，在不一样的地方，会有不一样的风景，这个世界很大，不要给自己设限。后续我会去研究VSCode中的调试技巧以及.NETCore相关内容，能看到C#跨平台运行是件幸福的事情，而跨平台开发是我一直在探索的方向之一。夜晚已然来临了，而这篇文章就是这样了，谢谢大家的关注，晚安！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近Visual Studio推出Mac版本的消息迅速在技术圈里刷屏，当工程师们最喜欢的笔记本电脑Mac，邂逅地球上最强大的集成开发环境Visual Studio的时候，会碰撞出怎样精彩的火花呢？在微软新任CEO纳德拉的“移动为先、云为先”战略下，微软的转变渐渐开始让人欣喜，从.NET Core、VSCode、TypeScript再到近期的Visual Studio For Mac，这一系列动作让我们感觉到，微软的技术栈越来越多地向着开源和跨平台两个方向努力。我们曾经固执地认为，微软的技术栈注定永远无法摆脱Windows的束缚，而事实上这个世界每天都在发生着变化。或许这次Visual Studio推出Mac版这件事情，本质上是微软收购的Xamarin公司旗下产品Xamarin Studio的一次改头换面。可是这件事情说明，微软正在努力让.NET技术栈融入更多的应用场景。对我而言，我是没有钱去买一台Mac的，所以在这篇文章中，我们将在Linux下通过Mono和VSCode来打造一个轻量级的IDE。而据说Mono会和Xamarin一样，将来会成为.NET基金会的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Mono" scheme="http://qinyuanpei.github.io/tags/Mono/"/>
    
      <category term="跨平台" scheme="http://qinyuanpei.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="VSCode" scheme="http://qinyuanpei.github.io/tags/VSCode/"/>
    
  </entry>
  
</feed>
