<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Payne&#39;s Blog</title>
  
  <subtitle>人生到处知何似，应似飞鸿踏雪泥</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qinyuanpei.github.io/"/>
  <updated>2018-03-01T01:38:10.358Z</updated>
  <id>http://qinyuanpei.github.io/</id>
  
  <author>
    <name>Payne</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Travis CI实现 Hexo 在 Github 和 Coding 的同步部署</title>
    <link href="http://qinyuanpei.github.io/posts/1113828794/"/>
    <id>http://qinyuanpei.github.io/posts/1113828794/</id>
    <published>2018-02-27T10:45:04.000Z</published>
    <updated>2018-03-01T01:38:10.358Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是 <a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a> .在曾经的一篇博客：<a href="https://qinyuanpei.github.io/posts/3521618732/">《持续集成在Hexo自动化部署上的实践》</a>中，我为大家分享了在线持续集成服务  <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 的相关内容，在这篇文章中我们通过  <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 为 Hexo 提供了自动部署的支持。其原理是Github为 <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 分配一个token，当我们向 Github 推送新的代码以后，Travis 就会从代码仓库中拉取代码，并通过 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> 安装依赖生成静态页面，我们将这些静态页面推送到 master 分支，即可完成对Hexo的部署操作。这个流程从去年10月份建立以来，一直运行得非常稳定，对我个人而言，随着博客里得内容越来越多，在本地生成静态页面需要<br>20多秒得时间，而有了持续集成服务以后，我可以用这个时间去做更多的事情，当持续集成流程发生异常的时候，微信上会收到 Travis 发送的邮件，整个过程简直令人心情愉悦。</p><p>&emsp;&emsp;今天想继续写点这个话题相关的内容，即如何通过 Travis CI 实现 Hexo 在 Github 和 Coding 的同步部署。显然，部署 Hexo 到 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 我们已经实现，今天我们着重来说 <a href="https://coding.net/pages/" target="_blank" rel="noopener">Coding Pages</a>。为什么我们需要 <a href="https://coding.net/pages/" target="_blank" rel="noopener">Coding Pages</a> 呢？主要从两个方面考虑，首先，因为 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 屏蔽了百度的爬虫，所以我们托管在 Github 上的博客，无法被搜索引擎正常收录；其次，由于 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 的服务器在国外，所以在国内博客的速度会受到影响，而且<strong>“防火墙”</strong>的国情决定了 <a href="https://github.com" target="_blank" rel="noopener">Github</a> 是一个不稳定的网站。曾经经历过短时间内无法使用 Github 的情形，故而，为了保证博客可以更加稳定地运行，我们必须为博客提供一个备份镜像，这就是我们今天要提到的 <a href="https://coding.net/pages/" target="_blank" rel="noopener">Coding Pages</a> 服务啦。在正式使用这个服务前，我们首先简单介绍下这个服务。</p><p>&emsp;&emsp;我们知道 <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 是 Github 提供的静态页面托管服务，其初衷是为个人项目或者组织项目创建演示或者文档站点，而 <a href="https://coding.net/pages/" target="_blank" rel="noopener">Coding Pages</a> 则是国内的代码托管平台 <a href="https://coding.net/git" target="_blank" rel="noopener">Coding</a> 提供的类似服务，国内类似的代码托管平台还有<a href="https://gitee.com/login" target="_blank" rel="noopener">码云</a>、<a href="https://about.gitlab.com/" target="_blank" rel="noopener">Gitlab</a> 等。<a href="https://coding.net/pages/" target="_blank" rel="noopener">Coding Pages</a> 支持自定义域名、SSL 等基本特性，随着官方不断对这一服务进行升级，目前该服务除支持静态页面部署以外，同时支持 PHP 和 MySQL这类动态页面部署的特性。对 Hexo 来说，静态页面部署的特性完全可以支撑我们这个想法。我的想法是以 <a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener">Github</a> 作为代码的主仓库，其上面的 <strong>blog</strong> 分支存放博客的源代码， <strong>master</strong> 分支存放博客的静态页面，在此基础上，我们同时推送静态页面到 Github 和 Coding 的代码仓库，这样就可以实现两个平台的同步部署，这里的部署自然是指由 Travis 完成的自动化部署。整体的流程设想如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/2018022714101472" alt="博客同步部署流程图" title="">                </div>                <div class="image-caption">博客同步部署流程图</div>            </figure><p>&emsp;&emsp;通过这个流程图，我们可以注意到，新增加的工作量，主要体现在 Travis 向 Coding 的代码仓库推送静态页面，因此我们首先要有一个 Coding 的代码仓库。关于如何注册 Coding 及在 Coding 上创建代码仓库，这里不再详细赘述啦，大家可以自行百度、Google 或者阅读官方文档。Travis CI 的行为主要由 <strong>.travis.yml</strong> 这个文件来决定，要推送静态页面到 Coding 的代码仓库，Travis CI 需要有代码仓库的读写权限。顺着这个思路，尝试让 Coding 授权 给 Travis CI，结果从文档中发现Travis CI 并不支持 Coding，而 Coding 官方支持的持续集成 flow.ci 需要使用者从 Docker 创建镜像，所以看起来这条路无法走通。从搜索引擎中检索相关问题，从 Git 工作机制的角度入手，可以想到三种常见思路，即 SSH Key、Hexo 的 deploy 插件和 HTTPS协议。</p><p>&emsp;&emsp;第一种思路是考虑让 Travis CI 的远程服务器共享本机的SSH Key，通过 <strong>ssh-copy-id</strong> 命令即可实现，可问题是 Travis CI 每次创建虚拟机环境是变化的，因此我们无法确定目标主机的 IP 或者计算机名称等信息，这种思路不适合 Travis CI。而 Travis CI 官方同样提供了命令行工具来完成这个工作，因为 Travis CI 是基于 Ruby 开发而来，所以需要 Ruby 的环境支持，作为一个为逃避 Jekyll 而选择 Hexo 的人，我是不会让自己再受到 Ruby 的摧残的，所以这种思路基本放弃。第二种思路是使用 Hexo 提供的 deploy 插件，例如 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deploy-git</a> 这个插件支持通过 git 部署，而 Coding 和 Github 都支持 Git 相关的协议，所以可以考虑使用这个插件来完成这个操作，目前网络上可以检索到的资料，都是使用这个插件来完成同步部署。可是经过我一位使用过这个插件的朋友确定，该插件需要再执行 git 命令行期间输入用户名和密码，Travis CI 是不会给你机会输入用户名和密码的，所以这种思路再次放弃。第三种 HTTPS 协议，这个想都不用想是需要输入密码的，所以果断直接放弃。</p><p>&emsp;&emsp;正所谓”行至水穷处，坐看云起时”，山重水复之间，柳暗花明之际，我意外发现 Coding 提供了和 Github 类似的”访问令牌”，我们在使用 Travis CI 的时候，实际上做了两步授权操作，第一次是授权 Travis CI 读取我们在 Github 上的仓库列表，这是一个通过 OAuth 授权的过程；第二次授权是授权 Travis CI 向指定仓库推送或者拉取内容，这是一个通过 Token 授权的过程。我们会在 Travis CI 的后台设置中将 Token 作为全局变量导出，这样我们就可以在 .travis.yml 文件中引用这些全局变量。我意识到这是一个值得一试的想法，首先我们在 Coding 的<strong>”个人设置”</strong>页面中找到<strong>访问令牌</strong>，新建一个新的访问令牌，这里我们选第一个权限即可，因为我们只需要为 Travis 提供基本的读写权限，这样我们会生成一个 Token，这里注意保存 Token，因为它在这里只显示这一次，我们将 Token 填写到 Travis CI 的后台，取名为 CO_Token 即可，依次如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180227150043442" alt="在Coding中新建访问令牌" title="">                </div>                <div class="image-caption">在Coding中新建访问令牌</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180227150136197" alt="在Coding中保存访问令牌" title="">                </div>                <div class="image-caption">在Coding中保存访问令牌</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180227150209635" alt="在Travis中新建全局变量" title="">                </div>                <div class="image-caption">在Travis中新建全局变量</div>            </figure><p>&emsp;&emsp;好了，现在有了Token，就意味着 Travis CI 有权限向 Coding 推送或者拉取内容了，那么怎么让它工作起来呢？我们记得 Travis CI 有一个叫做 .travis.yml 的配置文件对吧？这里我们需要简单修改下这个文件，让 Travis CI 在生成静态页面以后同时推送静态页面到 Coding。修改后的关键配置如下，我已经写好了详细注释，关于这个文件配置可以参考<a href="https://docs.travis-ci.com/" target="_blank" rel="noopener">这里</a>，这里不再详细说明：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"qinyuanpei"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"qinyuanpei@163.com"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER"</span></span><br><span class="line">  <span class="comment"># Github Pages</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:master</span> </span><br><span class="line">  <span class="comment"># Coding Pages</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://qinyuanpei:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;"</span> <span class="attr">master:master</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">tag</span> <span class="string">v0.0.$TRAVIS_BUILD_NUMBER</span> <span class="bullet">-a</span> <span class="bullet">-m</span> <span class="string">"Auto Taged By TravisCI With Build $TRAVIS_BUILD_NUMBER"</span></span><br><span class="line">  <span class="comment"># Github Pages</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:master</span> <span class="bullet">--tags</span></span><br><span class="line">  <span class="comment"># Coding Pages</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--quiet</span> <span class="string">"https://qinyuanpei:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;"</span> <span class="attr">master:master</span> <span class="bullet">--tags</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr"> global:</span></span><br><span class="line">   <span class="comment"># Github Pages</span></span><br><span class="line"><span class="attr">   - GH_REF:</span> <span class="string">github.com/qinyuanpei/qinyuanpei.github.io</span></span><br><span class="line">   <span class="comment"># Coding Pages</span></span><br><span class="line"><span class="attr">   - CO_REF:</span> <span class="string">git.coding.net/qinyuanpei/qinyuanpei.coding.me.git</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;好了，现在我们就可以同时部署博客到 Github 和 Coding了，现在大家可以使用下面两种方式来访问我的博客。需要说明的是，使用 Coding Pages 的特性需要开启仓库的 <strong>Pages </strong>服务，并且 Coding 支持免费托管私有项目，虽然目前仓库的容量存在限制，对我们部署 Hexo 来说完全足够啦，下图是 Coding 上展示的提交历史，排版效果棒棒哒，哈哈，好了，以上就是这篇文章的内容啦，希望大家喜欢哦！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180227152041753" alt="Coding上展示的提交历史" title="">                </div>                <div class="image-caption">Coding上展示的提交历史</div>            </figure><ul><li><a href="https://qinyuanpei.github.io">Github Pages 镜像</a></li><li><a href="http://qinyuanpei.coding.me" target="_blank" rel="noopener">Coding Pages 镜像</a></li></ul><p>&emsp;&emsp;本文使用的 .travis.yml 文件可以从<a href="https://github.com/qinyuanpei/qinyuanpei.github.io/blob/blog/.travis.yml" target="_blank" rel="noopener">这里</a> 获取哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是 &lt;a href=&quot;https://qinyuanpei.github.io&quot;&gt;https://qinyuanpei.github.io&lt;/a&gt; .在曾经的一篇博客：&lt;a href
      
    
    </summary>
    
      <category term="独立博客" scheme="http://qinyuanpei.github.io/categories/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://qinyuanpei.github.io/tags/Hexo/"/>
    
      <category term="CI" scheme="http://qinyuanpei.github.io/tags/CI/"/>
    
      <category term="Travis" scheme="http://qinyuanpei.github.io/tags/Travis/"/>
    
  </entry>
  
  <entry>
    <title>基于Python实现的微信好友数据分析</title>
    <link href="http://qinyuanpei.github.io/posts/2805694118/"/>
    <id>http://qinyuanpei.github.io/posts/2805694118/</id>
    <published>2018-02-24T12:50:52.000Z</published>
    <updated>2018-03-01T01:38:10.358Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近微信迎来了一次重要的更新，允许用户对”发现”页面进行定制。不知道从什么时候开始，微信朋友圈变得越来越复杂，当越来越多的人选择”仅展示最近三天的朋友圈”，大概连微信官方都是一脸的无可奈何。逐步泛化的好友关系，让微信从熟人社交逐渐过渡到陌生人社交，而朋友圈里亦真亦幻的状态更新，仿佛在努力证明每一个个体的”有趣”。有人选择在朋友圈里记录生活的点滴，有人选择在朋友圈里展示观点的异同，可归根到底，人们无时无刻不在窥探着别人的生活，唯独怕别人过多地了解自己的生活。人性中交织着的光明与黑暗，像一只浑身长满刺的刺猬，离得太远会感觉到寒冷，而靠得太近则害怕被刺扎到。朋友圈就像过年走亲戚，即便你心中有一万个不痛快，总是不愿意撕破脸，或屏蔽对方，或不给对方看，或仅展示最后三天，于是通讯录里的联系人越来越多，朋友圈越来越大，可再不会有能真正触动你内心的”小红点”出现，人类让一个产品变得越来越复杂，然后说它无法满足人类的需求，这大概是一开始就始料不及的吧！</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&emsp;&emsp;有人说，人性远比计算机编程更复杂，因为即使是人类迄今为止最伟大的发明——计算机，在面对人类的自然语言时同样会张惶失措 。人类有多少语言存在着模棱两可的含义，我认为语言是人类最大的误解，人类时常喜欢揣测语言背后隐藏的含义，好像在沟通时表达清晰的含义会让人类没有面子，更不用说网络上流行的猜测女朋友真实意图的案例。金庸先生的武侠小说《射雕英雄传》里，在信息闭塞的南宋时期，江湖上裘千丈的一句鬼话，就搅得整个武林天翻地覆。其实，一两句话说清楚不好吗？黄药师、全真七子、江南六怪间的种种纠葛，哪一场不是误会？一众儿武功震古烁今的武林高手，怎么没有丝毫的去伪存真的能力，语言造成了多少误会。</p><p>&emsp;&emsp;可即便人类的语言复杂得像一本无字天书，可人类还是从这些语言中寻觅到蛛丝马迹。古人有文王”拘而演周易”、东方朔测字卜卦，这种带有”迷信”色彩的原始崇拜，就如同今天人们迷信星座运势一般，都是人类在上千年的演变中不断对经验进行总结和训练的结果。如此说起来，我们的人工智能未尝不是一种更加科学化的”迷信”，因为数据和算法让我们在不断地相信，这一切都是真实地。生活在数字时代的我们，无疑是悲哀的，一面努力地在别人面前隐藏真实地自己，一面不无遗憾地感慨自己无处遁逃，每一根数字神经都紧紧地联系着你和我，你不能渴望任何一部数字设备具备真正的智能，可你生命里的每个瞬间，都在悄然间被数据地折射出来。</p><p>&emsp;&emsp;今天这篇文章会基于 Python 对微信好友进行数据分析，这里选择的维度主要有：性别、头像、签名、位置，主要采用图表和词云两种形式来呈现结果，其中，对文本类信息会采用词频分析和情感分析两种方法。常言道：工欲善其事，必先利其器也。在正式开始这篇文章前，简单介绍下本文中使用到的第三方模块：</p><ul><li><a href="https://github.com/littlecodersh/itchat" target="_blank" rel="noopener">itchat</a>：微信网页版接口封装Python版本，在本文中用以获取微信好友信息。</li><li><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba</a>：结巴分词的 Python 版本，在本文中用以对文本信息进行分词处理。</li><li><a href="https://matplotlib.org/" target="_blank" rel="noopener">matplotlib</a>： Python 中图表绘制模块，在本文中用以绘制柱形图和饼图</li><li><a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">snownlp</a>：一个 Python 中的中文分词模块，在本文中用以对文本信息进行情感判断。</li><li><a href="http://www.pythonware.com/products/pil/" target="_blank" rel="noopener">PIL</a>： Python 中的图像处理模块，在本文中用以对图片进行处理。</li><li><a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a>： Python中 的数值计算模块，在本文中配合 <a href="https://amueller.github.io/word_cloud/" target="_blank" rel="noopener">wordcloud</a> 模块使用。</li><li><a href="https://amueller.github.io/word_cloud/" target="_blank" rel="noopener">wordcloud</a>： Python 中的词云模块，在本文中用以绘制词云图片。</li><li><a href="https://github.com/Tencent-YouTu/Python_sdk" target="_blank" rel="noopener">TencentYoutuyun</a>：腾讯优图提供的 Python 版本 SDK ，在本文中用以识别人脸及提取图片标签信息。<br>以上模块均可通过 pip 安装，关于各个模块使用的详细说明，请自行查阅各自文档。</li></ul><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>&emsp;&emsp;分析微信好友数据的前提是获得好友信息，通过使用 itchat 这个模块，这一切会变得非常简单，我们通过下面两行代码就可以实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">itchat.auto_login(hotReload = <span class="keyword">True</span>)</span><br><span class="line">friends = itchat.get_friends(update = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;同平时登录网页版微信一样，我们使用手机扫描二维码就可以登录，这里返回的friends对象是一个集合，第一个元素是当前用户。所以，在下面的数据分析流程中，我们始终取friends[1:]作为原始输入数据，集合中的每一个元素都是一个字典结构，以我本人为例，可以注意到这里有Sex、City、Province、HeadImgUrl、Signature这四个字段，我们下面的分析就从这四个字段入手：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180223205004843" alt="好友信息结构展示" title="">                </div>                <div class="image-caption">好友信息结构展示</div>            </figure><h2 id="好友性别"><a href="#好友性别" class="headerlink" title="好友性别"></a>好友性别</h2><p>&emsp;&emsp;分析好友性别，我们首先要获得所有好友的性别信息，这里我们将每一个好友信息的Sex字段提取出来，然后分别统计出Male、Female和Unkonw的数目，我们将这三个数值组装到一个列表中，即可使用matplotlib模块绘制出饼图来，其代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseSex</span><span class="params">(firends)</span>:</span></span><br><span class="line">    sexs = list(map(<span class="keyword">lambda</span> x:x[<span class="string">'Sex'</span>],friends[<span class="number">1</span>:]))</span><br><span class="line">    counts = list(map(<span class="keyword">lambda</span> x:x[<span class="number">1</span>],Counter(sexs).items()))</span><br><span class="line">    labels = [<span class="string">'Unknow'</span>,<span class="string">'Male'</span>,<span class="string">'Female'</span>]</span><br><span class="line">    colors = [<span class="string">'red'</span>,<span class="string">'yellowgreen'</span>,<span class="string">'lightskyblue'</span>]</span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>,<span class="number">5</span>), dpi=<span class="number">80</span>)</span><br><span class="line">    plt.axes(aspect=<span class="number">1</span>) </span><br><span class="line">    plt.pie(counts, <span class="comment">#性别统计结果</span></span><br><span class="line">            labels=labels, <span class="comment">#性别展示标签</span></span><br><span class="line">            colors=colors, <span class="comment">#饼图区域配色</span></span><br><span class="line">            labeldistance = <span class="number">1.1</span>, <span class="comment">#标签距离圆点距离</span></span><br><span class="line">            autopct = <span class="string">'%3.1f%%'</span>, <span class="comment">#饼图区域文本格式</span></span><br><span class="line">            shadow = <span class="keyword">False</span>, <span class="comment">#饼图是否显示阴影</span></span><br><span class="line">            startangle = <span class="number">90</span>, <span class="comment">#饼图起始角度</span></span><br><span class="line">            pctdistance = <span class="number">0.6</span> <span class="comment">#饼图区域文本距离圆点距离</span></span><br><span class="line">    )</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>,)</span><br><span class="line">    plt.title(<span class="string">u'%s的微信好友性别组成'</span> % friends[<span class="number">0</span>][<span class="string">'NickName'</span>])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里简单解释下这段代码，微信中性别字段的取值有Unkonw、Male和Female三种，其对应的数值分别为0、1、2。通过Collection模块中的Counter()对这三种不同的取值进行统计，其items()方法返回的是一个元组的集合，该元组的第一维元素表示键，即0、1、2，该元组的第二维元素表示数目，且该元组的集合是排序过的，即其键按照0、1、2 的顺序排列，所以通过map()方法就可以得到这三种不同取值的数目，我们将其传递给matplotlib绘制即可，这三种不同取值各自所占的百分比由matplotlib计算得出。下图是matplotlib绘制的好友性别分布图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180223205838851" alt="微信好友性别分析" title="">                </div>                <div class="image-caption">微信好友性别分析</div>            </figure></p><p>&emsp;&emsp;看到这个结果，我一点都不觉得意外，男女比例严重失衡，这虽然可以解释我单身的原因，可我不觉得通过调整男女比例就能解决问题，好多人认为自己单身是因为社交圈子狭小，那么是不是扩展了社交圈子就能摆脱单身呢？我觉得或许这样会增加脱单的概率，可幸运之神应该不会眷顾我，因为我的好运气早在我24岁以前就消耗完啦。在知乎上有一个热门的话题：<a href="https://www.zhihu.com/question/55744630" target="_blank" rel="noopener">现在的男性是否普遍不再对女性展开追求了？</a>，其实哪里会有人喜欢孤独呢？无非是怕一次又一次的失望罢了。有的人并不是我的花儿，我只是恰好途径了她的绽放。曾经有人说我是一个多情的人，可她永远不会知道，我做出的每一个决定都炽热而悲壮。所谓”慧极必伤，情深不寿；谦谦君子，温润如玉”，世人苦五毒者大抵如此。</p><h2 id="好友头像"><a href="#好友头像" class="headerlink" title="好友头像"></a>好友头像</h2><p>&emsp;&emsp;分析好友头像，从两个方面来分析，第一，在这些好友头像中，使用人脸头像的好友比重有多大；第二，从这些好友头像中，可以提取出哪些有价值的关键字。这里需要根据HeadImgUrl字段下载头像到本地，然后通过<a href="http://youtu.qq.com/#/home" target="_blank" rel="noopener">腾讯优图</a>提供的人脸识别相关的API接口，检测头像图片中是否存在人脸以及提取图片中的标签。其中，前者是分类汇总，我们使用饼图来呈现结果；后者是对文本进行分析，我们使用词云来呈现结果。关键代码如下 所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseHeadImage</span><span class="params">(frineds)</span>:</span></span><br><span class="line">    <span class="comment"># Init Path</span></span><br><span class="line">    basePath = os.path.abspath(<span class="string">'.'</span>)</span><br><span class="line">    baseFolder = basePath + <span class="string">'\\HeadImages\\'</span></span><br><span class="line">    <span class="keyword">if</span>(os.path.exists(baseFolder) == <span class="keyword">False</span>):</span><br><span class="line">        os.makedirs(baseFolder)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Analyse Images</span></span><br><span class="line">    faceApi = FaceAPI()</span><br><span class="line">    use_face = <span class="number">0</span></span><br><span class="line">    not_use_face = <span class="number">0</span></span><br><span class="line">    image_tags = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>,len(friends)):</span><br><span class="line">        friend = friends[index]</span><br><span class="line">        <span class="comment"># Save HeadImages</span></span><br><span class="line">        imgFile = baseFolder + <span class="string">'\\Image%s.jpg'</span> % str(index)</span><br><span class="line">        imgData = itchat.get_head_img(userName = friend[<span class="string">'UserName'</span>])</span><br><span class="line">        <span class="keyword">if</span>(os.path.exists(imgFile) == <span class="keyword">False</span>):</span><br><span class="line">            <span class="keyword">with</span> open(imgFile,<span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">                file.write(imgData)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Detect Faces</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        result = faceApi.detectFace(imgFile)</span><br><span class="line">        <span class="keyword">if</span> result == <span class="keyword">True</span>:</span><br><span class="line">            use_face += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            not_use_face += <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Extract Tags</span></span><br><span class="line">        result = faceApi.extractTags(imgFile)</span><br><span class="line">        image_tags += <span class="string">','</span>.join(list(map(<span class="keyword">lambda</span> x:x[<span class="string">'tag_name'</span>],result)))</span><br><span class="line">    </span><br><span class="line">    labels = [<span class="string">u'使用人脸头像'</span>,<span class="string">u'不使用人脸头像'</span>]</span><br><span class="line">    counts = [use_face,not_use_face]</span><br><span class="line">    colors = [<span class="string">'red'</span>,<span class="string">'yellowgreen'</span>,<span class="string">'lightskyblue'</span>]</span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>,<span class="number">5</span>), dpi=<span class="number">80</span>)</span><br><span class="line">    plt.axes(aspect=<span class="number">1</span>) </span><br><span class="line">    plt.pie(counts, <span class="comment">#性别统计结果</span></span><br><span class="line">            labels=labels, <span class="comment">#性别展示标签</span></span><br><span class="line">            colors=colors, <span class="comment">#饼图区域配色</span></span><br><span class="line">            labeldistance = <span class="number">1.1</span>, <span class="comment">#标签距离圆点距离</span></span><br><span class="line">            autopct = <span class="string">'%3.1f%%'</span>, <span class="comment">#饼图区域文本格式</span></span><br><span class="line">            shadow = <span class="keyword">False</span>, <span class="comment">#饼图是否显示阴影</span></span><br><span class="line">            startangle = <span class="number">90</span>, <span class="comment">#饼图起始角度</span></span><br><span class="line">            pctdistance = <span class="number">0.6</span> <span class="comment">#饼图区域文本距离圆点距离</span></span><br><span class="line">    )</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>,)</span><br><span class="line">    plt.title(<span class="string">u'%s的微信好友使用人脸头像情况'</span> % friends[<span class="number">0</span>][<span class="string">'NickName'</span>])</span><br><span class="line">    plt.show() </span><br><span class="line"></span><br><span class="line">    image_tags = image_tags.encode(<span class="string">'iso8859-1'</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    back_coloring = np.array(Image.open(<span class="string">'face.jpg'</span>))</span><br><span class="line">    wordcloud = WordCloud(</span><br><span class="line">        font_path=<span class="string">'simfang.ttf'</span>,</span><br><span class="line">        background_color=<span class="string">"white"</span>,</span><br><span class="line">        max_words=<span class="number">1200</span>,</span><br><span class="line">        mask=back_coloring, </span><br><span class="line">        max_font_size=<span class="number">75</span>,</span><br><span class="line">        random_state=<span class="number">45</span>,</span><br><span class="line">        width=<span class="number">800</span>, </span><br><span class="line">        height=<span class="number">480</span>, </span><br><span class="line">        margin=<span class="number">15</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    wordcloud.generate(image_tags)</span><br><span class="line">    plt.imshow(wordcloud)</span><br><span class="line">    plt.axis(<span class="string">"off"</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里我们会在当前目录新建一个HeadImages目录，用以存储所有好友的头像，然后我们这里会用到一个名为FaceApi类，这个类由腾讯优图的SDK封装而来，这里分别调用了<a href="http://youtu.qq.com/#/develop/api-face-analysis-detect" target="_blank" rel="noopener">人脸检测</a>和<a href="http://youtu.qq.com/#/develop/api-image-tag" target="_blank" rel="noopener">图像标签识别</a>两个API接口，前者会统计”使用人脸头像”和”不使用人脸头像”的好友各自的数目，后者会累加每个头像中提取出来的标签。其分析结果如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180224095139638" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>&emsp;&emsp;可以注意到，在所有微信好友中，约有接近1/4的微信好友使用了人脸头像， 而有接近3/4的微信好友没有人脸头像，这说明在所有微信好友中对”颜值 “有自信的人，仅仅占到好友总数的25%，或者说75%的微信好友行事风格偏低调为主，不喜欢用人脸头像做微信头像。这是否说明”好看的皮囊”并非是千篇一律，长得好看的人实在是少数中的少数。所以，当女生的妆容越来越向着”韩式半永久粗平眉”、”瓜子脸”和”大红唇”靠拢的时候，当男生的服饰越来越向着”大背头”、”高领毛衣”和”长款大衣”靠拢的时候，我们能不能真正得个性一次。生命中有太多被世俗绑架着的事情，既要和别人不一样 ，同时还要和大多数人一样，这是人生在世的无可奈何。考虑到腾讯优图并不能真正得识别”人脸”，我们这里对好友头像中的标签再次进行提取，来帮助我们了解微信好友的头像中有哪些 关键词，其分析结果如图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180224100011424" alt="微信好友头像标签词云展示" title="">                </div>                <div class="image-caption">微信好友头像标签词云展示</div>            </figure></p><p>&emsp;&emsp;通过词云，我们可以发现：在微信好友中的签名词云中，出现频率相对较高的关键字有：女孩、树木、房屋、文本、截图、卡通、合影、天空、大海。这说明在我的微信好友中，好友选择的微信头像主要有日常、旅游、风景、截图四个来源，好友选择的微信头像中风格以卡通为主，好友选择的微信头像中常见的要素有天空、大海、房屋、树木。通过观察所有好友头像，我发现在我的微信好友中，使用个人照片作为微信头像的有15人，使用网络图片作为微信头像的有53人，使用动漫图片作为微信头像的有25人，使用合照图片作为微信头像的有3人，使用孩童照片作为微信头像的有5人，使用风景图片作为微信头像的有13人，使用女孩照片作为微信头像的有18人，基本符合图像标签提取的分析结果。</p><h2 id="好友签名"><a href="#好友签名" class="headerlink" title="好友签名"></a>好友签名</h2><p>&emsp;&emsp;分析好友签名，签名是好友信息中最为丰富的文本信息，按照人类惯用的”贴标签”的方法论，签名可以分析出某一个人在某一段时间里状态，就像人开心了会笑、哀伤了会哭，哭和笑两种标签，分别表明了人开心和哀伤的状态。这里我们对签名做两种处理，第一种是使用用结巴分词进行分词后生成词云，目的是了解好友签名中的关键字有哪些，哪一个关键字出现的频率相对较高；第二种是使用SnowNLP分析好友签名中的感情倾向，即好友签名整体上是表现为正面的、负面的还是中立的，各自的比重是多少。这里提取Signature字段即可，其核心代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseSignature</span><span class="params">(friends)</span>:</span></span><br><span class="line">    signatures = <span class="string">''</span></span><br><span class="line">    emotions = []</span><br><span class="line">    pattern = re.compile(<span class="string">"1f\d.+"</span>)</span><br><span class="line">    <span class="keyword">for</span> friend <span class="keyword">in</span> friends:</span><br><span class="line">        signature = friend[<span class="string">'Signature'</span>]</span><br><span class="line">        <span class="keyword">if</span>(signature != <span class="keyword">None</span>):</span><br><span class="line">            signature = signature.strip().replace(<span class="string">'span'</span>, <span class="string">''</span>).replace(<span class="string">'class'</span>, <span class="string">''</span>).replace(<span class="string">'emoji'</span>, <span class="string">''</span>)</span><br><span class="line">            signature = re.sub(<span class="string">r'1f(\d.+)'</span>,<span class="string">''</span>,signature)</span><br><span class="line">            <span class="keyword">if</span>(len(signature)&gt;<span class="number">0</span>):</span><br><span class="line">                nlp = SnowNLP(signature)</span><br><span class="line">                emotions.append(nlp.sentiments)</span><br><span class="line">                signatures += <span class="string">' '</span>.join(jieba.analyse.extract_tags(signature,<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'signatures.txt'</span>,<span class="string">'wt'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">         file.write(signatures)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sinature WordCloud</span></span><br><span class="line">    back_coloring = np.array(Image.open(<span class="string">'flower.jpg'</span>))</span><br><span class="line">    wordcloud = WordCloud(</span><br><span class="line">        font_path=<span class="string">'simfang.ttf'</span>,</span><br><span class="line">        background_color=<span class="string">"white"</span>,</span><br><span class="line">        max_words=<span class="number">1200</span>,</span><br><span class="line">        mask=back_coloring, </span><br><span class="line">        max_font_size=<span class="number">75</span>,</span><br><span class="line">        random_state=<span class="number">45</span>,</span><br><span class="line">        width=<span class="number">960</span>, </span><br><span class="line">        height=<span class="number">720</span>, </span><br><span class="line">        margin=<span class="number">15</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    wordcloud.generate(signatures)</span><br><span class="line">    plt.imshow(wordcloud)</span><br><span class="line">    plt.axis(<span class="string">"off"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    wordcloud.to_file(<span class="string">'signatures.jpg'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Signature Emotional Judgment</span></span><br><span class="line">    count_good = len(list(filter(<span class="keyword">lambda</span> x:x&gt;<span class="number">0.66</span>,emotions)))</span><br><span class="line">    count_normal = len(list(filter(<span class="keyword">lambda</span> x:x&gt;=<span class="number">0.33</span> <span class="keyword">and</span> x&lt;=<span class="number">0.66</span>,emotions)))</span><br><span class="line">    count_bad = len(list(filter(<span class="keyword">lambda</span> x:x&lt;<span class="number">0.33</span>,emotions)))</span><br><span class="line">    labels = [<span class="string">u'负面消极'</span>,<span class="string">u'中性'</span>,<span class="string">u'正面积极'</span>]</span><br><span class="line">    values = (count_bad,count_normal,count_good)</span><br><span class="line">    plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'simHei'</span>] </span><br><span class="line">    plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="keyword">False</span></span><br><span class="line">    plt.xlabel(<span class="string">u'情感判断'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">u'频数'</span>)</span><br><span class="line">    plt.xticks(range(<span class="number">3</span>),labels)</span><br><span class="line">    plt.legend(loc=<span class="string">'upper right'</span>,)</span><br><span class="line">    plt.bar(range(<span class="number">3</span>), values, color = <span class="string">'rgb'</span>)</span><br><span class="line">    plt.title(<span class="string">u'%s的微信好友签名信息情感分析'</span> % friends[<span class="number">0</span>][<span class="string">'NickName'</span>])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过词云，我们可以发现：在微信好友的签名信息中，出现频率相对较高的关键词有：努力、长大、美好、快乐、生活、幸福、人生、远方、时光、散步。果然我的微信好友都是温暖、正直的好青年啊！ :smile:其实，签名这个设定，从某种程度上是在反映人的一种心态，人在年轻时不免”为赋新词强说愁”，等到你真正到了这个精神境界，突然发现年轻时图样图森破，或许这就是我们不愿意让别人了解过去的原因，因为伴随着人的成长，某一种瞬间的状态简直不忍直视，QQ空间陪伴了我们这代人的整个青春，令人印象深刻的”那年今日”功能，有时让我们感到回忆的温暖，有时让我们感到岁月的萧杀，”当时只道是寻常”的物是人非，”回首向来萧瑟处”的淡定从容，”今夕复何夕”的失落惆怅……都在这一行行签名里留下深深浅浅的印记。在知乎上有关于<a href="https://www.zhihu.com/topic/19665970/hot" target="_blank" rel="noopener">签名</a>的话题讨论，对此感兴趣的朋友不妨找时间看看。:smile:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/201802241102499" alt="微信好友签名信息词云展示" title="">                </div>                <div class="image-caption">微信好友签名信息词云展示</div>            </figure><p>&emsp;&emsp;通过柱状图，我们可以发现：在微信好友的签名信息中，正面积极的情感判断约占到55.56%，中立的情感判断约占到32.10%，负面消极的情感判断约占到12.35%。这个结果和我们通过词云展示的结果基本吻合，这说明在微信好友的签名信息中，约有87.66%的签名信息，传达出来都是一种积极向上的态度。朋友圈中基本上有两类用户，第一类用户使用朋友圈记录自己的生活，第二类用户使用朋友圈输出自己的观点。显然，对于第二类用户，它并不介意别人了解它的过去，它更在乎它从始至终输出的观点是否一致。所以，不管朋友圈里别人在或晒美食、或晒旅游、或秀恩爱、或晒宝宝、或煲鸡汤等等，在我看来这都是一种生活方式，精神层次和物质层次比你高的人群，觉得你朋友圈里的内容”无趣”，这是符合人类一贯的认知方式的，在大多数情况下，反而是那些和你层次差不多的人群，对不熟悉的人或者事物妄加判断，如果你不喜欢我朋友圈里的内容，请直接屏蔽我就好，因为这样我们还可以做朋友；如果你因为喜欢A而在我这里和我说B不好，这就真的是三观不合啦。我相信没有完全兴趣匹配的两个人，即使是男女朋友或者情侣之间，总之人与人相处嘛，真诚和互相尊重是基本要求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180224120700356" alt="微信好友签名信息情感分析展示" title="">                </div>                <div class="image-caption">微信好友签名信息情感分析展示</div>            </figure><h2 id="好友位置"><a href="#好友位置" class="headerlink" title="好友位置"></a>好友位置</h2><p>&emsp;&emsp;分析好友位置，主要通过提取Province和City这两个字段。Python中的地图可视化主要通过Basemap模块，这个模块需要从国外网站下载地图信息，使用起来非常的不便。百度的<a href="http://echarts.baidu.com/" target="_blank" rel="noopener">ECharts</a>在前端使用的比较多，虽然社区里提供了<a href="http://pyecharts.org/" target="_blank" rel="noopener">pyecharts</a>项目，可我注意到因为政策的改变，目前Echarts不再支持导出地图的功能，所以地图的定制方面目前依然是一个问题，主流的技术方案是配置全国各省市的JSON数据，这里博主使用的是<a href="https://me.bdp.cn/home.html" target="_blank" rel="noopener">BDP个人版</a>，这是一个零编程的方案，我们通过Python导出一个CSV文件，然后将其上传到BDP中，通过简单拖拽就可以制作可视化地图，简直不能再简单，这里我们仅仅展示生成CSV部分的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyseLocation</span><span class="params">(friends)</span>:</span></span><br><span class="line">    headers = [<span class="string">'NickName'</span>,<span class="string">'Province'</span>,<span class="string">'City'</span>]</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'location.csv'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>,newline=<span class="string">''</span>,) <span class="keyword">as</span> csvFile:</span><br><span class="line">        writer = csv.DictWriter(csvFile, headers)</span><br><span class="line">        writer.writeheader()</span><br><span class="line">        <span class="keyword">for</span> friend <span class="keyword">in</span> friends[<span class="number">1</span>:]:</span><br><span class="line">           row = &#123;&#125;</span><br><span class="line">           row[<span class="string">'NickName'</span>] = friend[<span class="string">'NickName'</span>]</span><br><span class="line">           row[<span class="string">'Province'</span>] = friend[<span class="string">'Province'</span>]</span><br><span class="line">           row[<span class="string">'City'</span>] = friend[<span class="string">'City'</span>]</span><br><span class="line">           writer.writerow(row)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;下图是BDP中生成的微信好友地理分布图，可以发现：我的微信好友主要集中在宁夏和陕西两个省份。数字时代的神经牵动着每一个社交关系链的人，我们想要竭力去保护的那点隐私，在这些数据中一点点地折射出来。人类或许可以不断地伪装自己，可这些从数据背后抽离出来的规律和联系不会欺骗人类。数学曾经被人称为最没有用的学科，因为生活中并不需要神圣而纯粹的计算，在不同的学科知识里，经验公式永远比理论公式更为常用。可是此时此刻，你看，这世界就像一只滴滴答答转动着的时钟，每一分每一秒都是严丝合缝的。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180223234011645" alt="微信好友地理分布图" title="">                </div>                <div class="image-caption">微信好友地理分布图</div>            </figure></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;写这篇文章的时候，我一直不知道该如何下笔，因为微信是一个神奇的存在，它是一个国民级别的全民APP，所以，微信的产品设计一直都是一个有趣的现象，从最初底部Tab的数目、每个Tab的名称、”发现”页面的定制、小程序入口、朋友圈入口到朋友圈评论等等一系列的设计细节，都是值得我们透过人性和心理去研究的。即使是被人们封神的”张小龙”，在面对结构最为复杂的中国用户群体的时候，他的潇洒中依旧不免充满无奈，从对朋友圈的置之不理就可以看出，这是一个怎么做都不会让人满意的功能，任何一个生态在面对巨大的用户群体的时候，功能的增减就会变成一个难题，所谓”林子大了什么鸟都有”，知乎面对的是同样的问题，营销类公众号在不断消费社会话题的同时，引导着一批又一批粉丝的价值取向，人类总渴望着别人了解自己，可人类真的了解自己吗？这篇博客是我对数据分析的又一次尝试，主要从性别、头像、签名、位置四个维度，对微信好友进行了一次简单的数据分析，主要采用图表和词云两种形式来呈现结果。总而言之一句话，”数据可视化是手段而并非目的”，重要的不是我们在这里做了这些图出来，而是从这些图里反映出来的现象，我们能够得到什么本质上的启示，我一位朋友问我怎么什么都想抓取，为什么啊，因为我不懂人类啊！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近微信迎来了一次重要的更新，允许用户对”发现”页面进行定制。不知道从什么时候开始，微信朋友圈变得越来越复杂，当越来越多的人选择”仅展示最近三天的朋友圈”，大概连微信官方都是一脸的无可奈何。逐步泛化的好友关系，让微信从熟人社交逐渐过渡到陌生人社交，而
      
    
    </summary>
    
      <category term="数据分析" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="http://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="Wechat" scheme="http://qinyuanpei.github.io/tags/Wechat/"/>
    
      <category term="matplotlib" scheme="http://qinyuanpei.github.io/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>使用Python生成博客目录并自动更新README</title>
    <link href="http://qinyuanpei.github.io/posts/1329254441/"/>
    <id>http://qinyuanpei.github.io/posts/1329254441/</id>
    <published>2018-02-23T09:32:45.000Z</published>
    <updated>2018-03-01T01:38:10.358Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是：<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。首先在这里祝大家春节快乐，作为过完年以后的第一篇文章，博主想写点内容风格相对轻松的内容。自从博主的博客采用 <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">TravisCI</a> 提供的持续集成(CI)服务以以来，博客的更新部署变得越来越简单，所有的流程都被简化为Git工作流下的<strong>提交(commit)</strong>和<strong>推送(push)</strong>操作。考虑到博客是托管在 <a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener">Github</a> 上的，一直希望可以自动更新仓库主页的README文件，这样可以显示每次提交代码后的变更历史。基于这样一个构想，我想到了为博客生成目录并自动更新README，其好处是可以为读者建立良好的文档导航，而且Markdown是一种简单友好的文档格式，Github等代码托管平台天生就支持Markdown文档的渲染。关于博客采用 <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">TravisCI</a>  提供持续集成(CI)服务相关内容，可以参考 <a href="https://qinyuanpei.github.io/posts/3521618732/">持续集成在Hexo自动化部署上的实践</a> 这篇文章。</p><p>&emsp;&emsp;好了，现在考虑如何为博客生成目录，我们这里需要三个要素，即标题、链接和时间。标题和时间可以直接从 <strong>_posts</strong> 目录下的Markdown文档中读取出来，链接从何而来呢？我最初想到的办法是读取每个Markdown文档的文件名，因为我的使用习惯是采用英文命名，这样当博客的<strong>永久链接(permalink)</strong>采用默认的<strong>:year/:month/:day/:title/</strong>形式时，每个Markdown文档的文件名等价于文章链接。事实证明这是一个愚蠢的想法，因为当你改变了<strong>永久链接(permalink)</strong>的形式时，这种明显投机的策略就会彻底的失败。相信你在浏览器种打开这篇文章时，已然注意到链接形式发生了变化，当然这是我们在稍后的文章中讨论的话题啦。至此，我们不得不寻找新的思路，那么这个问题该如何解决呢？</p><p>&emsp;&emsp;我意识到我的博客配置了 <a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="noopener">hexo-generator-json-content</a> 插件，这个插件最初的目的是为博客提供离线的搜索能力，该插件会在博客的根目录里生成一个<strong>content.json</strong>文件，而这个文件中含有我们想要的一切信息，因此我们的思路转变为解析这个文件，人生苦短啊，我果断选择了我最喜欢的Python，这里我们会提取出所有的文章信息，按照日期由近到远排序后生成列表。Python强大到让我觉得这篇文章无法下笔，所以这里直接给出代码啦：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文档实体结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,date,link,title)</span>:</span></span><br><span class="line">        self.date  = date</span><br><span class="line">        self.link  = link</span><br><span class="line">        self.title = title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTitle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLink</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'https://qinyuanpei.github.io/'</span> + self.link</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDate</span><span class="params">(self)</span>:</span></span><br><span class="line">        d = re.findall(<span class="string">r'\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;'</span>,self.date)[<span class="number">0</span>]</span><br><span class="line">        t = re.findall(<span class="string">r'\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;'</span>,self.date)[<span class="number">0</span>]</span><br><span class="line">        dt = <span class="string">'%s %s'</span> % (d,t)</span><br><span class="line">        <span class="keyword">return</span> datetime.datetime.strptime(dt,<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从JSON中加载文档数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadData</span><span class="params">()</span>:</span></span><br><span class="line">    json_file = open(<span class="string">'./public/content.json'</span>,<span class="string">'rb'</span>)</span><br><span class="line">    json_data = json.load(json_file)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> json_data:</span><br><span class="line">        <span class="keyword">yield</span> Post(item[<span class="string">'date'</span>],item[<span class="string">'path'</span>],item[<span class="string">'title'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从列表生成Markdown文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkMarkdown</span><span class="params">(items)</span>:</span></span><br><span class="line">    mdfile = open(<span class="string">'README.md'</span>,mode=<span class="string">'wt'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    itemTpl = <span class="string">'* &#123;0&#125; - [&#123;1&#125;](&#123;2&#125;)\n'</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        mdfile.write(itemTpl.format(</span><br><span class="line">            datetime.datetime.strftime(item.getDate(),<span class="string">'%Y-%m-%d'</span>),</span><br><span class="line">            item.getTitle(),</span><br><span class="line">            item.getLink()</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(__name__ == <span class="string">"__main__"</span>):</span><br><span class="line">    items = sorted(loadData(),key=<span class="keyword">lambda</span> x:x.getDate(),reverse=<span class="keyword">True</span>)</span><br><span class="line">    mkMarkdown(items)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里需要注意的有两个地方，第一，从JSON中解析出来的日期形式为：<strong>2018-02-23T01:32:45.000Z</strong>。对于这个形式的日期，博主先后尝试了内建的time模块和第三方的datetime模块，发现均无法直接转换为日期类型，所以首先采用正则匹配出日期和时间，然后再组合为标准的<strong>%Y-%m-%d %H:%M:%S</strong>的格式，这样就可以使用datetime模块进行处理啦，我还是想吐槽人类对各种各样format的执着，这些通配符在不同的语言中存在差别，就像SQL和正则引擎或多或少地存在兼容性问题一样。如果有朋友知道如何对这种日期形式进行转换，欢迎在博客中评论留言，再次谢谢大家。第二，使用内置函数sorted()对数据进行排序，lambda表达式使用起来非常棒，因为默认是升序排列地，而我们需要的是日期由近到远，所以这里选择了降序排列。</p><p>&emsp;&emsp;现在我们更新博客时的流程将发生变化，首先通过 <strong>hexo generate 或 hexo g</strong>命令生成博客，这样Hexo会为我们生成 <strong> content.json</strong>，然后我们执行这段Python脚本，就可以生成REAMD.md文件，这里我们将这个文件推送到blog分支。相对应地，我们修改 <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">TravisCI</a> 的脚本文件 <strong>.travis.yml</strong> 文件如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script:</span><br><span class="line">  - hexo clean</span><br><span class="line">  - hexo generate</span><br><span class="line">  - cp README.md ./public/README.md</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;显然，这是告诉 TravisCI 在生成博客以后，将 README.md 文件复制到输出文件，这样当我们推送博客(指生成的静态页面)到 master 分支的时候，它会和 blog 分支同步共享同一份 README 。我想一定有朋友会问我，难道生成 README.md 文件的步骤不能交给 TravisCI 来处理？一定要在推送到 blog 分支以前手动地去执行脚本吗？我最初尝试过让 TravisCI 去执行这个 Python 脚本，可我发现一个残酷的事实时，我们这个虚拟机环境是 nodejs 的，这在我们定义 <strong>.travis.yml</strong> 文件时就指定了，因此这个环境中可能是没有 Python 支持的。起初我以为 Linux 系统自带 Python ， 因此尝试在 <strong>.travis.yml</strong> 文件中使用 pip 安装相关依赖，然后我发现持续集成服务华丽丽地挂了，因为 TravisCI 默认的 Python 版本是 Python2.7 , 除非我们指定的是一个 Python 的语言环境，所以这种想法不得不作罢，暂时就手动更新好啦。</p><p>&emsp;&emsp;好了，这篇文章核心的内容就这么多，下面想说些关于 Hexo 的延伸话题。 Hexo 是一个基于 nodejs 的静态博客生成器，按理说使用 nodejs 去扩展功能是最佳的实践方式，所以即使 Python 再强大，我们在这里看到的依然存在着天然的割裂感， 我们能不能将执行Python脚本的这个过程合并到 <strong>hexo generate 或者 hexo g</strong>这个步骤中去呢？ 通过官方文档中关于<a href="https://hexo.io/api/events.html" target="_blank" rel="noopener">事件</a>和<a href="https://hexo.io/api/events.html" target="_blank" rel="noopener">生成器</a>的描述，我们获得了两种新的思路，分别是在生成页面以后通过 child_process 模块调用 python 脚本、通过 Locals 变量获取全部文章信息后生成Markdown。从方案是否优雅的角度上来讲，我个人更倾向于第二种方案。基本的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案一</span></span><br><span class="line">hexo.on(<span class="string">'generateAfter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">post</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span>通过content.json文件生成markdown文档</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案二</span></span><br><span class="line">hexo.extend.generator.register(<span class="string">"markdown"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span>通过posts属性生成markdown文档</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;显然，我是不会写 nodejs 的，如果有时间和精力的话，我可能会考虑采用第二种方案写一个插件，可是像我这么懒的一个人，还是不要提前立 flag 啦，毕竟人生苦短呐，我都选择使用 Python 这门语言来写啦，我干嘛非要再花时间去迎合它呢？好啦，这篇文章就是这样啦，本文中的脚本可以到 <a href="https://github.com/qinyuanpei/BlogScripts/blob/master/HexoBlog.py" target="_blank" rel="noopener">这里</a> 来获取，本文生成的目录可以到 <a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener">这里</a> 来访问，再次谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是：&lt;a href=&quot;https://qinyuanpei.github.io&quot;&gt;https://qinyuanpei.github.io&lt;/a&gt;。首先在这里祝大家春节快乐，作为过完
      
    
    </summary>
    
      <category term="独立博客" scheme="http://qinyuanpei.github.io/categories/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Github" scheme="http://qinyuanpei.github.io/tags/Github/"/>
    
      <category term="Python" scheme="http://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="Script" scheme="http://qinyuanpei.github.io/tags/Script/"/>
    
  </entry>
  
  <entry>
    <title>愿你和我一样喜欢蛋炒饭</title>
    <link href="http://qinyuanpei.github.io/posts/1933583281/"/>
    <id>http://qinyuanpei.github.io/posts/1933583281/</id>
    <published>2018-02-10T16:12:25.000Z</published>
    <updated>2018-03-01T01:38:10.358Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;周末花了一个晚上的时间看了部电影，由黄渤主演的《蛋炒饭》。有人说，这是一部刻意模仿《阿甘正传》的电影，充满胶片质感的纪录片风格，相似的镜头语言和表现手法，无一不在努力告诉你，这是一部本土化的《阿甘正传》。可是如同巧克力之于蛋炒饭，两种截然不同的食物会有不同的味道，电影所反映的实则是两种不同的内涵。如果说《阿甘正传》代表的是极具美国精神的励志故事，那么《蛋炒饭》代表的则是小人物为理想打拼的乌托邦。说《蛋炒饭》是本土化的《阿甘正传》其实不无道理，因为电影里充满了太多相似，这种在由时代感打磨出的细腻的情感，让我觉得这是一部值得一看的电影。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211094000741" alt="电影《阿甘正传》经典开头" title="">                </div>                <div class="image-caption">电影《阿甘正传》经典开头</div>            </figure><p>&emsp;&emsp;电影开头苏茉莉坐在游乐园长凳上自下而上的长镜头，不禁让人联想到《阿甘正传》的开场，联想到那片空中摇曳着的羽毛；电影中反复出现的台词，来自大卫父亲的那句：做蛋炒饭要慢要慢，一如《阿甘正传》里的经典台词：人生就像一盒巧克力，你永远不知道下一块会是哪种？电影令我印象深刻的地方，在于它具厚重的时代感，中美建交、改革开放、金融危机、邓丽君、摇滚音乐、周杰伦、周笔畅……看起来王大卫好像和阿甘一样，参与并影响了众多历史事件。可我的理解是，阿甘最终成为了流浪街头的大富翁，而王大卫一直一无所有，因为他一辈子都在做一件事情，那就是做蛋炒饭。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/201802110925019" alt="最美好的年纪" title="">                </div>                <div class="image-caption">最美好的年纪</div>            </figure><p>&emsp;&emsp;整个电影采用的是倒叙的表现手法。主人公王大卫是一个智商不太高，而且有语言表达障碍的“傻子”，他第一次出场是替好兄弟打抱不平，结果他就像星爷《功夫》里的少年一样，以为自己的武功盖世无双，结果自然是被人打得头破血流；他书包里藏着的“复仇”的板砖，在外国友人访华的时候，一板砖破坏了中美友谊，结果自然是被校长通报批评；他家祖上是宫廷御厨，父亲即将退休食堂安排他去顶岗，一心想做厨师的他差点烧了厨房，结果自然是迫使父亲替他求情以保住工作；他从小喜欢的女孩苏茉莉要和好兄弟发生关系，她吻了他一下叫他在门口把风，结果自然是茉莉被渣男欺骗然后甩了他；他用母亲变卖古董的钱来了饭店，好兄弟嫉妒他做了老板，骗走他的产业后远走高飞，结果自然是他从老板变成杂工。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211094910921" alt="有些爱就像一阵风" title="">                </div>                <div class="image-caption">有些爱就像一阵风</div>            </figure><p>&emsp;&emsp;看这个电影的时候，我一直觉得人生是绝望的，父母先后离开人世，哥哥在面前自杀而死，喜欢的女生抛弃自己，好兄弟发小欺骗自己……周围人对他全部是冷嘲热讽，每次发工资的时候，嘲弄他什么时候攒够钱赎回饭店；每次娱乐圈有绯闻传来的时候，说他“媳妇”苏茉莉又登上杂志封面；“好兄弟“因为金融危机背负债务，他就拎着辛苦攒下的一袋子零钱去帮他还债，结果半夜“好兄弟”开着车跑了……我不知道，我们该不该认同这种无条件“傻”的行为，电影想告诉我们的或许是“以德报怨，以德服人”这种儒家的传统思想，即在复杂的社会中，如何以一种淳朴单纯的心态，追寻本心，不畏曲折。所谓“众生虽苦，诸恶莫作”，这个社会复杂险恶是现实，可温润善良则是一种选择。我们抱怨时代给我们选择狭窄，因为我们放弃了那些艰难的选择，最终选择大多数人选择的那条路。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211095932714" alt="李红兵：人都是会变的" title="">                </div>                <div class="image-caption">李红兵：人都是会变的</div>            </figure><p>&emsp;&emsp;可我还是想说，无条件的善良是懦弱，我们选择善良，是因为我们不想伤害别人，可在今天这样一个时代，善良常常被当做是懦弱的表现，一个人努力让心变狠变硬，或许会达到通常意义上的成功，可成功的定义从来都是被人绑架着的，电影中“好兄弟”登上了“胡弄排行榜”，我不知道这是不是导演的一种讽刺，一个人靠着骗取好兄弟的产业而发家，即使收获了声名和利益，当他一个人在高速公路上疾驶，打算远走他乡的时候，内心是不是会有一点羞愧和遗憾呢？我们说，这是一部乌托邦式的电影，因为现实中像李红兵这样的人，绝对不会陡然间良心发现，把饭店归还王大卫，甚至王大卫拉开窗帘阳光照射进来，阳光下苏茉莉牵着女儿的手对他微笑，大卫的蛋炒饭得到溥仪认可，入选国际非遗名录……我宁愿相信，这是一种美好的理想。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211092759718" alt="大卫做蛋炒饭" title="">                </div>                <div class="image-caption">大卫做蛋炒饭</div>            </figure><p>&emsp;&emsp;大卫在电影中做过三次蛋炒饭，第一次是他顶替父亲的岗位到食堂工作，结果想做厨师的他差点烧了厨房，付出的代价是，因为御厨身份而自豪的父亲，向一辈子没低过头的食堂经理低头；第二次是他陪苏茉莉到医院流产，打完胎的苏茉莉说自己饿，他冒着被饭店人追打的危险，给苏茉莉做了一份蛋炒饭，付出的代价是，苏茉莉同他告别，独自到南方发展演艺事业；第三次是李红兵归还了饭店，成名后的王大卫，当着记者的面做了一次蛋炒饭，溥仪评价大卫的蛋炒饭，比他爷爷做得还要好，蛋炒饭入选国际非遗名录。大卫的一生都在做一件事情，那就是做蛋炒饭，这种专注是他和阿甘不一样的地方，在一个浮躁的时代，我们每天都在追逐都在忙碌，可我们追逐的是什么呢？或许是一盘蛋炒饭的安宁，从这个角度来说，蛋炒饭这种食物，真的是质朴而简单的存在啦。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211094532546" alt="有些人像你生命里的天使" title="">                </div>                <div class="image-caption">有些人像你生命里的天使</div>            </figure><p>&emsp;&emsp;如果你看过《阿甘正传》这部电影，会觉得苏茉莉和珍妮这两个角色是相似的。她们看起来都知道自己想要些什么，苏茉莉选择发展演艺事业进入娱乐圈，珍妮一直知道自己想要什么，她想做一名歌手，为了唱歌吃尽苦头，在酒吧、街头甚至任何可以唱歌的地方，只有有场合给她吉他，她就可以唱，甚至为了唱歌而穷困潦倒到卖身吸毒……她可以真挚地给成名的阿甘一个拥抱，而不愿依附他达到自己成名的目的，她深爱阿甘的同时，深知阿甘不会同自己结婚，因为童年的经历让她内心无比自卑，她始终打不开心里的结，她选择为阿甘生下孩子，这是一种自我成全。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211094252365" alt="愿茉莉一直这样美好" title="">                </div>                <div class="image-caption">愿茉莉一直这样美好</div>            </figure><p>&emsp;&emsp;苏茉莉成名后取艺名苏菲，据说这个人物原型来自王菲，苏茉莉在成名过程中不断豪门势力，从最初回北京办演唱会拉赞助，到嫁入豪门以后受不了娱乐圈绯闻骚扰，进而宣布退出娱乐圈回到北京，她是一个不知道自己想要什么的人，直到故事最后她终于发现，原来那个深爱着自己的人，一直就在默默地等自己回来。所以对比两部电影中的女主，就可以发现，两部电影阐述的观点是截然相反的，即阿甘是迷茫的，而珍妮是坚定的；王大卫是坚定的，而苏茉莉是迷茫的。当你不知道想要什么的时候，不妨慢下来做份蛋炒饭，或许你就会找到答案。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180211104230957" alt="你饿不饿，我做蛋炒饭给你吃呀" title="">                </div>                <div class="image-caption">你饿不饿，我做蛋炒饭给你吃呀</div>            </figure><p>&emsp;&emsp;故事接近尾声的时候，王大卫再次登上三个人从小便常去的城楼，猛然间看到三个孩子正在那里玩耍，孩子们说这是他们的地盘，王大卫还是像从前一样，知趣地准备转身离开，阳光照耀城楼的刹那，我分明看见他脸上满意的笑容，那种历经沧桑后初心不改的从容。每个人，都既注定的命运，同时有偶然，两者都在同时发生，就像那片羽毛，努力飘啊飘啊，终于飘到阿甘脚下，然后又无可奈何的飘离阿甘。羽毛不是飞鸟，无法掌控飞行的方向，其实很想和你在一起，但偏偏风把距离吹得好远。如果可以的话，我想你和我一样，都喜欢蛋炒饭。你饿不饿，我做蛋炒饭给你吃呀？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;周末花了一个晚上的时间看了部电影，由黄渤主演的《蛋炒饭》。有人说，这是一部刻意模仿《阿甘正传》的电影，充满胶片质感的纪录片风格，相似的镜头语言和表现手法，无一不在努力告诉你，这是一部本土化的《阿甘正传》。可是如同巧克力之于蛋炒饭，两种截然不同的食物会
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="蛋炒饭" scheme="http://qinyuanpei.github.io/tags/%E8%9B%8B%E7%82%92%E9%A5%AD/"/>
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>基于Python实现Windows下壁纸切换功能</title>
    <link href="http://qinyuanpei.github.io/posts/2822230423/"/>
    <id>http://qinyuanpei.github.io/posts/2822230423/</id>
    <published>2018-02-05T16:48:39.000Z</published>
    <updated>2018-03-01T01:38:10.358Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在过去一年多的时间里，我尝试改变博客的写作风格，努力让自己不再写教程类文章，即使在这个过程中，不断地面临着写作内容枯竭的痛苦。因为我渐渐地意识到，告诉别人如何去做一件事情，始终停留在”术”的层面，而比这个更为重要的是，告诉别人为什么要这样做，这样就可以过渡到”道”的层面。古人云：形而上者谓之道，形而下者谓之器。我们常常希望通过量变来产生质变，可是如果在这个过程中不能及时反思和总结，我们认为的努力或许仅仅是重复的劳作而已。如你所见，在这篇文章里，我们将通过Python和Windows注册表实现壁纸切换功能，主要涉及到的Python中的requests、pyinstaller这两个模块的使用，希望大家喜欢。</p><h1 id="故事缘由"><a href="#故事缘由" class="headerlink" title="故事缘由"></a>故事缘由</h1><p>&emsp;&emsp;人们常常相信事出有因，可这世界上有些事情，哪里会有什么原因啊，比如喜欢与不喜欢。做这样一个小功能的初衷，起源于我对桌面壁纸的挑剔。作为一个不完全的强迫症患者，我需要花费大量时间去挑选一张壁纸，丝毫不亚于在网上挑选一件喜欢的商品。我注意到知乎上有这样的话题：<a href="https://www.zhihu.com/question/22857942" target="_blank" rel="noopener">有哪些无版权图片网站值得推荐？</a>，因此对于桌面壁纸的筛选，我渐渐地开始摆脱对搜索引擎的依赖，我个人比较喜欢<a href="https://www.pexels.com" target="_blank" rel="noopener">Pexels</a>和<a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a>这两个网站，所以我想到了从这两个网站抓取图片来设置Windows壁纸的方案。市面上类似的商业软件有<a href="http://bizhi.baidu.com/" target="_blank" rel="noopener">百度壁纸</a>、<a href="http://bizhi.sogou.com/index.html" target="_blank" rel="noopener">搜狗壁纸</a>等，可这些软件都不纯粹，或多或少地掺杂了额外功能，个中缘由想来大家都是知道的。联想到微信最新版本的更新，”发现”页面支持所有项目的隐藏，甚至是盟友京东的电商入口和腾讯最赚钱的游戏入口，这让我开始正视腾讯这家公司，我收回曾经因为抄袭对腾讯产生的不满，腾讯是一家值得尊重的互联网公司。做一个纯粹的应用程序，这就是我的初心。</p><h1 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h1><p>&emsp;&emsp;好了，现在我们考虑如何来实现这个功能，我们的思路是从<a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a>这个网站抓取图片，并将其存储在指定路径，然后通过Windows API完成壁纸的设置。Python脚本会通过pyinstaller模块打包成可执行文件，我们通过修改注册表的方式，在右键菜单内加入切换壁纸的选项，这样我们可以直接通过右键菜单实现壁纸切换功能。在编写脚本的时候，起初想到的是抓包这样的常规思路，因为请求过程相对复杂而失败，后来意外地发现官方提供了API接口。事实上<a href="https://www.pexels.com" target="_blank" rel="noopener">Pexels</a>和<a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a>都提供了API接口，通过调用这些API接口，我们的探索进行得非常顺利，下面是具体脚本实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Query Images</span></span><br><span class="line">searchURL = <span class="string">'https://unsplash.com/napi/search?client_id=%s&amp;query=%s&amp;page=1'</span></span><br><span class="line">client_id = <span class="string">'fa60305aa82e74134cabc7093ef54c8e2c370c47e73152f72371c828daedfcd7'</span></span><br><span class="line">categories = [<span class="string">'nature'</span>,<span class="string">'flowers'</span>,<span class="string">'wallpaper'</span>,<span class="string">'landscape'</span>,<span class="string">'sky'</span>]</span><br><span class="line">searchURL = searchURL % (client_id,random.choice(categories))</span><br><span class="line">response = requests.get(searchURL)</span><br><span class="line">print(<span class="string">u'正在从Unsplash上搜索图片...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse Images</span></span><br><span class="line">data = json.loads(response.text)</span><br><span class="line">results = data[<span class="string">'photos'</span>][<span class="string">'results'</span>]</span><br><span class="line">print(<span class="string">u'已为您检索到图片共%s张'</span> % str(len(results)))</span><br><span class="line">results = list(filter(<span class="keyword">lambda</span> x:float(x[<span class="string">'width'</span>])/x[<span class="string">'height'</span>] &gt;=<span class="number">1.33</span>,results))</span><br><span class="line">result = random.choice(results)</span><br><span class="line">resultId = str(result[<span class="string">'id'</span>])</span><br><span class="line">resultURL = result[<span class="string">'urls'</span>][<span class="string">'regular'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download Images</span></span><br><span class="line">print(<span class="string">u'正在为您下载图片:%s...'</span> % resultId)</span><br><span class="line">basePath = sys.path[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span>(os.path.isfile(basePath)):</span><br><span class="line">    basePath = os.path.dirname(basePath)</span><br><span class="line">baseFolder = basePath + <span class="string">'\\Download\\'</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> path.exists(baseFolder)):</span><br><span class="line">    os.makedirs(baseFolder)</span><br><span class="line">jpgFile = baseFolder + resultId + <span class="string">'.jpg'</span></span><br><span class="line">bmpFile = baseFolder + resultId + <span class="string">'.bmp'</span></span><br><span class="line">response = requests.get(resultURL)</span><br><span class="line"><span class="keyword">with</span> open(jpgFile,<span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(response.content)</span><br><span class="line">img = Image.open(jpgFile)</span><br><span class="line">img.save(bmpFile,<span class="string">'BMP'</span>)</span><br><span class="line">os.remove(jpgFile)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这部分代码非常简单，需要关注的地方有：第一，这个API对应的密钥是公共的，即所有人都可以使用，这里随机从指定的分类中去搜索图片。第二，这里使用filter()函数过滤出宽高比超过1.33的图片，即分辨率为1366 * 768的图片。这里需要注意的是，在Python3.X下filter需要转化为list，否则会引发一个异常。第三，下载的图片默认为JPEG格式，而Windows下设置壁纸使用的是位图格式，即BMP格式，所以在这里我们使用PIL模块来完成格式转换。这里需要注意的是，PIL模块目前不支持Python3.X以后的版本，我们这里使用的是Pillow模块，该模块可以通过pip直接完成安装。</p><p>&emsp;&emsp;现在，我们将壁纸下载到本地以后，就可以着手设置壁纸相关的工作。这些工作主要借助为win32api和win32gui这两个内置模块，我们一起来看具体代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">u'正在设置图片:%s为桌面壁纸...'</span> % resultId)</span><br><span class="line">key = win32api.RegOpenKeyEx(win32con.HKEY_CURRENT_USER,</span><br><span class="line">    <span class="string">"Control Panel\\Desktop"</span>,<span class="number">0</span>,win32con.KEY_SET_VALUE)</span><br><span class="line">win32api.RegSetValueEx(key, <span class="string">"WallpaperStyle"</span>, <span class="number">0</span>, win32con.REG_SZ, <span class="string">"2"</span>) </span><br><span class="line"><span class="comment">#2拉伸适应桌面,0桌面居中</span></span><br><span class="line">win32api.RegSetValueEx(key, <span class="string">"TileWallpaper"</span>, <span class="number">0</span>, win32con.REG_SZ, <span class="string">"0"</span>)</span><br><span class="line">win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, bmpFile, <span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line">print(<span class="string">u'成功应用图片:%s为桌面壁纸'</span>  % resultId)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这部分内容非常简单，基本没有复杂的东西在里面。接下来我们需要通过pyinstaller模块将脚本打包成可执行文件，实际上这个步骤完全可以省略，因为现在我们通过命令行就可以实现壁纸切换，为什么要做这样额外的工作呢？考虑到Windows下GUI更为便捷一点，所以我们打包成可执行文件，主要是为了给右键菜单添加功能，我们最终点击想要实现的功能是，点击右键菜单就可以完成壁纸的切换。首先通过pip安装pyinstaller模块，在终端下执行命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install pyinstaller</span><br></pre></td></tr></table></figure></p><p>安装完成后按照<a href="http://www.pyinstaller.org/" target="_blank" rel="noopener">官方</a>文档即可在./dist/目录中找到生成的可执行文件，如果打包出错可以修改Python根目录下的./Scripts/pyinstaller-script.py文件，修改第一行Python.exe的路径，删除两端的引号即可，如下图所示。关于pyinstaller模块打包时的详细参数设定，请自行查阅官方文档。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180207140459403" alt="pyinstaller-script.py文件" title="">                </div>                <div class="image-caption">pyinstaller-script.py文件</div>            </figure><p>&emsp;&emsp;现在，在生成可执行文件以后，我们打开注册表，定位到以下节点：<br><strong>计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</strong>，然后创建一级子节点WallPaper，其默认值填写”更换壁纸”，接下来创建二级子节点command，注意这个名称不能修改，其默认值填写可执行文件路径，本例中为：E:\Software\WallPaper\main.exe，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180207140515219" alt="为右键菜单增加" 更换壁纸"选项"="" title="">                </div>                <div class="image-caption">为右键菜单增加"更换壁纸"选项</div>            </figure><p>&emsp;&emsp;好了，现在我们可以看看在右键菜单中增加”更换壁纸”选项以后的效果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180207143108184" alt="最终效果" title="">                </div>                <div class="image-caption">最终效果</div>            </figure></p><h1 id="文本小结"><a href="#文本小结" class="headerlink" title="文本小结"></a>文本小结</h1><p>&emsp;&emsp;本文使用Python实现了Windows下切换壁纸的功能，通过requests模块从网络上抓取图片，通过PIL模块实现JPEG格式到BMP格式的转换，通过win32api和win32gui模块实现壁纸设置，并通过修改注册表的方式，将这一功能整合到系统菜单中，可以非常便捷地更换桌面壁纸。作为一个设计上的扩展，我们需要考虑更多的问题，比如当网络断开的时候如何避免异常，如何接入更多的在线图库API，如何支持可配置的图片分类信息以及如何将修改注册表的过程自动化等等，这些问题博主会利用空闲时间去解决，今天这篇文章就是这样啦，本文源代码可以通过<a href="https://github.com/qinyuanpei/WallPaper" target="_blank" rel="noopener">这里</a>获取，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在过去一年多的时间里，我尝试改变博客的写作风格，努力让自己不再写教程类文章，即使在这个过程中，不断地面临着写作内容枯竭的痛苦。因为我渐渐地意识到，告诉别人如何去做一件事情，始终停留在”术”的层面，而比这个更为重要的是，告诉别人为什么要这样做，这样就可
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="脚本" scheme="http://qinyuanpei.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="Windows" scheme="http://qinyuanpei.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出理解Python装饰器</title>
    <link href="http://qinyuanpei.github.io/posts/2829333122/"/>
    <id>http://qinyuanpei.github.io/posts/2829333122/</id>
    <published>2018-01-23T15:55:13.000Z</published>
    <updated>2018-03-01T01:38:10.362Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。今天我想和大家一起探讨的话题是Python中的装饰器。因为工作关系最近这段时间在频繁地使用Python，而我渐渐意识到这是一个非常有趣的话题。无论是在Python标准库还是第三方库中，我们越来越频繁地看到装饰器的身影，从某种程度上而言，Python中的装饰器是Python进阶者的一条必由之路，正确合理地使用装饰器可以让我们的开发如虎添翼。装饰器天然地和函数式编程、设计模式、AOP等概念产生联系，这更加让我对Python中的这个特性产生兴趣。所以，在这篇文章中我将带领大家一起来剖析Python中的装饰器，希望对大家学习Python有所帮助。</p><h1 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h1><p>&emsp;&emsp;什么是装饰器？这是一个问题。在我的认知中，装饰器是一种语法糖，其本质就是函数。我们注意到Python具备函数式编程的特征，譬如lambda演算，map、filter和reduce等高阶函数。在函数式编程中，函数是一等公民，即“一切皆函数”。Python的函数式编程特性由早期版本通过渐进式开发而来，所以对“一切皆对象”的Python来说，函数像普通对象一样使用，这是自然而然的结果。为了验证这个想法，我们一起来看下面的示例。</p><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line">func = square</span><br><span class="line"><span class="keyword">print</span> func    <span class="comment">#&lt;function square at 0x01FF9FB0&gt;</span></span><br><span class="line"><span class="keyword">print</span> func(<span class="number">5</span>) <span class="comment">#25</span></span><br></pre></td></tr></table></figure><p>可以注意到，我们将一个函数直接赋值给一个变量，此时该变量表示的是一个函数对象的实例，什么叫做函数对象呢？就是说你可以将这个对象像函数一样使用，所以当它带括号和参数时，表示立即调用一个函数；当它不带括号和参数时，表示一个函数。在C#中我们有一个相近的概念被称为委托，而委托本质上是一个函数指针，即表示指向一个方法的引用，从这个角度来看，C#中的委托类似于这里的函数对象，因为Python是一个动态语言，所以我们可以直接将一个函数赋值给一个对象，而无需借助Delegate这样的特殊类型。</p><ul><li><p>使用函数作为参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_square</span><span class="params">(f,m,n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(m) + f(n)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">print</span> sum_square(square,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">#25</span></span><br></pre></td></tr></table></figure></li><li><p>使用函数作为返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_wrapper</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n * n</span><br><span class="line">    <span class="keyword">return</span> square</span><br><span class="line">    </span><br><span class="line">wrapper = square_wrapper()</span><br><span class="line"><span class="keyword">print</span> wrapper(<span class="number">5</span>) <span class="comment">#25</span></span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;既然在Python中存在函数对象这样的类型，可以让我们像使用普通对象一样使用函数。那么，我们自然可以将函数推广到普通对象适用的所有场合，即考虑让函数作为参数和返回值，因为普通对象都都具备这样的能力。为什么要提到这两点呢？因为让函数作为参数和返回值，这不仅是函数式编程中高阶函数的基本概念，而且是闭包、匿名方法和lambda等特性的理论基础。从ES6中的箭头函数、Promise、React等可以看出，函数式编程在前端开发中越来越流行，而这些概念在原理上是相通的，这或许为我们学习函数式编程提供了一种新的思路。在这个示例中，<strong>sum_square()</strong>和<strong>square_wrapper()</strong>两个函数，分别为我们展示了使用函数作为参数和返回值的可行性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(m)</span>:</span></span><br><span class="line">    n = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> m + n</span><br><span class="line">    <span class="keyword">return</span> outer</span><br><span class="line"></span><br><span class="line">func = outer(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> func() <span class="comment">#15</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#内函数修改外函数局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(a)</span>:</span></span><br><span class="line">    b = [<span class="number">10</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        b[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a + b[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> func() <span class="comment">#16</span></span><br><span class="line"><span class="keyword">print</span> func() <span class="comment">#17</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对Python这门语言来说，这里的outer()函数和inner()函数分别被称为外函数和内函数，变量n的定义不在inner()函数内部，因此变量n称为inner()函数的环境变量。在Python中，一个函数及其环境变量就构成了闭包(<strong>Closure</strong>)。要理解闭包我认为我们可以把握这三点：第一，外函数返回了内函数的引用，即我们调用outer()函数时返回的是inner()函数的引用；第二，外函数将自己的局部变量绑定到内函数，其中变量b的目的是展示如何在内函数中修改环境变量；第三，调用内函数意味着发生出、入栈，不同的是每次调用都共享同一个闭包变量，请参考第二个示例。好了，现在讲完闭包以后，我们就可以开始说Python中的装饰器啦。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>&emsp;&emsp;装饰器是一种高级Python语法，装饰器可以对一个函数、方法或者类进行加工。所以，装饰器就像女孩子的梳妆盒，经过一番打扮后，可以让女孩子更漂亮。装饰器使用起来是非常简单的，其难点主要在如何去写一个装饰器。带着这个问题，我们来一起看看Python中的装饰器是如何工作的，以及为什么我们说装饰器的本质就是函数。早期的Python中并没有装饰器这一语法，最早出在Python 2.5版本中且仅仅支持函数的装饰，在Python 2.6及以后版本中装饰器被进一步用于类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_print</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*arg)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> arg</span><br><span class="line">        <span class="keyword">return</span> func(*arg)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_print</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x+y,array)</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> sum(data)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们注意到装饰器可以使用def来定义，装饰器接收一个函数对象作为参数，并返回一个新的函数对象。装饰器通过名称绑定，让同一个变量名指向一个新返回的函数对象，这样就达到修改函数对象的目的。在使用装饰器时，我们通常会在新函数内部调用旧函数，以保留旧函数的功能，这正是“装饰”一词的由来。在定义好装饰器以后，就可以使用@语法了，其实际意义时，将被修饰对象作为参数传递给装饰器函数，然后将装饰器函数返回的函数对象赋给原来的被修饰对象。装饰器可以实现代码的可复用性，即我们可以用同一个装饰器修饰多个函数，以便实现相同的附加功能。在这个示例中，我们定义了一个decorator_print的装饰器函数，它负责对一个函数func进行修饰，在调用函数func以前执行print语句，进而可以帮助我们调试函数中的参数，通过@语法可以让我们使用一个名称去绑定一个函数对象。在这里，它的调用过程可以被分解为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = decorator_print(sum)</span><br><span class="line"><span class="keyword">print</span> sum()</span><br></pre></td></tr></table></figure></p><p>接下来，我们再来写一个统计代码执行时长的装饰器decorator_watcher:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_watcher</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*arg)</span>:</span></span><br><span class="line">        t1 = time.time()</span><br><span class="line">        result = func(*arg)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        print(<span class="string">'time:'</span>,t2-t1)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p><p>此时我们可以使用该装饰器来统计sum()函数执行时长：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator_watcher</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x+y,array)</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> sum(data)</span><br></pre></td></tr></table></figure></p><p>现在，这个装饰器打印出来的信息格式都是一样的，我们无法从终端中分辨它对应哪一个函数，因此考虑给它增加参数以提高辨识度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_watcher</span><span class="params">(funcName=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*arg)</span>:</span></span><br><span class="line">            t1 = time.time()</span><br><span class="line">            result = func(*arg)</span><br><span class="line">            t2 = time.time()</span><br><span class="line">            print(<span class="string">'%s time:'</span> % funcName,t2-t1)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_watcher('sum')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x+y,array)</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> sum(data)</span><br></pre></td></tr></table></figure></p><p>装饰器同样可以对类进行修饰，譬如我们希望某一个类支持单例模式，在C#中我们定义泛型类Singleton<t>。下面演示如何通过装饰器来实现这一功能：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">instances = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInstance</span><span class="params">(aClass, *args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> aClass <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">        instances[aClass] = aClass(*args)</span><br><span class="line">    <span class="keyword">return</span> instances[aClass]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(aClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onCall</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getInstance(aClass,*args)</span><br><span class="line">    <span class="keyword">return</span> onCall</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,hours,rate)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.hours = hours</span><br><span class="line">        self.rate = rate</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.hours * self.rate</span><br></pre></td></tr></table></figure></t></p><p>&emsp;&emsp;除此以外，Python标准库中提供了诸如classmethod、staticmethod、property等类装饰器，感兴趣的读者朋友可以自行前去研究，这里不再赘述。</p><h1 id="装饰器与设计模式"><a href="#装饰器与设计模式" class="headerlink" title="装饰器与设计模式"></a>装饰器与设计模式</h1><p>&emsp;&emsp;装饰器可以对函数、方法和类进行修改，同时保证原有功能不受影响。这自然而然地让我想到面向切面编程(<strong>AOP</strong>)，其核心思想是，以非侵入的方式，在方法执行前后插入代码片段，以此来增强原有代码的功能。面向切面编程(<strong>AOP</strong>)通常通过代理模式(静态/动态)来实现，而与此同时，在Gof提出的“设计模式”中有一种设计模式被称为装饰器模式，这两种模式的相似性，让我意识到这会是一个有趣的话题，所以在接下来的部分，我们将讨论这两种设计模式与装饰器的内在联系。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>&emsp;&emsp;<strong>代理模式</strong>，属于23种设计模式中的结构型模式，其核心是为真实对象提供一种代理来控制对该对象的访问。在这里我们提到了<strong>真实对象</strong>，这就要首先引出代理模式中的三种角色，即<strong>抽象对象</strong>、<strong>代理对象</strong>和<strong>真实对象</strong>。其中：</p><ul><li><strong>抽象对象</strong>：通过接口或抽象类声明真实角色实现的业务方法。</li><li><strong>代理对象</strong>：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法。</li><li><strong>真实对象</strong>：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</li></ul><p>&emsp;&emsp;下面是一个典型的代理模式UML图示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180202094102971" alt="代理模式" title="">                </div>                <div class="image-caption">代理模式</div>            </figure></p><p>&emsp;&emsp;通过UML图我们可以发现，代理模式通过代理对象隐藏了真实对象，实现了调用者对真实对象的访问控制，即调用者无法直接接触到真实对象。“代理”这个词汇是一个非常生活化的词汇，因为我们可以非常容易地联系到生活种的中介这种角色，譬如租赁房屋时会存在房屋中介这种角色，租客(<strong>调用者</strong>)通过中介(<strong>代理对象</strong>)来联系房东(<strong>真实对象</strong>)，这种模式有什么好处呢？中介(<strong>代理对象</strong>)的存在隔离了租客(<strong>调用者</strong>)与房东(<strong>真实对象</strong>)，有效地保护了房东(<strong>真实对象</strong>)的个人隐私，使其免除了频繁被租客(调用者)骚扰的困惑，所以代理模式的强调的是<strong>控制</strong>。</p><p>&emsp;&emsp;按照代理机制上的不同来划分，代理模式可以分为<strong>静态代理</strong>和<strong>动态代理</strong>。前者是将<strong>抽象对象</strong>、<strong>代理对象</strong>和<strong>真实对象</strong>这三种角色在编译时就确定下来。对于C#这样的静态强类型语言而言，这意味着我们需要手动定义出这些类型；而后者则是指在运行时期间动态地创建代理类，譬如Unity、Ca’stle、Aspect Core以及ASP.NET中都可以看到这种技术的身影，即所谓的“动态编织”技术，通过反射机制和修改IL代码来达到动态代理的目的。通常意义上的代理模式，都是指静态代理，下面我们一起来看代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RealSubject</span> : <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"我是RealSubject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProxySubject</span> : <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ISubject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过示例代码，我们可以注意到，在代理对象ProxySubject中持有对ISubject接口的引用，因此它可以代理任何实现了ISubject接口的类，即真实对象。在Request()方法中我们调用了真实对象的Request()方法，实际上我们可以在代理对象中增加更多的细节，譬如在Request()方法执行前后插入指定的代码，这就是面向切面编程(<strong>AOP</strong>)的最基本的原理。在实际应用中，主要以动态代理最为常见，Java中提供了InvocationHandler接口来实现这一接口，在.NET中则有远程调用(<strong>Remoting Proxies</strong>)、<strong>ContextBoundObject</strong>和<strong>IL织入</strong>等多种实现方式。从整体而言，生成代理类和子类化是常见的两种思路。相比静态代理，动态代理机制相对复杂，不适合在这里展开来说，感兴趣的朋友可以去做进一步的了解。</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>&emsp;&emsp;<strong>装饰器模式</strong>，同样是一种结构型模式，其核心是为了解决由继承引发的“类型爆炸”问题。我们知道，通过继承增加子类就可以扩展父类的功能，可随着业务复杂性的不断增加，子类变得越来越多，这就会引发“类型爆炸”问题。<strong>装饰器模式</strong>就是一种用以代替继承的技术，即无需通过继承增加子类就可以扩展父类的功能，同时不改变原有的结构。在《西游记》中孙悟空和二郎神斗法，孙悟空变成了一座庙宇，这是对原有功能的一种扩展，因为孙悟空的本质依然是只猴子，不同的是此刻具备了庙宇的功能。这就是装饰器模式。下面，我们一起来看一个生活中的例子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180202130527268" alt="咖啡种类" title="">                </div>                <div class="image-caption">咖啡种类</div>            </figure><p>&emsp;&emsp;喜欢喝咖啡的朋友，看到这张图应该感到特别亲切，因为咖啡的种类的确是太多啦。在开始喝咖啡以前，我完全不知道咖啡会有这么多的种类，而且咖啡作为一种略显小资的饮品，其名称更是令人目不暇接，一如街头出现的各种女孩子喜欢的茶品饮料，有些当真是教人叫不出来名字。这是一个典型的“类型爆炸”问题，人们在吃喝上坚持不懈的追求，让咖啡的种类越来越多，这个时候继承反而变成了一种沉重的包袱，那么该如何解决这个问题呢？装饰器模式应运而生，首先来看装饰器模式的UML图示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180202113809724" alt="装饰器模式" title="">                </div>                <div class="image-caption">装饰器模式</div>            </figure></p><p>&emsp;&emsp;从这个图示中可以看出，装饰器和被装饰者都派生自同一个抽象类Component，而不同的Decorator具备不同的功能，DecoratorA可以为被装饰者扩展状态，DecoratorB可以为被装饰者扩展行为，可无论如何，被装饰者的本质不会发生变化，它还是一个Component。回到咖啡这个问题，我们发现这些咖啡都是由浓缩咖啡、水、牛奶、奶泡等组成，所以我们可以从一杯浓缩咖啡开始，对咖啡反复进行调配，直至搭配出我们喜欢的咖啡，这个过程就是反复使用装饰器进行装饰的过程，因此我们可以写出下面的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饮料抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Drink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Drink <span class="title">Mix</span>(<span class="params">Drink drink</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//牛奶装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MilkDecorator</span> : <span class="title">Drink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Drink milk;</span><br><span class="line">    MilkDecorator(Drink milk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.milk = milk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Drink <span class="title">Mix</span>(<span class="params">Drink coffee</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.Mix(<span class="keyword">this</span>.milk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//热水装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">WaterDecorator</span> : <span class="title">Drink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Drink water;</span><br><span class="line">    WaterDecorator(Drink water)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.water = water;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Drink <span class="title">Mix</span>(<span class="params">Drink coffee</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.Mix(<span class="keyword">this</span>.water);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一杯浓缩咖啡</span></span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> Coffee()</span><br><span class="line"><span class="comment">//咖啡里混入水</span></span><br><span class="line">coffee = <span class="keyword">new</span> WaterDecorator(<span class="keyword">new</span> Water()).Mix(coffee)</span><br><span class="line"><span class="comment">//咖啡里混入牛奶</span></span><br><span class="line">coffee = <span class="keyword">new</span> MilkDecorator(<span class="keyword">new</span> Milk()).Mix(coffee)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们演示了如何通过装饰器模式来调配出一杯咖啡，这里我没有写出具体的Coffee类。在实际场景中，我们还会遇到在咖啡里加糖或者配料来收费的问题，此时装饰器模式就可以帮助我们解决问题，不同的装饰器会对咖啡的价格进行修改，因此在应用完所有装饰器以后，我们就可以计算出最终这杯咖啡的价格。由此我们可以看出，装饰器模式强调的是<strong>扩展</strong>。什么是扩展呢，就是在不影响原来功能的基础上增加新的功能。</p><h2 id="区别和联系"><a href="#区别和联系" class="headerlink" title="区别和联系"></a>区别和联系</h2><p>&emsp;&emsp;代理模式和装饰器模式都是结构型的设计模式，两者在实现上是非常相似的。不同的地方在于，代理模式下调用者无法直接接触到真实对象，因此代理模式强调的是<strong>控制</strong>，即向调用者隐藏真实对象的信息，控制真实对象可以访问的范围；装饰器模式下，扩展功能的职责由子类转向装饰器，且装饰器与被装饰者通常是<strong>“同源”</strong>的，即派生自同一个父类或者是实现了同一个接口，装饰器关注的是增加被装饰者的功能，即<strong>扩展</strong>。两者的联系在于都需要持有一个<strong>“同源”</strong>对象的引用，譬如代理对象与真实对象同源，装饰器与被装饰者同源。从调用的层面上来讲，调用者无法接触到真实对象，它调用的始终是代理对象，对真实对象的内部细节一无所知，这是代理模式；调用者可以接触到装饰器和被装饰者，并且知道装饰器会对被装饰者产生什么样的影响，通常是从一个默认的对象开始”加工”，这是装饰器模式。</p><h1 id="装饰器与面向切面"><a href="#装饰器与面向切面" class="headerlink" title="装饰器与面向切面"></a>装饰器与面向切面</h1><p>&emsp;&emsp;这篇文章写到现在，我发觉我挖了一个非常大的坑，因为这篇文章中涉及到的概念实在太多，务求每一个概念都能讲得清楚透彻，有时候就像莫名立起来的flag，时间一长连我自己都觉得荒唐。有时候感觉内容越来越难写，道理越来越难同别人讲清楚。写作从一开始坚持到现在，就如同某些固执的喜欢一样，大概连我都不记得最初是为了什么吧。好了，现在来说说装饰器与面向切面。我接触Python装饰器的时候，自然而然想到的是.NET中的Attribute。我在越来越多的项目中使用Attribute，譬如ORM中字段与实体的映射规则、数据模型(<strong>Data Model</strong>)中字段的校验规则、RESTful API/Web API设计中的路由配置等，因为我非常不喜欢Java中近乎滥用的配置文件。</p><p>&emsp;&emsp;C#中的Attribute实际上是一种依附在目标(<strong>AttributeTargets</strong>)上的特殊类型，它无法通过new关键字进行实例化，它的实例化必须依赖所依附的目标，通过分析IL代码我们可以知道，Attribute并非是一种修饰符而是一种特殊的类，其方括号必须紧紧挨着所依赖的目标，构造函数以及对属性赋值均在圆括号内完成。相比较而言，Python中的装饰器就显得更为顺理成章些，因为Python中的装饰器本质就是函数，装饰器等价于用装饰器函数去修饰一个函数。函数修饰函数，听起来感觉不可思议，可当你理解了函数和普通对象一样，就不会觉得这个想法不可思议。有时回想起人生会觉得充满玄学的意味，大概是因为我们还没有学会把自己看得普通。</p><p>&emsp;&emsp;通过这篇文章的梳理，我们会发现一个奇妙的现象，Java的Spring框架采用了动态代理了实现AOP，而Python的装饰器简直就是天生的AOP利器，从原理上来讲，这两门语言会选择什么样的方案都说得通。Java是典型的面向对象编程的语言，所以不存在任何游离于Class以外的函数，代理模式对类型的要求更为强烈些，因为我必须限制或者说要求Proxy实现里面的方法，而装饰器模式相对更为宽松些，遇到Python这样的动态类型语言，自然会显得事半功倍。这说明一个道理，通往山顶的道路会有无数条，从中找出最为优雅的一条，是数学家毕生的心愿。AOP是一种思想，和语言无关，我常常听到Java的同学们宣称AOP和IOC在Java社区里如何流行，其实这些东西本来就是可以使用不同的方式去实现的，有些重要的东西，需要你剥离开偏见去认知。</p><p>&emsp;&emsp;关于C#中的Attribute和AOP如何去集成，在Unity和Aspect Core这两个框架中都有涉及，主流的AOP都在努力向这个方向去靠拢，Java中的注解同样不会跳出这个设定，因为编程技术到了今天，语言间的差别微乎其微，我至今依然可以听到，换一种语言就能让问题得到解决的声音，我想说，软件工程是没有银弹的，人类社会的复杂性会永远持续地存在下去，你看微信这样一个社交软件，其对朋友圈权限的粒度之细足以令人叹服。有朋友尝试在C#中借鉴Python的装饰器，并在一组文章中记录了其中的心得，这里分享给大家，希望对这个问题有兴趣的朋友，可以继续努力研究下去，AOP采用哪种方式实现重要吗？有人用它做权限控制，有人用它做日志记录……允许差异的存在，或许才是我们真正需要从这个世界里汲取的力量。</p><ul><li><p><a href="https://www.cnblogs.com/leven/archive/2009/12/28/decorator-csharp-1.html" target="_blank" rel="noopener">轻量级AOP框架-移植python的装饰器(Decorator)到C#(思考篇) </a></p></li><li><p><a href="http://www.cnblogs.com/leven/archive/2009/12/28/decorator-csharp-2.html" target="_blank" rel="noopener">轻量级AOP框架-移植python的装饰器(Decorator)到C#(编码篇) </a></p></li></ul><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文是博主学习Python时临时起意的想法，因为曾经有在项目中使用过AOP的经验，所以在学习Python中的装饰器的时候，自然而然地对这个特性产生了兴趣。有人说，装饰器是Python进阶的重要知识点。在今天这篇文章中，我们首先从Python中的函数引出”函数对象”这一概念，在阐述这个概念的过程中，穿插了函数式编程、高阶函数、lambda等等的概念，”函数是一等公民”，这句话在Python中出现时就是指装饰器，因为装饰器的本质就是函数。然后我们讨论了两种和装饰器有关的设计模式，即代理模式和装饰器模式，选择这两种模式来讨论，是因为我们在Java/C#和Python中看到了两种截然不同的实现AOP的思路，这部分需要花功夫去精心雕琢。博主有时候觉得力不从心，所以写作中有不周到的地方希望大家谅解，同时积极欢迎大家留言，这篇文章就先写到这里吧，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是&lt;a href=&quot;https://qinyuanpei.github.io&quot;&gt;https://qinyuanpei.github.io&lt;/a&gt;。今天我想和大家一起探讨的话题是Pyt
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="装饰器" scheme="http://qinyuanpei.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
      <category term="AOP" scheme="http://qinyuanpei.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AI时代：聊聊大数据中的MapReduce</title>
    <link href="http://qinyuanpei.github.io/posts/2911923212/"/>
    <id>http://qinyuanpei.github.io/posts/2911923212/</id>
    <published>2018-01-19T00:45:08.000Z</published>
    <updated>2018-03-01T01:38:10.350Z</updated>
    
    <content type="html"><![CDATA[<p>各位朋友，大家好，我是Payne，欢迎大家关注我的博客。最近读一本并行计算相关的书籍，在这本书中作者提到了MapReduce。相信熟悉大数据领域的朋友，一定都知道MapReduce是Hadoop框架中重要的组成部分。在这篇文章中，博主将以函数式编程作为切入点，来和大家聊一聊大数据中的MapReduce。如今人工智能正成为行业内竞相追逐的热点，选择MapReduce这个主题，更多的是希望带领大家一窥人工智能的门庭，更多深入的话题需要大家来探索和挖掘。</p><h1 id="MapReduce的前世今生"><a href="#MapReduce的前世今生" class="headerlink" title="MapReduce的前世今生"></a>MapReduce的前世今生</h1><p>MapReduce最早是由Google公司研究并提出的一种面向大规模数据处理的并行计算模型和方法。2003年和2004年，Google公司先后在国际会议上发表了关于Google分布式文件系统(GFS)和MapReduce的论文。这两篇论文公布了Google的GFS和MapReduce的基本原理和主要设计思想，我们通常所说的Google的三驾马车，实际上就是在说GFS、BigTable和MapReduce。因此，这些论文的问世直接催生了Hadoop的诞生，可以说今天主流的大数据框架如Hadoop、Spark等，无一不是受到Google这些论文的影响，而这正是MapReduce由来，其得名则是因为函数式编程中的两个内置函数: map()和reduce()。</p><p>我们常常说，脱离了业务场景去讨论一项技术是无意义的，这个原则在MapReduce上同样适用。众所周知，Google是一家搜索引擎公司，其设计MapReduce的初衷，主要是为了解决搜索引擎中大规模网页数据的并行化处理。所以，我们可以说，MapReduce其实是起源自Web检索的。而我们知道，Web检索可以分为两部分，即获取网页内容并建立索引、根据网页索引来处理查询关键字。我们可以认为互联网上的每个网页都是一个文档，而每个文档中都会有不同的关键字，Google会针对每一个关键字建立映射关系，即哪些文档中含有当前关键字，这是建立索引的过程。在建立索引以后，查询就会变得简单，因为现在我们可以按图索骥。</p><p>互联网诞生至今，网站及网页的数量越来越庞大，像Google这样的搜索引擎巨头是如何保证能够对Web上的内容进行检索的呢？答案是采用并行计算(<strong>Parallel</strong>)。硬件技术的不断革新，让计算机可以发挥多核的优势来处理数据，可当数据量庞大到单机无法处理的程度，就迫使我们不得不采用多台计算机进行并行计算。我们知道并行计算的思想是，将大数据分割成较小的数据块，交由不同的任务单元来处理，然后再将这些结果聚合起来。因此，可以将MapReduce理解为一种可以处理<strong>海量数据</strong>、运行在<strong>大规模集群</strong>上、具备<strong>高度容错</strong>能力、以<strong>并行处理</strong>方式执行的软件框架。MapReduce是分治思想在大规模机器集群时代的集中体现(<strong>如图所示</strong>)，其中，Mapper负责任务的划分，Reducer负责结果的汇总。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180119003729791" alt="MapReduce原理图" title="">                </div>                <div class="image-caption">MapReduce原理图</div>            </figure><p>MapReduce的推出给大数据并行处理带来了巨大的革命性影响，使其成为事实上的大数据处理的工业标准，是目前为止最为成功、最广为接受和最易于使用的大数据并行处理技术。广为人知的大数据框架Hadoop，正是受到MapReduce的启发。自问世来，成为Apache基金会下最重要的项目，受到全球学术界和工业界的普遍关注，并得到推广和普及应用。MapReduce的非凡意义在于，它提出了一个基于集群的高性能并行计算模型，允许使用市场上普通的商用服务器构成一个含有数十、数百甚至数千个节点的分布式并行计算集群，可以在集群节点上自动分配和执行任务以及收集计算结果，通过Mapper和Reducer提供了抽象的大数据处理并行编程接口，可以帮助开发人员更便捷地完成大规模数据处理的编程和计算工作。今天，Google有超过10000个不同的项目已采用MapReduce来实现。</p><h1 id="函数式编程与MapReduce"><a href="#函数式编程与MapReduce" class="headerlink" title="函数式编程与MapReduce"></a>函数式编程与MapReduce</h1><p>我们提到，MapReduce之得名，其灵感来自函数式编程中的两个内置函数：map()和reduce()。函数式编程中，有一个重要的概念叫做高阶函数，是指函数自身能够接受函数，并返回函数的一种函数。我们所熟悉的C#和Java都是典型的面向对象编程(<strong>OOP</strong>)的语言，在这类编程语言中类(<strong>Class</strong>)是第一等公民，即不允许有独立于类的结构出现在代码中。虽然微软从未公开表示C#支持函数式编程，可从LINQ中我们依然可以窥见高阶函数的身影，譬如我们熟悉的Select()、Where()等扩展方法，就可以让我们按照函数式编程的风格去编写代码，这正是为什么Java 8开始支持Stream API的原因。最经典的函数式编程语言当属Haskell语言，我们今天见到的各种编程语言，在考虑引入函数式编程风格的时候，或多或少地都会受到这门语言影响。当你开始适应函数作为第一等公民、高阶函数、柯里化以及惰性求值以后，你或许就会感受到函数式编程特有的美感。</p><p>这里我们选择Python来阐述函数式编程与MapReduce的关系。Python可以让我们轻易地在多种不同的编程风格间切换，事实上现在的编程语言都有向着混合式编程风格发展的趋势。我们提到MapReduce来自两个内置函数：map()和reduce()。其中，map()方法可以对指定集合中的元素按照指定函数进行映射，并将映射后的结果以集合形式返回。譬如我们有一个集合<strong>[1,3,5,7,9]</strong>，我们希望对集合中的每一个元素做平方运算。借助Python中的map()方法和lambda表达式，这个问题可以通过1行代码得到解决。同理，如果我们希望对该集合内的元素做求和运算，我们可以借助于Python中的reduce()方法，该方法位于functools模块中。在某些编程语言中该方法又被成为fold()方法，实际上这两种叫法是等价的，我们关注函数式编程的本质即可。什么是本质呢？当然是函数啦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">list = map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]) <span class="comment">#[1,9,25,49,81]</span></span><br><span class="line">sum = functools.reduce(<span class="keyword">lambda</span> x,y: x+y, [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]) <span class="comment">#25</span></span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line">好了，现在我们来分析下这两个函数，这将帮助我们更好地理解MapReduce。map()方法在这里被称为映射函数，它可以将一种类型映射为一种新的类型。举一个生活中的例子，譬如我们做菜的时候，必不可少的一个环节是将各种各样的食材切碎， 此时作用在这些食材的这个操作就是一个Map操作，你给Map一个洋葱就可以得到洋葱丝。同样地 ，你给Map一个番茄就可以得到番茄块。所以Map处理的原始数据，每条数据间没有相互联系，聪明的你告诉我洋葱和番茄有什么关系。相比map()方法，reduce()方法复杂的地方在于，它要求<span class="keyword">lambda</span>表达式中必须是两个参数。如果继续沿用做菜这个生活化的例子，reduce()方法是将Map操作中切好的食材混合在一起。假设我们要做一份辣椒酱，辣椒酱需要的材料有辣椒、姜和蒜，因此在第一步Map的时候，这些食材将具有相同的Key。对同一类数据，我们就可以使用reduce()进行左/右折叠操作，这相当于我们将同一道菜的食材一起放到锅里，所以 Reduce阶段处理的数据是以Key-Value形式组织的，同一个Key下的Value具有相关性。这样，从理论上它就完全符合函数式编程里的map()和reduce()啦。        </span><br><span class="line">                </span><br><span class="line"><span class="comment"># C#并行编程里的PLINQ</span></span><br><span class="line">关于MapReduce中一个经典案例是，统计不同文章中出现的关键字的频率。对这样一个问题，我们基本上可以想到下面四种方法：</span><br><span class="line">*  写一个单线程程序，顺序地遍历所有文章，然后统计每个关键字出现的频率。</span><br><span class="line">* 写一个多线程程序，并发地遍历所有文章，然后统计每个关键字出现的频率。</span><br><span class="line">* 写一个单线程程序，部署到N台不同的计算机上，然后将文章分割成N份分别输入，再由人工汇总N份结果。</span><br><span class="line">* 使用MapReduce，程序部署、任务划分、结果汇总全部交给框架去完成，我们定义好任务即可。</span><br><span class="line">通过对比，我们可以非常容易地分析出来，第一种方法最简单同时最耗时；第二种方法理论上比第一种高效，尤其是当计算机是多核或者多处理器的时候，缺点是要解决线程同步的问题；第三种方法初现集群的思想，可无法解决程序部署、任务划分和结果汇总等一系列问题；第四种方法本质上就是第三种方法， 可是MapReduce解决了第三种方法全部缺陷，所以它或许是目前最完美的方法。我们下面来考虑，如何模拟这个过程，因为博主不可能为了写一篇科普性质的文章，专门去准备一个Hadoop的开发环境啊，哈哈。</span><br><span class="line"></span><br><span class="line">PLINQ，即Parallel LINQ，是.NET <span class="number">4.0</span>中增加的任务并行库(**TPL**)中的一部分。并行编程中有两个基本的概念，**任务并行**和**数据并行**。前者是指，将程序分割成一组任务并使用不同的线程来运行不同的任务，这种方式被称为**任务并行**；而后者是指，将数据分割成较小的数据块，对这些数据进行并行计算，然后聚合这些计算结果，这种编程模型称为**数据并行**。伴随着并行算法的出现，并行集合相继而来，显然LINQ的并行版本就是PLINQ。这里我们来看一个使用PLINQ实现的词频统计代码，这将作为我们实现MapReduce的一个示例：</span><br><span class="line"></span><br><span class="line">```CSharp</span><br><span class="line">//Origin Texts</span><br><span class="line">string strTarget = @<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">//Map</span><br><span class="line">string[] words = strTarget.Split(<span class="string">' '</span>); </span><br><span class="line">ILookup&lt;string, int&gt; map = words.AsParallel().ToLookup(p =&gt; p, k =&gt; 1); </span><br><span class="line"></span><br><span class="line">//Reduce</span><br><span class="line">var reduce = <span class="keyword">from</span> IGrouping&lt;string, int&gt; wordMap <span class="keyword">in</span> map.AsParallel() </span><br><span class="line">                 where wordMap.Count() &gt; <span class="number">1</span> </span><br><span class="line">                 select new &#123; Word = wordMap.Key, Count = wordMap.Count() &#125;; </span><br><span class="line"></span><br><span class="line">//Show Results</span><br><span class="line">foreach (var word <span class="keyword">in</span> reduce) </span><br><span class="line"> Console.WriteLine(<span class="string">"Word: '&#123;0&#125;' : Count: &#123;1&#125;"</span>, word.Word, word.Count);</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>今天Google发布了全新的AI服务工具Cloud AutoML，从这个产品的名字就可以看出，这是一个试图将人工智能大众化的产品。目前AI是行业中不容置疑热点，国外的科技巨头如Google、微软，国内的科技巨头如腾讯、阿里和百度等，无一不在积极布局AI的上下游产业链。最近CSDN发布了人工智能方向的发展规划，整个产品线的基本都在做战略上调整，我们这些曾经的老用户被新的社区 运营搞得非常郁闷，因为所有的资源都在向着人工智能和区块链倾斜。上周在知乎上看到一篇讽刺国内区块链发展乱象的<a href="https://zhuanlan.zhihu.com/p/32796998" target="_blank" rel="noopener">文章</a>，大概就是说国人喜欢拿一个Token当做加密货币来买，实则连底层技术、分布账本、钱包等基础设施都没有。对于这一点我深有体会，任何新的商业模式在中国都火不过1年，譬如在2017年里被发扬广大的共享经济，有多少共享单车是靠技术和产品赢得市场的，我相信大部分都是沾了人口基数大的光。目前的人工智能，核心算法及技术都掌握在科技巨头手上。我们所追逐的人工智能，有多少是需要靠不断调整参数反复去训练来达到的呢？我觉得找到切实可靠的需求落脚点，比追逐一个又一个热点要更现实，我们大部分工程师都是在科学家工作的基础上做集成应用，所以拨开泡沫看清方向比盲目跟风更重要呀。</p><p>这篇文章蹭了人工智能的热点，其实它对MapReduce并没有做多少深入的研究。我们从Google的业务场景着手分析，思考为什么Google需要MapReduce，即提出MapReduce是为了解决一个什么样的问题？答案是为了适应Google在大规模Web检索业务方面的需要。通过梳理Web检索的一般流程，我们意识到，Web检索可以分为两部分，即获取网页内容并建立索引、根据网页索引来处理查询关键字，从而引出了Mapper和Reducer两个基本的数据处理单元，MapReduce是分治思想在大规模机器集群时代的集中体现，其中，Mapper负责任务的划分，Reducer负责结果的汇总。接下来，我们顺着函数式编程的思路，分析了函数式编程中的map()和reduce()，这两个核心的函数同MapReduce在思想上的一致性，这正是为了印证前文中MapReduce得名的由来。考虑到C#中提供了PLINQ，而在阅读《C#多线程编程》这本书时，同样提到了MapReduce这种并行计算模型，所以在这里将这两者进行结合，提供了一个通过并行计算统计单词频率的简单示例。以上就是这篇文章的所有内容了，如果大家对文章有什么意见或者建议，可以在文章评论区留言，这篇文章就是这样了，谢谢大家，晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;各位朋友，大家好，我是Payne，欢迎大家关注我的博客。最近读一本并行计算相关的书籍，在这本书中作者提到了MapReduce。相信熟悉大数据领域的朋友，一定都知道MapReduce是Hadoop框架中重要的组成部分。在这篇文章中，博主将以函数式编程作为切入点，来和大家聊一聊
      
    
    </summary>
    
      <category term="人工智能" scheme="http://qinyuanpei.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="AI" scheme="http://qinyuanpei.github.io/tags/AI/"/>
    
      <category term="MapReduce" scheme="http://qinyuanpei.github.io/tags/MapReduce/"/>
    
      <category term="FP" scheme="http://qinyuanpei.github.io/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>无问东西：你曾是少年</title>
    <link href="http://qinyuanpei.github.io/posts/1983298072/"/>
    <id>http://qinyuanpei.github.io/posts/1983298072/</id>
    <published>2018-01-19T00:42:06.000Z</published>
    <updated>2018-03-01T01:38:10.362Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果提前了解了你所要面对的人生，你是否还有勇气前来？</p></blockquote><p>这是电影《无问西东》里提出的一个问题。作为一部清华大学建校100周年的献礼片，在因为种种原因而被雪藏6年以后，终于以这样一种倔强而孤傲的姿态，进入到人们的视野。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144159822" alt="绘制彩红的张果果" title="">                </div>                <div class="image-caption">绘制彩红的张果果</div>            </figure><p>电影一开始，透过玻璃注视着四胞胎的张果果(张震饰)，第一次向我们发问：如果提前了解了你所要面对的人生，你是否还有勇气前来。而在电影接近尾声的时候，张果果再一次注视着四胞胎，在窗户上为它们勾勒彩虹，此时旁白再次想起，一问一答间，张果果心中已然找到答案。我想知道的是，屏幕前的你，是不是同样找到了答案？</p><p>这是一部讲述传承的电影，它不同于目前电影市场上任何一种主流的类型，它从一开始就注定是一部不讨巧、不友善、不商业的电影。其故事跨度将近一个世纪，或许我们所看到的，不过是历史长河里的星星点点，可依然难掩背后熠熠生辉的文人风骨，这种由时代所赋予的文化气息，让它成为一部瑕不掩瑜的电影，所以即使这部电影在叙事、配乐和剪辑上存在缺陷，这依然是一部值得关注的电影。</p><p>电影尝试用四个平行的板块，讲述四个不同历史阶段的故事，这些故事中的人物彼此关联，组成了一幅波澜壮阔的历史画面，而影片中想要去表达的精神内核，恰好是关联起这些人物的一种特质，我们称之为传承的东西。按照影片线性叙事的结构，我们可以梳理出这样四条线索。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144246715" alt="上进求学的吴岭澜" title="">                </div>                <div class="image-caption">上进求学的吴岭澜</div>            </figure><p>1923年，北平，清华学堂的高材生吴岭澜(陈楚生饰)，面对选择文理科时的迷茫与彷徨，校长梅贻绮告诉他什么是真实，适逢泰戈尔访华到清华园演讲，在听到“不要忘记你们的真心和真性”后，开始思考人生的意义。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144326412" alt="捐躯赴国的沈光耀" title="">                </div>                <div class="image-caption">捐躯赴国的沈光耀</div>            </figure><p>1938年，昆明，世家子弟沈光耀面对山河破碎的现实，在忠与孝的两难抉择中深感困惑，直到听到吴岭澜说“不要放弃对生活的思索，对自己的真实”，毅然选择投笔从戎，成为飞虎队队员，在国家危亡之际战死沙场。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144448584" alt="青春阳光的陈鹏" title="">                </div>                <div class="image-caption">青春阳光的陈鹏</div>            </figure><p>1962年，北京，清华毕业生陈鹏，在面对国家的大爱与恋人的小爱的选择时，饱含着对恋人王敏佳的爱远赴沙漠投身科研，他质问为支边而蒙蔽内心的李想什么是真实，他用爱托着恋人鼓励她努力活下去，为爱而奉献一生。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144541946" alt="寻找本心的张果果" title="">                </div>                <div class="image-caption">寻找本心的张果果</div>            </figure><p>2010年，北京，广告总监张果果，在明争暗斗的职场上遭人排挤，在面对职场中的名利诱惑时，在面对四胞胎永无止境的救助要求时，李想用生命拯救了张果果的父母，完成自我救赎，而张果果则在迷茫中找会初心，让爱传承下去。</p><p>看这样一部电影的时候，像是在经历一件久远的事情。“这个时代缺少的不是完美的人，缺少的是从自己心底里给出的，真心、正义、无畏和同情”，这是电影中飞虎队教练在招收飞行员时所说的话。我想我们喜欢这部电影，恰恰是因为我们缺少这些东西，这些让我们感到温暖而纯粹的东西。借用吴岭澜在影片中的一句话，“此刻我终于不觉得这样的思考是羞耻的，甚而是你们人生必须的”，面对一个我们无力反驳的现实，或许思考有时候会显得更为苍白。彼时，清华大学校长梅贻绮对迷茫中的吴岭澜这样说道，“人把自己置身于忙碌之中，有一种麻木的踏实，但丧失了真实”，那么你知道什么是真实吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144640309" alt="循循善诱的清华校长梅贻琦" title="">                </div>                <div class="image-caption">循循善诱的清华校长梅贻琦</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144747948" alt="聆听泰戈尔演讲的吴岭澜" title="">                </div>                <div class="image-caption">聆听泰戈尔演讲的吴岭澜</div>            </figure><p>电影中第一个人物，是1924年就读于清华大学的吴岭澜，他见证过泰戈尔访问清华，最终从摇摆不定到听从内心声音，找寻人生的意义。吴岭澜当时是清华大学的一名学生，他的理科成绩属于不列，而当时最好的学生都会去读理科，所以他开始面临学业选择上的困惑。校长梅贻绮给他的答案是：“真实是你看到什么，听到什么，做什么和谁在一起，有一种从心灵深处满溢出来的不懊悔也不羞耻的平和与喜悦”。当时诗人泰戈尔访问清华，演讲的主题是”对自己的真诚”，这次演讲促使吴岭澜心态发生最终变化，转学文科，并最终成为西南联大的一名文科教授。电影对吴岭澜的描绘着重放在他和校长梅贻绮的谈话，以及他出现在泰戈尔演讲现场时那双坚定而执著的眼睛。影片中泰戈尔并没有给出完整的正脸，我们可以看到的只有他标志性的长头发和白头发，可见当时泰戈尔的演讲激起了这代青年人内心的热潮。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144839631" alt="历史上的西南联大" title="">                </div>                <div class="image-caption">历史上的西南联大</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144915148" alt="西南联大师生合影" title="">                </div>                <div class="image-caption">西南联大师生合影</div>            </figure><p>历史上的西南联合大学，始于1938年4月。“七七事变”后，京津地区陷入日军炮火，彼时的清华、北大和南开三校一致决定南迁，遂组成西南联合大学。电影中投笔从戎的沈光耀(王力宏饰)就是这段历史时期的一个缩影，西南联大是中国高等教育史上最伟大的传奇，在短短8年间，汇聚并培养了一大批精英，譬如陈寅恪、钱穆、梁思成、朱自清、闻一多、冯友兰……可以说这是近代最为光华璀璨的时期，可谓群贤毕至、风华绝代。短短8年间，西南联大共毕业学生3882名，其中诺贝尔奖获得者2位、国家最高科学技术奖获得者4位、两弹一星功勋奖章获得者8位、两院院士171位及人文大师100多位。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123144951566" alt="静坐停雨" title="">                </div>                <div class="image-caption">静坐停雨</div>            </figure><p>电影中这段我最喜欢的场景是“静坐听雨”。历史上西南联大的校舍，是由梁思成夫妇参与设计的。因为战争时期物资非常紧缺，校方无法提供充足的建筑材料，所以梁思成夫妇的设计方案一改再改，从楼房变成了平房，从砖墙变成了泥墙，最终124亩的校园里，只有图书馆和实验室以青瓦覆顶，教室用铁皮，宿舍则用茅草。铁皮屋顶最害怕下雨，而昆明偏偏是多雨气候，因此就有了雨声太大导致学生无法听清老师讲课，老师无奈地在黑板上写下“静坐听雨”四个字，这样苦涩中带着温情的画面。电影中沈光耀推开教室窗户，听到的是雨中体育系学生坚持出操的呐喊，看到的是雨中垂钓者的“一蓑烟雨任平生”的从容。我们今天的大学占地越来越大，楼越盖越高，可再找不回这种令人动容的场景。我本科有位老师喜欢讲《大学》，他说这大学不是“高楼大厦之谓”，而是“大师之谓”，这一刻我很想再听老师讲一次大学之道。</p><p>汪曾琪有篇散文《跑警报》，讲述的正是当时的师生躲避日军飞机轰炸的故事，电影中沈光耀(王力宏饰)在锅炉房相遇煮冰糖银耳的桥段，正是取材于这篇散文。在影片中，吴岭澜(陈楚生饰)是一个对沈光耀产生深远影响的人，吴岭澜此时已成为西南联大文学系教授，他冒着被轰炸的危险把煮冰糖银耳的沈光耀从校舍拉了出来，一句“学生不走老师怎么能走”，足以让其形象瞬间高大起来。电影中吴岭澜躲避轰炸的时候带了只鸽子，而历史真实的故事则是金岳霖抱着一只鸡。当时流传着这样一个段子，“陈寅恪跑警报是为了保护国粹，刘文典跑警报是为了庄子，沈从文跑警报到底是为了什么“。在防空洞里吴岭澜讲述泰戈尔的“真实就是你所见所闻”，将真实传承到沈光耀心里，所以他会冒着受罚的风险向饥民空投物资，所以他会不顾家人反对毅然选择投笔从戎、加入飞虎队，直至弹尽粮绝的最后一刻，他毫不犹豫地选择同日军舰艇同归于尽，这是他们的青春故事。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123145045010" alt="研制原子弹归来的陈鹏" title="">                </div>                <div class="image-caption">研制原子弹归来的陈鹏</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123145058418" alt="用深情撑住恋人的陈鹏" title="">                </div>                <div class="image-caption">用深情撑住恋人的陈鹏</div>            </figure><p>陈鹏(黄晓明饰)在影片中是清华大学的一名学生，在毕业后参与原子弹的研制工作。他对恋人王敏佳矢志不渝的爱，成为了支撑她熬过人生低谷的强大动力。影片中的王敏佳一心想帮助曾经的老师摆脱“家庭暴力”，结果反倒被师母诬陷她勾引自己老师，而她的虚荣心迫使她被组织审查直至接受批斗。在批斗中王敏佳失去了美丽的面庞，她的好朋友李想为争取支援边区的名额，不敢承认自己的错误并坚决同她划清了界限。只有陈鹏自始至终守护在王敏佳身边。可陈鹏依然在国家和个人的抉择中，选择了远赴沙漠参与原子弹的研制工作，对他而言，照顾王敏佳和研制原子弹，就是他生命的全部。可当陈鹏回到曾经熟悉的地方时，却发现恋人因为“破四旧”运动而不见踪影。在爱人与国家面前，在爱情与理想面前，我们到底应该怎么去选择，我想大概就是电影中陈鹏告诉李想那句话，“死者已矣，生者如斯”，这是“晃晃”哥哥和神父教给他的大爱。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123145713649" alt="眼神里都是戏的领导" title="">                </div>                <div class="image-caption">眼神里都是戏的领导</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123145759140" alt="现代人的感情，就剩这么点了" title="">                </div>                <div class="image-caption">现代人的感情，就剩这么点了</div>            </figure><p>生活在现代都市的张果果(张震饰)，在尔虞我诈的人际关系中艰难前行，他恪守上下级的职场伦理却被有预谋地当作了替罪羊。面对女下属的质疑，不得不以高深莫测的“你猜”来掩饰内心的焦虑。对父母缺乏耐心以至于出去吃饭的时候直接将碗筷丢进垃圾框，他习惯性地防备着身边的一切，一如喜欢给自己覆盖一层冰冷盔甲的你我。他怕四胞胎家人纠缠而从医院匆匆离开，却又主动掏出名片在门口等人家追上来；目睹四胞胎家人住在没有暖气的出租屋里，冷峻着脸转身离开却又悄声让助理帮忙找个好点的两居室；他买来各种奶粉默默研究选出最满意的奶粉并长期供给，却又不愿意让四胞胎家人对他抱太高期望……起初会觉得这个角色和整个故事无关，可当张果果的父母交代出李想在边区为救自己而牺牲的故事，这一刻我们终于明白，这种传承从未改变，经历过迷茫和无助的张果果终于找回初心，自信地对这个世界说：“我和他们不一样”。</p><p>我相信每个时代里的青年都曾这样迷茫过，就像我们今天所要面对的这种困局一样。媒体称我们这一代人是得过且过的佛系青年，我们为工作中无法得到别人认可而焦虑过，我们为空有适婚的年龄而无适婚的感情而烦闷过，我们为透支父母毕生积蓄来买房而羞愧过……可你看每一个在时代洪流中挣扎的人，其生命无一不被同时打上时代和民族的烙印。吴岭澜是因真心而重新选择自己的人生，沈光耀是因为正义而投笔从戎，陈鹏是因为无畏而托住恋人投身科研，张果果是因为同情而重拾本心迷途知返。列夫·托尔斯泰说过，幸福的人生都是相似的，不幸的人生各有各的不同。每个时代有每个时代的不幸，我们今天不单单要面对水涨船高的房价，更要面对逐渐枯竭甚至贫瘠的心灵。有人说，这部拍给清华学生看的电影，对改善我们的生活毫无意义，可这世上有多少东西，说出来以后能不变得庸俗呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123145847393" alt="那时的爱情真美好" title="">                </div>                <div class="image-caption">那时的爱情真美好</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123150016826" alt="这个校服好帅诶" title="">                </div>                <div class="image-caption">这个校服好帅诶</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123150042048" alt="不管多远都要去寻找你" title="">                </div>                <div class="image-caption">不管多远都要去寻找你</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123150121157" alt="最后的国学大师，王国维" title="">                </div>                <div class="image-caption">最后的国学大师，王国维</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123150159518" alt="那时的青春真美好" title="">                </div>                <div class="image-caption">那时的青春真美好</div>            </figure><p>同样是在迷茫的20多岁，有人找到了真性在生命里惊鸿一瞥，有人在沉浮中随波逐流迷失本心，前者是沈光耀目睹战友牺牲与敌舰同归于尽，后者是李想为争取支边名额背弃朋友间的友谊。陈鹏的爱慷慨而深沉，王敏佳不幸而无能为力……每个时代都是写意的，有佚群绝类的意气，有献血淋漓的痛苦，今天的人们注定无法理解曾经艰苦的生活，而曾经的人们同样无法理解现代人所面对的压力。现实中的离婚和出轨，让美好的爱情变得遥不可及。我们今天越是期待什么，我们的心里就越是缺乏什么。白居易说《长恨歌》是虚构的，而感情是真实的，这或许完全是我们的内心在作怪。世道艰辛，梦想与现实，家国与大义，爱情与理想，名利与善良，仿佛冥冥之中被逼迫到进退两难境地的每一个人，众生皆苦，各自悲欢。张果果在酒吧里拎着半瓶红酒自嘲道，“现代人的情感，就这么多了”，当本心迷失，便是我们有火车，有高铁，有飞机，都不知道要去哪里了！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180123150238166" alt="路一直都在远方" title="">                </div>                <div class="image-caption">路一直都在远方</div>            </figure><p>古人说“为天地立心，为生民立命，为往圣继绝学，为万世开太平”，这是传统知识分子对文化传承的一种使命感。在这部电影中，防空洞里师生背诵《楚辞》、讲述泰戈尔，这是我理解的文化上的传道；王国维在一片英语声中转身离去，那个萧疏没落的背景像是很久很久以前的事情；沈光耀的母亲不愿意他为功名荣辱，在不知人生为何物的时候匆匆离开；师母看到被人打得半死的王敏佳，内心残存的善念觉醒愧而坠井……这些游曳在光影里的残余画面，显得温暖而残酷，终于化作电影结束时一个又一个陌生而熟悉的名字。我们之所以怀念青春，是因为青春本该就是这个样子，真实勇敢，无惧无悔。世俗这样强大，强大到生不出改变它们的念头来。可是无论外界的社会如何跌宕起伏，都对自己真诚，坚守原则。内心没有了杂念和疑问，才能勇往直前。愿你在被打击时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;如果提前了解了你所要面对的人生，你是否还有勇气前来？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是电影《无问西东》里提出的一个问题。作为一部清华大学建校100周年的献礼片，在因为种种原因而被雪藏6年以后，终于以这样一种倔强而孤傲的姿态，进入到人们
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="影评" scheme="http://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="无问西东" scheme="http://qinyuanpei.github.io/tags/%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C/"/>
    
  </entry>
  
  <entry>
    <title>致前任：愿余生各自安好</title>
    <link href="http://qinyuanpei.github.io/posts/1358971951/"/>
    <id>http://qinyuanpei.github.io/posts/1358971951/</id>
    <published>2018-01-12T00:39:39.000Z</published>
    <updated>2018-03-01T01:38:10.362Z</updated>
    
    <content type="html"><![CDATA[<p>也许是因为年纪大了的缘故，渐渐地如同上瘾一般喜欢上怀旧，喜欢怀旧到了什么程度呢？想着再次重温下小马哥的英雄本色，想着再次感受下星球大战里的刀光剑影……可是每次都因为不同的原因而落空，之所以没有去看《英雄本色》，是因为附近的电影院都没有排片，那么这一次呢，好像是因为一部和前任有关的电影《前任攻略3：再见前任》。</p><p>或许前任与现任永远都是一道无解的题目，就如同网上流传着的一个问题，“我和你妈同时掉水里你会先救哪一个”，我们发现对这个问题而言，即使代入现任和前任这样的设定，它看起来依然是说得通的。那么，在我们心里是如何对待现任和前任的呢？我想，在很多人的潜意识里，前任代表了那个你曾经认定要一直走下去的人。我们曾经用天真对一个人好，发自内心地去爱，最终却用尽全力去遗忘释怀。这部电影所讲述的恰好是这样一个写实的场景。最近看到一段这样的话，我们总是用前任的错误惩罚下一任，或者是用对前任的亏欠弥补下一任。这两种做法均无可厚非，甚至听起来第二种做法更好，可如果扪心自问，到底是爱前任多些，还是爱现任多些，我想这是一个问题。电影里的两对情侣，孟云和林佳，余飞和丁点，同时因为生活中的矛盾分手，好兄弟和好闺蜜再度走到一起，这个时候，我们觉得失恋应该是痛苦的一件事情，没有喝醉到不省人事，没有悲伤到歇斯底里，这都不算做失恋吧。</p><p>可或许是我们想多了，有时候两个人分开以后，难过的只有自己，对对方而言或许是种解脱，于是我们在电影里看到了一幕幕单身男女嗨翻天的景象，我们常常听到这样一句话，两个人不合适就分手呗，讽刺的是，我们一边渴望着美好的爱情，一边对待感情弃若敝履，我们谈恋爱的时间越来越短，对彼此越来越没有耐心，有人说，这是因为我们长大了，知道20多岁的年龄，不能再像10多岁一样挥霍，像孟云和林佳这样的情侣，现实中举不胜举，为了彼此一点可怜的自尊，谁都不肯先放下身段同对方和解，等到矛盾积累得越来越多，任何一件事情都有可能成为，压死骆驼的最后一根稻草。这个时候，还要试图用扮演至尊宝说“我爱你”和疯狂吃芒果吃到过敏，这样幼稚可笑的事情来满足各自的虚荣心，好像我们每个人都实现了对彼此的承诺，真正爱你的人，怎么会舍得离开你呢，明明是自私得只懂得爱自己，非要坚持说是对方不够爱自己，真正爱你的人，爱一直都在心里。</p><p>我不知道这样一部电影，是如何让大家产生共鸣，在观影的时候哭得稀里哗啦的，电影中两位男主在“隔壁老王”，讨论是生男孩好还是生女孩好，讨论和双胞胎姐妹约会的好处，和一众长着网红脸的95后在Party上狂嗨……各种段子让分手变成一场狂欢，而狂欢下的两种状态，有余飞和丁点这种“以分手的名义，撒着思念的娇”的，有孟云和林佳这种因为沟通不善而渐行渐远的。我们常常听到一个词叫做合适，其实以人类这种奇葩的性格，又怎么会找到完全合适的两个人呢？这一切都是需要去不断磨合的，我们看待感情的角度是功利的，如果两个人走到一起甚至结婚，我们觉得这就是合适的，那么像孟云和林佳这种相爱五年的情侣，我觉得我们很难用一句合适或者不合适来说说清楚，两个人在一起一定要多沟通，有问题不要想着第二天再解决。在感情中不要用“作”这种手段去测试对方，一个人喜欢你，愿意忍让你，并不代表你可以毫无底线。也许很多时候，我们都喜欢把话埋在心里，我们都觉得谁先主动谁就输啦，即使此刻赢得了面子，最终还是会输掉了里子。</p><p>这部电影可谓是为“前任系列”画上了一个完美的结局，然而这样一部名不见经传的电影，可以在猫眼电影上获得9.2分的高分，一度超越近期口碑极佳的《芳华》，这种前半段走肾后半段走心的编排方式，成功地将观众的情绪带向高潮。有人说在这部电影里找到了自己的影子，可在我看来大家都在努力给自己加戏，两个人会分开一定是有某种原因的，我们总幻想着离开的时候，如何惊天地泣鬼神一般轰轰烈烈，可真正的离开从来都是悄无声息的。一场体面的分手，是两个彼此伤痕累累的的人，在面对这段感情时，即使知道其中存在的问题，但是发现一切再无法回到以前，因为在这个被称为成长的过程中，感情早已被当作燃料的消耗殆尽。所以，我们说：我依然爱你，但我不再喜欢你了，所以我们只能走到这里了。体面的分手，或许应该是这个样子的，是一切大彻大悟以后的慈悲，是用尽了力气后的平静，是虽然结局不如意，但我没有后悔遇见你，是接受成长带来的痛苦，是学会如何更好地爱自己、爱别人。</p><p>有人说，前任就像黑夜中摇曳着的烛火，坍塌在无边的夜色中。或许会有无数根的蜡烛，能照亮你的黑暗，但再不会有这样一个人，能这样一往无前地在黑暗中，为你烫出一个洞，然后用温暖填满。成长是件非常痛苦的事情，你不一定会得到什么，但一定会失去什么，有些人注定是让你成长的，所以请好好再见，不负遇见。有些人会永远停留在你的心里，他们曾经出现，并成为你人生的一部分，我们会爱上下一个，再下一个。放过前任，放过自己，这或许是最好的结局。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;也许是因为年纪大了的缘故，渐渐地如同上瘾一般喜欢上怀旧，喜欢怀旧到了什么程度呢？想着再次重温下小马哥的英雄本色，想着再次感受下星球大战里的刀光剑影……可是每次都因为不同的原因而落空，之所以没有去看《英雄本色》，是因为附近的电影院都没有排片，那么这一次呢，好像是因为一部和前任
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="http://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="前任" scheme="http://qinyuanpei.github.io/tags/%E5%89%8D%E4%BB%BB/"/>
    
      <category term="公众号" scheme="http://qinyuanpei.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>《C#多线程编程实战》读书笔记</title>
    <link href="http://qinyuanpei.github.io/posts/345410188/"/>
    <id>http://qinyuanpei.github.io/posts/345410188/</id>
    <published>2018-01-07T21:34:36.000Z</published>
    <updated>2018-03-01T01:38:10.354Z</updated>
    
    <content type="html"><![CDATA[<p>本文是一篇读书笔记，由<a href="https://book.douban.com/subject/26574917/" target="_blank" rel="noopener">《C#多线程编程实战》</a>一书中的内容整理而来，主要梳理了.NET中多线程编程相关的知识脉络，从Thread、ThreadPool、Task、async/await、并发集合、Parallel、PLINQ到Rx及异步I/O等内容，均有所覆盖。为了帮助大家理解本文内容，首先给出博主在阅读该书过程中绘制的思维导图，大家可以根据个人需要针对性的查漏补缺。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20180112234912008" alt="《多线程编程实战》思维导图" title="">                </div>                <div class="image-caption">《多线程编程实战》思维导图</div>            </figure><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><ul><li>Tips1：暂停线程，即通过Thread.Sleep()方法让线程等待一段时间而不用消耗操作系统资源。当线程处于休眠状态时，它会占用尽可能少的CPU时间。</li><li>Tips2：线程等待，即通过Join()方法等待另一个线程结束，因为不知道执行所需要花费的时间，此时Thread.Sleep()方法无效，并且第一个线程等待时是处于阻塞状态的。</li><li>Tips3：终止线程，调用Abort()方法会给线程注入ThreadAbortException异常，该异常会导致程序崩溃，且该方法不一定总是能终止线程，目标线程可以通过处理该异常并调用Thread.ResetAbort()方法来拒绝被终止，因此不推荐使用Abort()方法来终止线程，理想的方式是通过CancellationToken来实现线程终止。</li><li>Tips4：线程优先级，线程优先级决定了该线程可占用多少CPU时间，通过设置IsBackground属性可以指定一个线程是否为后台线程，默认情况下，显式创建的线程都是前台线程。其主要区别是：进程会等待所有的前台线程完成后再结束工作，但是如果只剩下后台线程，则会直接结束工作。需要注意的是，如果程序定义了一个不会赞成的前台线程，主程序并不会正常结束。</li><li>Tips5：向线程传递参数，可以通过ThreadStart或者lambda表达式来向一个线程传递参数，需要注意的是，由lambda表达式带来的闭包问题</li><li>Tips6：竞争条件是多线程环境中非常常见的导致错误的原因，通过lock关键字锁定一个静态对象(static&amp;readonly)时，需要访问该对象的所有其它线程都会处于阻塞状态，并等待直到该对象解除锁定，这可能会导致严重的性能问题，</li><li><p>Tips7：发生死锁的原因是锁定的静态对象永远无法解除锁定，通常Monitor类用以解除死锁，而lock关键字用以创建死锁，Monitor类的TryEnter()方法可以用以检测静态对象是否可以解锁，lock关键字本质上是Monitor类的语法糖。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> acquiredLock = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  Monitor.Enter(lockObject, <span class="keyword">ref</span> acquiredLock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(acquiredLock)</span><br><span class="line">  &#123;</span><br><span class="line">    Monitor.Exit(lockObject)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Tips8：不要在线程中抛出异常，而是在线程代码中使用try…catch代码块。</p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1></li><li>Tips9：无须共享对象，则无须进行线程同步，通过重新设计程序来移除共享状态，从而避免复杂的同步构造；使用原子操作，这意味着一个操作只占用一个量子的时间，一次就可以完成，并且只有当前操作完成后，其它线程方可执行其它操作，因此，无须实现其它线程等待当前操作完成，进而避免了使用锁，排除了死锁。</li><li>Tips10：为了实现线程同步，我们不得不使用不同的方式来协调线程，方式之一是将等待的线程设为阻塞，当线程处于阻塞状态时，会占用尽可能少的CPU时间，然而这意味着会引入至少一次的上下文切换。上下文切换，是指操作系统的线程调度器，该调度器会保存等待的线程状态，并切换到另一个线程，依次恢复等待的线程状态，而这需要消耗更多的资源。</li><li>Tips11：线程调度模式，当线程挂起很长时间时，需要操作系统内核来阻止线程使用CPU时间，这种模式被称为内核模式；当线程只需要等待一小段时间，而不需要将线程切换到阻塞状态，这种模式被称为用户模式；先尝试按照用户模式进行等待，如线程等待足够长时间，则切换到阻塞状态以节省CPU资源，这种模式被称为混合模式。</li><li>Tips12：Mutex是一种原始的同步方法，其只对一个线程授予对共享资源的独占访问，Mutex可以在不同的程序中同步线程。</li><li>Tips13：SemaphoreSlim是Semaphore的轻量级版本，用以限制同时访问同一个资源的线程数量，超过该数量的线程需要等待，直到之前的线程中某一个完成工作，并调用Release()方法发出信号，其使用了混合模式，而Semaphore则使用内核模式，可以在跨程序同步的场景下使用。</li><li>Tips14：AutoResetEvent类用以从一个线程向另一个线程发送通知，该类可以通知等待的线程有某个事件发生，其实例在默认情况下初始状态为unsignaled，调用WaitOne()方法时将会被阻塞，直到我们调用了Set方法；相反地，如果初始状态为signaled，调用WaitOne()方法时将会被立即处理，需要我们再调用一次Set方法，以便向其它线程发出信号。</li><li>Tips15：ManualResetEventSlim类是使用混合模式的线程信号量，相比使用内核模式的AutoResetEvent类更好(因为等待时间不能太长)，AutoResetEvent像一个旋转门，一次仅允许一个人通过，而ManualResetEventSlim是ManualResetEvent的混合版本，一直保持大门开启直到手动屌用Reset方法。</li><li>Tips16：EventWaitHandle类是AutoResetEvent和ManualResetEvent的基类，可以通过调用其WaitOne()方法来阻塞线程，直到Set()方法被调用，它有两种状态，即终止态和非终止态，这两种状态可以相互转换，调用Set()方法可将其实例设为终止态，调用Reset()方法可以将其实例设为非终止态。</li><li>Tips17：CountdownEvent类可以用以等到直到一定数量的操作完成，需要注意的是，如果其实例方法Signal()没有达到指定的次数，则其实例方法Wait()将一直等待。所以，请确保使用CountdownEvent时，所有线程完成后都要调用Signal()方法。</li><li>Tips18：ReaderWriterLockSlim用以创建一个线程安全的机制，在多线程中对一个集合进行读写操作，ReaderWriterLockSlim代表了一个管理资源访问的锁，允许多个线程同时读取，以及独占写。其中，读锁允许多线程读取数据，写锁在被释放前会阻塞其它线程的所有操作。</li><li>Tips19：SpinWait类是一个混合同步构造，被设计为使用用户模式等待一段时间，然后切换到内核模式以节省CPU时间。<h1 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h1></li><li>Tips20：volatile关键字指出一个字段可能会被同时执行的多个线程修改，声明为volatile的字段不会被编译器和处理器优化为只能被单线程访问。</li><li>Tips21：创建线程是昂贵的操作，所以为每个短暂的异步操作创建线程会产生显著的开销。线程池的用途是执行运行时间短的操作，使用线程池可以减少并行度耗费及节省操作系统资源。在ASP.NET应用程序中使用线程池时要相当小心，ASP.NET基础切实使用自己的线程池，如果在线程池中浪费所有的工作者线程，Web服务器将不能够服务新的请求，在ASP.NET中只推荐使用I/O密集型的异步操作，因为其使用了一个不同的方式，叫做I/O线程。</li><li>Tips22：APM，即异步编程模型，是指使用BeginXXX/EndXXX和IAsyncResult对象等方式，其通过调用BeginInvoke方法返回IAsyncResult对象，然后通过调用EndInvoke方法返回结果，我们可通过轮询IAsyncResult对象的IsCompleted或者调用IAsyncResult对象的AsyncWaitHandle属性的WaitOne()方法来等待直到操作完成。</li><li>Tips23：ThreadPool.RegisterWaitForSingleObject()方法允许我们将回调函数放入线程池中的队列中，当提供的等待事件处理器收到信号或发生超时时，该回调函数将被调用，这做鱼我们为线程池中的操作实现超时功能。具体思路是：ManualResetEvent + CancellationToken，当接收到ManualResetEvent对象的信号时处理超时，或者是使用CancellationToken来处理超时。</li><li>Tips24：CancellationToken是.NET4.0中被引入的实现异步操作的取消操作的事实标准，我们可以使用三种方式来实现取消过程，即轮询IsCancellationRequested属性、抛出OperationCanceledException异常、为CancellationToken注册一个回调函数。</li><li>Tips25：Timer对象用以在线程池中创建周期性调用的异步操作。</li><li>Tips26：BackgroundWorker组件，是典型的基于事件的异步模式，即EAP，当通过RunWorkerAsync启动一个异步操作时，DoWork事件所订阅的事件处理器，将会运行在线程池中，如果需要需要取消异步操作，则可以调用CancelAsync()方法。<h1 id="使用任务并行库"><a href="#使用任务并行库" class="headerlink" title="使用任务并行库"></a>使用任务并行库</h1></li><li>Tips27：TPL即任务并行库，在.NET 4.0中被引入，目的是解决APM和EAP中获取结果和传播异常的问题，TPL在.NET4.5中进行了调整，使其在使用上更简单，它可以理解为线程池之上的又一个抽象层，对程序员隐藏了与线程池交互的底层代码，并提供了更方便的细粒度的API。TPL的核心概念是任务，一个任务代表了一个异步操作，该操作可以通过多种方式运行，可以使用或者不使用独立线程运行。TPL相比之前的模式，一个关键优势是其具有用于组合任务的便利的API。</li><li>Tips28：Task.Run是Task.Factory.StartNew的一个快捷方式，后者有附加的选项，在无特殊需求的情况下，可以直接使用Task.Run，通过TaskScheduler，我们可以控制任务的运行方式。</li><li>Tips29：使用Task实例的Start方法启动任务并等待结果，该任务会被放置在线程池中并且主线程会等待，直到任务返回前一直处于阻塞状态；使用Task实例的RunSynchronously方法启动任务，该任务是运行在主线程中，这是一个非常好的优化，可以避免使用线程池来执行非常短暂的操作；我们可以通过轮询Task实例的状态信息来判断一个任务是否执行结束。</li><li>Tips30：通过Task实例的ContinueWith方法可以为任务设置一个后续操作，通过TaskContinuationOptions选项来指定后续任务以什么样的方式执行。</li><li>Tips31：通过Task实例的FromAsync可以实现APM到Task的转换</li><li>Tips32：通过TaskCompletionSource可以实现EAP到Task的转换</li><li>Tips33：TaskScheduler是一个非常重要的抽象，该组件实际上负责如何执行任务，默认的任务调度程序将任务放置在线程池的工作线程中。为了避免死锁，绝对不要通过任务调度程序在UI线程中使用同步操作，请使用ContinueWith或async/await方法。<h1 id="使用C-6-0"><a href="#使用C-6-0" class="headerlink" title="使用C# 6.0"></a>使用C# 6.0</h1></li><li>Tips34：异步函数是C# 5.0引入的语言特性，它是基于TPL之上的更高级别抽象，真正简化了异步编程。要创建一个异步函数，首先需要使用async关键字标注一个方法，其次异步函数必须返回Task或Task类型，可以使用async void的方法，但是更推荐async Task的方法，使用async void的方法的唯一合理的地方就是在程序中使用顶层UI控制器事件处理器的时候，在使用async关键字标注的方法内部，可以使用await操作符，该操作符可与TPL任务一起工作，并获取该任务中异步操作的结果，在async方法外部不能使用await关键字，否则会有编译错误，异步函数代码中至少要拥有一个await关键字。</li><li>Tips35：在Windows GUI或ASP.NET等环境中不推荐使用Task.Wait和Task.Result，因为非常有可能会造成死锁。<br>async可以和lambda表达式联用，在表达式体中应该至少含有一个await关键字标示，因为lambda表达式的类型无法通过自身推断，所以必须显式地向C#编译器指定类型。</li><li>Tips36：异步并不总是意味着并行执行</li><li>Tips37：单个异步操作可以使用try…catch来捕获异常，而对于一个以上的异步操作，使用try…catch仅仅可以从底层的AggregateException对象中获得第一个异常，为了获得所有的异常，可以使用AggregateException的Flatten()方法将层级异常放入一个列表，并从中提取出所有的底层异常。</li><li>Tips38：通过Task实例的ConfigureAwait()方法，可以设置使用await时同步上下文的行为，默认情况下，await操作符会尝试捕捉同步上下文，并在其中执行代码，即调度器会向UI线程投入成千上百个后续操作任务，这会使用它的消息循环来异步地执行这些任务，当我们不需要在UI线程中运行这些代码时，向ConfigureAwait方法传入false将会是一个更高效的方案。</li><li>Tips39：async void方法会导致异常处理方法，会放置到当前的同步上下文中，因此线程池中未被处理的异常会终结整个进程，使用AppDomain.UnhandledException事件可以拦截未处理的异常，但不能从拦截的地方恢复进程，async void的lambda表达式，同Action类型是兼容的，强烈建议仅仅在UI事件处理器中使用async void方法，在其他情况下，请使用返回Task或者Task的方法。<h1 id="使用并行集合"><a href="#使用并行集合" class="headerlink" title="使用并行集合"></a>使用并行集合</h1></li><li>Tips40：ConcurrentQueue使用了原子的比较和交换(CAS)，以及SpinWait来保证线程安全，它实现了一个先进先出(FIFO)的集合，这意味着元素出队列的顺序与加速队列的顺序是一致的，可以调用Enqueue方法向对接中加入元素，调用TryDequeue方法试图取出队列中第一个元素，调用TryPeek方法试图得到第一个元素但并不从队列中删除该元素。</li><li>Tips41：ConcurrentStack的实现同样没有使用锁，仅采用了CAS操作，它是一个后进先出(LIFO)的集合，这意味着最后添加的元素会先返回，可以调用Push和PushRange方法添加元素，使用TryPop和TryPopRange方法获取元素，使用TryPeek方法检查元素。</li><li>Tips42：ConcurrentBag是一个支持重复元素的无序集合，它针对以下情况进行了优化，即多个线程以这样的方式工作：每个线程产生和消费其自身的任务，极少发生线程间的交互(因为要交互就要使用锁)。可以调用Add方法添加元素，调用TryPeek方法检查元素，调用TryTake方法获取元素。</li><li>Tips43：ConcurrentDictionary是一个线程安全的字典集合的实现，对于读操作无需使用锁，对于写操作则需要使用锁，该并发字典使用多个锁，在字典桶之上实现了一个细粒度的锁模型(使用锁的常规字典称为粗粒度锁)，参数concurrentLevel可以在构造函数中定义锁的数量。这意味着预估的线程数量将并发地更新该字典。由于并发字典使用锁，如无必要请避免使用以下操作：Count、IsEmpty、Keys、Values、CopyTo及ToArray，因为需要获取该字典中的所有锁。</li><li>Tips44：BlockingCollection是一个针对IProducerConsumerCollection泛型接口实现的高级封装，它有很多先进的功能来实现管道场景，即当你有一些步骤需要使用之前步骤运行的结果时。BlockingCollection类支持分块、调整内部集合容量、取消集合操作、从多个块集合中获取元素等。</li><li>Tips45：对BlockingCollection进行迭代时，需要注意的是，使用GetConsumingEnumerable()进行迭代，因为虽然BlockingCollection实现了IEnumerable接口，但是它默认的行为是表示集合的“快照”，这不是我们期望的行为。<h1 id="使用PLINQ"><a href="#使用PLINQ" class="headerlink" title="使用PLINQ"></a>使用PLINQ</h1></li><li>Tips46：将程序分割成一组任务并使用不同的线程来运行不同的任务，这种方式被称为任务并行<br>将数据分割成较小的数据块，对这些数据进行并行计算，然后聚合这些计算结果，这种编程模型称为数据并行</li><li>Tips47：结构并行确实更易维护，应该尽可能地使用，但它并不是万能的。通常有很多情况我们是不能简单地使用结构并行，那么以非结构化的方式使用TPL任务并行也是完全可以的。<br>Parallel类中的Invoke方法是最简单的实现多任务并行的方法，Invoke方法会阻塞其它线程直到所有线程都完成。</li><li>Tips48：Parallel类中的For和ForEach方法可以定义并行循环，通过传入一个委托来定义每个循环项的行为，并得到一个结果来说明循环是否成功完成，ParallelOptions类可以为并行循环定义最大并行数，使用CollectionToken取消任务，使用TaskScheduler类调度任务。</li><li>Tips49：ParallelLoopState可以用于从循环中跳出或者检查循环状态，它有两种方式：Break和Stop，Stop是指循环停止处理任何工作，而Break是指停止其之后的迭代，继续保持其之前的迭代工作。</li><li>Tips50：同Task类似，当使用AsParallel()方法并行查询时，我们将得到AggregateException，它将包含运行PLINQ期间发生的所有异常，我们可以使用Flatten()方法和Handle()方法来处理这些异常。</li><li>Tips51：ParallelEnumerable类含有PLINQ的全部逻辑，并且作为IEnumerable集合功能的一组扩展方法，默认情况下结果会被合并单个线程中，我们可以通过ForAll方法来指定处理逻辑，此时它们使用的是同一个线程，将跳过合并结果的过程，除了AsParallel()方法，我们同样可以使用AsSequential()方法，来使得PLINQ查询以顺序方式执行(相对于并行)</li><li>Tips52：PLINQ中提供了丰富用以PLINQ查询的选项，例如WithCancellation()方法用以取消查询，这将导致引发OperationCanceledException异常，并取消剩余的工作；例如WithDegreeOfParallelism()方法用以指定执行查询时实际并行分割数，可以决定并行执行会占用多少资源及其性能如何；例如WithExecutionMode()可以重载查询执行的模式，即我们可以决定选择以顺序执行还是并行执行的方式去执行查询；例如WithMergeOptions()方法可以用以调整对查询结果的处理，默认PLINQ会将结果合并到单个线程中，因此在查询结果返回前，会缓存一定数量的结果，当发现查询花费大量时间时，更合理的方式是关闭结果缓存从而尽可能快地得到结果；例如AsOrdered()方法，用以告诉PLINQ我们希望按照集合中的顺序进行处理(并行条件下，集合中的项有可能不是按顺序被处理的)<h1 id="使用异步I-O"><a href="#使用异步I-O" class="headerlink" title="使用异步I/O"></a>使用异步I/O</h1></li><li>Tips53：异步I/O，对服务器而言，可伸缩性是最高优先级，这意味着单个用户消耗的资源越少越好，如果为每个用户创建多个线程，则可伸缩性并不好，在I/O密集型的场景中需要使用异步，因为不需要CPU工作，其瓶颈在磁盘上，这种执行I/O任务的方式成为I/O线程。<br>在异步文件读写中，FileOptions.Asynchronous是一个非常重要的选项，无论有无此参数都可以，以异步的方式使用该文件，区别是前者仅仅是在线程池中异步委托调用，而后者可以对FileStream垒使用异步I/O。</li><li>Tips54：对HttpListener类，我们可以通过GetContextasync()方法来异步地获取上下文。</li><li>Tips55：对数据库而言，我们可以通过OpenAsync()、ExecuteNonQueryAsync()等方法异步地执行SQL语句。</li></ul><p>好了，以上就是这篇读书笔记的主要内容啦，听说掌握了这55条Tips的人，都敢在简历上写”精通多线程编程“，哈哈，晚安啦，各位！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是一篇读书笔记，由&lt;a href=&quot;https://book.douban.com/subject/26574917/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《C#多线程编程实战》&lt;/a&gt;一书中的内容整理而来，主要梳理了.NET中多线程编程相关
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://qinyuanpei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="多线程" scheme="http://qinyuanpei.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="读书" scheme="http://qinyuanpei.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="http://qinyuanpei.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2017，在驻足间回首</title>
    <link href="http://qinyuanpei.github.io/posts/2676125676/"/>
    <id>http://qinyuanpei.github.io/posts/2676125676/</id>
    <published>2017-12-31T21:30:45.000Z</published>
    <updated>2018-03-01T01:38:10.350Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;当朋友圈开始集体缅怀18岁的时候，我们说，从此以后是00后的天下，因为所以的90后都成年了。或许我们都是喜欢怀旧的人，所以我们选择以这样一种方式，在狂欢中失去的同时，在失去中缅怀着，仿佛这种死磕到底的做法，会让这一切来得更晚一些。一群人抱着手机等待着新年的到来，和曾经无数个无眠的夜晚一样，我们并不知道明天会有什么，就像钟表的指针哒哒地作响，生命的齿轮永不停歇地转动。我们习惯性地期盼明天会更好，因为我们都知道“往者不可谏，来者犹可追”。那么，在新年钟声敲响以前，让记忆彻底来一场独自的狂欢吧！</p><h1 id="多情应笑我"><a href="#多情应笑我" class="headerlink" title="多情应笑我"></a>多情应笑我</h1><p>&emsp;&emsp;我不知道该从哪里开始回顾我的2017年，如果一定要找一个起点开始说，我想应该是裴武刚离开西安。那时青龙寺樱花正在盛开，在他离开西安以前，我曾带他一起去那里游玩。他曾遗憾没有好好在西安游玩一番，在分别前我们一起去吃羊肉泡馍，真正体会到什么叫做相顾无言，直到十一回家去兰州转车，我们再次联系到彼此，所以当你想做一件事情的时候，最好就是趁着现在去做，一个过期的承诺是没有意义的，人生本就是大海里航行的一叶扁舟，你可以祈祷它不遭遇狂风暴雨，可事实上你并不能替任何人做这样一个决定，越想做好一件事情就越是要减少拖延。“人生不相见，动如参与商”，人生本不完美，缺憾能少一分便是一分。</p><p>&emsp;&emsp;我记得我们吃完泡馍，两个人都抢着付钱，老板娘笑着说：“大家都是好朋友，谁付都是一样的，以后还有机会”。两个人一阵默然。从那时算起，到今天差不多8个月，我们再没有见过面，偶尔会在微信上聊聊天。人生的无奈就在于，你埋头忙碌的时候，对离别的处境毫不在意，等到你过头来再看时，不禁怅然若失，感情就这样一天天变淡，可是不是你努力融入对方的生活，就能够留住彼此在心中的位置呢？有人告诉我，她不属于你，她不适合你，可是不是换一个性格完全相反的人，就一定会是合适的人选呢？我们的大脑，同绝对理性的计算机最大的不同是，我们评价和认识一个人的标准，永远没有办法达到统一，就像你喜欢吃葱，而我喜欢吃香菜，你不能因此指责别人三观不正，这或许仅仅是你们的喜好不同而已，这个理性而感性的世界，有时真的让人抓狂。</p><p>&emsp;&emsp;我一直没有告诉任何人，我和小古分开快两年的时间了。有人说，时间会慢慢磨去一切痕迹，而对于她，始终就像我心上的一颗痣，时间会把它变成一颗琥珀，时间越久越显得珍贵，我知道有人会嘲笑这固执的感情，就像我会在分开一年后，坐一个晚上的火车到洛阳，仅仅是为了见她一面而已，我永远记得她穿裙子的样子，我永远记得那条挂满灯笼的路，我永远都想再抱她一次……我听到莎莉花园的时候，会突然想起那个下午，当我们听到一家店里传来的音乐声，我们互相对彼此说我知道……我们在彼此不成熟的年龄深爱上彼此，等一天幡然醒悟的时候发现追悔莫及，离开她以后我发现我会单身很久，因为除了她我好像都不会同别人谈恋爱，这种迹象在我身上更加明显，因为无论你怎么尝试去改变，你永远无法逃开被拒绝的命运。我们喜欢喜欢一个人的时候，通常靠眼缘这种特别主观的东西，可太多时候我们无法完全了解一个人。</p><p>&emsp;&emsp;从前我们喜欢一个人的时候，喜欢爱得轰轰烈烈，相信爱情可以战胜一切；等到长大以后，我们习惯爱得小心谨慎，试探和套路混杂不清真真假假。有人告诉你，要相信爱情是存在的，你只是还没有等到那个合适的人出现；有的人告诉你，不要在一棵树上吊死。成年人的感情和时间都非常有限，不要把精力浪费在一个不喜欢你的人身上。可兜兜转转就到了25岁，一个谈爱已晚、谈死尚早的尴尬年纪。有时候我会想，大学毕业了就可以结婚成家的人，或许是最幸福的人，因为你再找不到那样单纯的爱情。我见过情侣间吵架无数分分合合，我见过向现实妥协随便找个人结婚……我想找一个可以托付终生的人，因为父母总有一天会先我们而去，如果需要有人陪伴在我生命的一刻，我希望那个人会是你，可我决不会如此自私，因为我不想你在这个世界里孤单。我曾被人温柔地对待过，我想温柔地对待你，不是因为亏欠或者内疚而弥补什么，而是我知道“爱人者人恒爱之”。</p><p>&emsp;&emsp;我曾经被一个女孩子拒绝过，我天真的以为，出场顺序会决定两个人的命运，直到她平静地说出，“就算我不和他在一起，我绝不会和你在一起“，原来一个在小古心里待她特别好的人，在别人眼中居然是如此的不堪，我记得我在她面前结结巴巴说英语的窘迫，我记得她告诉我她要订婚时我写满难过的脸……我好像被施诅咒一样，在和小古分开后，我喜欢过两个有男朋友的女生，有时候我都想告诉自己，我不再是那个十八九岁的少年，长大以后的爱情夹杂着现实，变得更加让人迷惑，可我再找不回那种“赌书泼茶”的感觉，或许求而不得是人生常态，王尔德说“人生有两种悲剧，一种是想得到的得不到，一种是想得到的得到了”，我对小古说，给我留一个梦好吗？她说好的呀。对这个世界而言，我们两个人的故事，或许一点都不美丽。可真正让我怀念的，恰好是这些微不足道的故事，有时候我会分不清，喜欢的到底是真实的她，还是想象中的她，或许我真正喜欢的，是曾经那个年轻而勇敢的少年，佛家有”贪嗔痴慢疑“，所谓五毒心者，都说人要学会放下执念，可如果从来没有得到过，又要放下什么呢？人因为“求而不得”而痛苦，从来没有拥有过的人，是无所谓拿起和放下的。</p><h1 id="做人没意思"><a href="#做人没意思" class="headerlink" title="做人没意思"></a>做人没意思</h1><p>&emsp;&emsp;大概从8月份开始学习做饭，而学习做饭的动机早就模糊不清，我只知道，从那一刻开始，我的生活开始慢慢发生变化，从一个不知道做饭需要买什么调味品的人，变成一个喜欢逛超市、喜欢看商品价格的人，变成一个喜欢周末去超市购物、喜欢钻研美食的人，变成一个懂得如何照顾自己、爱惜自己的人。西安的面食对我而言是粗犷的，如同这片关中大地上粗犷的民风，所以最初就买了本菜谱学习做饭，我学做饭的动机，其实是非常简单的，最低要求是以后讨不着老婆不会饿死自己，进阶要求是两口子过日子必须要有一个具备这项生活技能，现在我们看到有把吃作为爱好的吃货，可这样的人是不能称之为吃货的，因为吃货如果就是花花钱动动嘴这样简单，就对不起古往今来的吃货们，譬如苏东坡之于红烧肉，季鹰之于鲈鱼，袁枚之于《随园食单》，能做会吃这是真吃货。有人说，征服一个吃货的心，首先要征服她的胃。可也许这仅仅是一个理由，当你征服她的胃，你会发现还有更多的东西等你去征服。现在，先让我征服这本菜谱，我刚刚学会其中的10来道家常小炒。</p><p>&emsp;&emsp;除了做饭这件事情以外，我一直在坚持的事情是读书，去年国庆的时候买了Kindle，而年初则办理了省图的借书卡。一旦这两者结合起来以后，读书就变成了一件趣事。因为Kindle不擅长阅读技术类书籍，所以技术类书籍主要来自纸质书，而人文类书籍主要来自电子书。最早是Wesley推荐读陈忠实的《白鹿原》，这本书让我了解了许多陕西的风土人情。在同名电视剧中，张嘉怡饰演的白嘉轩，生平念念不忘的是妻子亲手做的油泼面。陕西的面食的确让人印象深刻，原本出生在北方的我，在这里仿佛第一次来到北方。此外，由电影《嫌疑人X的献身》追溯到原著，逐渐接触了《白夜行》和《解忧杂货店》这样典型的东野圭吾作品，程浩的《站在两个世界边缘》，毛姆的《月亮与六便士》，堀辰雄的《起风了》，《小王子》，沈复的《浮生六记》以及《追风筝的人》，而纸质书基本都是Web前后端(JavaScript/ASP.NET/SPA)相关的书籍，Python相关的书籍和数学相关的书籍，这些书籍不能在这里展开讨论，感兴趣的朋友可以在博客里留言。</p><p>&emsp;&emsp;我是一个喜欢看电影的人，就是单纯地喜欢听人讲故事，这和约会意义上的看电影不同，我就是单纯地去看个电影而已。不过作为一个日常单身狗，总是要学会面对这个世界里满满的恶意。2017年看的第一部电影是韩寒的《乘风破浪》，这是一个笑点中夹杂着泪点的故事，剧情上借鉴了陈可辛导演的《难兄难弟》。接下来，2017年看过的超级英雄电影有《神奇女侠》、《蜘蛛侠 : 归来》、《雷神 : 诸神的黄昏》、《猩球崛起》。2017年看过的动画电影有《大护法》和《寻梦环游记》，其中前者是电影风格和政治隐寓吸引了我，而后者是讲述了一个亡灵节背景下的暖心故事，告诉我们如何去面对死亡、如何平衡家庭与梦想等。2017年看过一部讲述野外探险的电影《七十七天》，由赵汉唐和江一燕主要，这个电影是部旅游风景片，江一燕的存在感略弱，男主最终在雷雨夜里丧生，告诫人们要懂得量力而行，我们觉得去趟西藏就能净化心灵，可比净化心灵更重要的是好好活着。2017年最后一部电影是陈凯歌的《妖猫传》，改编自梦枕貘的《沙门空海》，以唐朝时期僧人空海和诗人白居易为主角，讲述唐玄宗和杨玉环的爱恨纠葛，这部电影视觉美是无与伦比的，虽然后期剧情呈现方式存在瑕疵，但可以让我们重新感受大唐盛景，以一种新的方式解读《长恨歌》，我觉得这样就很好啦！</p><p>emsp;&emsp;2017年写作方面相对去年明显退步，因为有两个月一直没有时间写东西，尤其是拖延症发作的时候，一篇博客大概两三个周甚至一个月方能写完，这大概是2017年最让人遗憾的事情。2017年共撰写博客16篇，访客量增加约30万，受到CSDN运营梦姐的离开以及CSDN战略调整的影响，2017年博客流量的主要来源是旧文章。2017年技术博客的写作，基本延续2016年的策略，不再写面向新手的教程类内容，而是侧重对技术的整合和改进，尽可能地去写一种思路或者想法，与此同时，希望在技术博客以外扩展更多的，譬如写对生活的感悟、对电影的思考等等，计划中打算开通知乎专栏(已开通)、开通个人微信公众号(正在准备)。总而言之，希望拓宽博客的流量渠道，提升个人品牌的影响力，你可以不用长得特别帅，但要有一种不怒自威的气场，因为要想成为架构师，这是件任重而道远的事情！</p><h1 id="New-TodoList-“2018”"><a href="#New-TodoList-“2018”" class="headerlink" title="New TodoList(“2018”)"></a>New TodoList(“2018”)</h1><p>&emsp;&emsp;写这样一个TodoList，我总觉得像在立一个个flag，因为2017年计划的MongoDB就没有达到目标，所以2018的TodoList我希望可以更接地气一点，具体来讲，我从技术、生活两个方面来制定目标：</p><p>首先，希望2018年的我在技术方面：</p><ul><li>学会一个前端框架(Vue/Angular/React)</li><li>继续完善HttpServer(支持RESTful)</li><li>Web后端认证授权及中间件(OWIN/OAuth)</li><li>继续学习Python数据分析(Pandas)</li><li>写一个微信小程序(词典/小工具)</li><li>建立知乎专栏/个人微信公众号</li></ul><p>其次，希望2018年的我在生活方面：</p><ul><li>认真谈恋爱，找个女朋友</li><li>提升整体审美及品味(穿衣/吃饭/健身)</li><li>去一趟莫高窟或者苏州园林(做想做的事)</li><li>争取涨薪，继续存钱</li><li>租一个可以更好做饭的房子</li><li>和任何人都聊得来(沟通技巧/情商)</li></ul><p>2018，愿期望不负，愿你被温柔对待，岁月静好，现世安稳，心安处即吾家，晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;当朋友圈开始集体缅怀18岁的时候，我们说，从此以后是00后的天下，因为所以的90后都成年了。或许我们都是喜欢怀旧的人，所以我们选择以这样一种方式，在狂欢中失去的同时，在失去中缅怀着，仿佛这种死磕到底的做法，会让这一切来得更晚一些。一群人抱着手机等待着
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="总结" scheme="http://qinyuanpei.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="回首" scheme="http://qinyuanpei.github.io/tags/%E5%9B%9E%E9%A6%96/"/>
    
      <category term="展望" scheme="http://qinyuanpei.github.io/tags/%E5%B1%95%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>基于新浪微博的男女性择偶观数据分析</title>
    <link href="http://qinyuanpei.github.io/posts/1386017461/"/>
    <id>http://qinyuanpei.github.io/posts/1386017461/</id>
    <published>2017-12-23T20:28:40.000Z</published>
    <updated>2018-03-01T01:38:10.358Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;或许是因为我喜欢的姑娘从来都不喜欢我，而感情上的挫折一度让我陷入无尽的自卑。朋友在朋友圈里发布一条关于皮影戏的动态，我开玩笑说这个皮影戏结局应该是个悲剧，因为我注意到在剧中，无论一个人如何卖力地表演甚至双腿跪倒在地，有的人从故事开场到结束一直对此无动于衷。朋友回复我说，这不就是你现在的状态吗？我沉默半天终于熄灭手机屏幕。我听到过各种各样让我放弃她的话，即使这种念头在我脑海里萌生已久，是幻想让我硬生生地拖了这么久。当你努力想要融入对方的生活，而等待你的是一道冰冷的墙。这种感觉像什么呢？大概就是一个又一个“好友”安安静静地躺在联系人的置顶名单里，不敢发消息让对方知道，更不愿残忍地把对方删除。我安慰自己说，对我而言，我失去的是一个不喜欢你的人；而对对方而言，失去的是一个喜欢她的人。你当然可以说我没有那么喜欢她，如果一定要喜欢到卑微如尘土的地步，我宁愿一个人单身到天荒地老。</p><p>&emsp;&emsp;当我意识到人与人间，即使亲近如父母尚且无法完全理解彼此的时候，我忽然发现一个有趣的现象，我们喜欢一个人的时候，首先注意到的会是外表，我们将其称之为眼缘，所以人与人间的感情纽带最初会是吸引，而后是了解彼此的优缺点，最终是相互理解和扶持。可我们知道，外表是可以伪装出来的，所以我们习惯通过外表和言语来评价一个人，这就像是数学归纳法，我们总认为推倒第一块多诺米骨牌，就意味着所有多诺米骨牌都会倒下。可现实世界矛盾的地方就在于，我们认为理所当然正确的事情，或许正是我们无法证明其正确性的，这在数学上称为哥德尔不完备定理。所以，一件残酷的事情是，当你无法吸引一个人的时候，通往内心世界的路就被堵死了。朋友圈里精彩纷呈的社交互动，并不代表有人愿意真正了解你的生活，何况是你吸引不到的人呢？我很想知道，我们在选择伴侣的时候到底看中什么，所以我一直在关注<a href="https://weibo.com/u/5566882921" target="_blank" rel="noopener">@西安月老牵线</a>上发布的征婚交友类微博，本文的故事从这里正式展开。</p><h1 id="身高175的悲伤"><a href="#身高175的悲伤" class="headerlink" title="身高175的悲伤"></a>身高175的悲伤</h1><p>&emsp;&emsp;或许你以为我会无聊到试图从微博上找到女朋友，可事实上作为一个程序员的我，即使整天投入精力在编程上，依然无法避免对象空引用的异常出现。如果说找到女朋友是个小概率事件，那么在我看来，找到一个真正懂我、喜欢我的女朋友，基本上是不可能事件。你不要觉得我对没有调整好心态、对生活过分悲观，如果你了解贝叶斯公式就会真正地理解我说的话。这个微博开始引起我的注意，是我发现身高在155到165左右的女生，对男生的要求基本上无疑例外地是175+到180+，我想知道到底有多少女生是有这样的想法，这是我想要抓取新浪微博的数据进行分析的初衷。更重要的是，身高不到175的我在面对这种要求的时候是悲伤的，因为我想起了《巴黎圣母院》中的卡西莫多，一个外表丑陋而拥有高尚人格的“丑八怪”。现代人整天都特别忙碌，以至于没有人会有耐心，园艺在忍受着你丑陋的外表的同时，同你讲一只小兔子亲了它喜欢的长颈鹿一下这种故事。</p><p>&emsp;&emsp;我听到这样一句话，“好看的皮囊千篇一律，有趣的灵魂万里挑一”，可谁会觉得像卡西莫夫这样的人，会拥有或者配拥有高尚的人格呢？我们这副皮囊不管好看与否，它们都是父母给予我们的最好的礼物。难道一个所谓情商高的人，会在收到别人的时候因为礼物不好看而生气吗？ 我想起《画心》里懊悔受狐妖小唯皮相蛊惑而自毁双目的霍心，美丑都是父母赐予我们的，不该被我们拿来一番大肆炫耀，可我还是想知道，我们评价一个人的标准到底是什么？因为我渐渐明白，有些人不喜欢我们，并不是我们不好，而仅仅是某一点和对方不匹配。喜欢一个人的时候，像拔下身上的一根根刺，因为你越是得不到回应，就越像变成对方期待的样子，这个过程会让你觉得自己一无是处。直到今天看到一句话，一句足以热泪盈眶的话，如果不曾喜欢你，我本来非常可爱的。有时候，人做一件事情，或许就是在和自己过不去，比如说这件事情。</p><h1 id="花点时间爬爬微博"><a href="#花点时间爬爬微博" class="headerlink" title="花点时间爬爬微博"></a>花点时间爬爬微博</h1><p>&emsp;&emsp;好了，现在我们来考虑从新浪微博上抓取<a href="https://weibo.com/u/5566882921" target="_blank" rel="noopener">@西安月老牵线</a>上发布的微博，因为这是我们进行数据分析的前提。事实上，在写这篇文章前我曾花了大量时间来调试爬虫，然后用了一天的时间对数据进行清洗，最终利用晚上下班的时间生成词云。由此我们可以理出整体的思路：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171223234945060" alt="流程图" title="">                </div>                <div class="image-caption">流程图</div>            </figure><p>&emsp;&emsp;通过流程图我们可以注意到，在这里我选择了Python来实现整个功能。转眼间我已经25岁了，这是种什么样的概念呢？两年前我23岁的时候，听别人讨论结婚这个问题，我觉得它离我还很遥远。如今看着周围人都结婚了，我竟有种“高处不胜寒”的感觉。所以呢，人生苦短，当你不能阻止时间一天天消逝的时候，你只能趁着现在去做你想做的事情，为了节省时间去做技术以外的尝试，我选择拥有全世界最丰富的库的Python。</p><p>&emsp;&emsp;这段时间学习数据分析，我渐渐意识到我们所熟悉的这个世界，如果以一种理性的角度，完全通过数据来解构的话，我们在这个数字时代里留下的每一条讯息，都冷冰冰地暴露着我们的喜怒哀乐，每一张照片里细微的表情变化，每一段文字里隐匿着的真实意图，都能被人脸识别和自然语言处理等等，这类人工智能为代表的技术所解读，我们努力想在朋友圈里隐藏些什么，当朋友圈的访问范围从半年逐渐缩小到三天，我们究竟能隐藏下什么呢？</p><h2 id="微博爬虫分析"><a href="#微博爬虫分析" class="headerlink" title="微博爬虫分析"></a>微博爬虫分析</h2><p>&emsp;&emsp;首先，我们需要从微博上抓取数据下来，我没有去做抓包分析这样的重复性工作，因为我注意到这个问题，在网络上有很多朋友在讨论，我主要参考了以下内容：</p><ul><li><a href="https://www.zhihu.com/question/29666539/answer/63325949" target="_blank" rel="noopener">Python 爬虫如何机器登录新浪微博并抓取内容？</a></li><li><a href="https://github.com/xchaoinfo/fuck-login" target="_blank" rel="noopener">https://github.com/xchaoinfo/fuck-login</a></li><li><a href="http://python.jobbole.com/84349/" target="_blank" rel="noopener">用Python写一个简单的微博爬虫</a></li></ul><p>通过以上内容，我了解到在抓取新浪微博数据的问题上，我们基本会有以下思路：</p><ul><li>保存cookie信息，利用requests库发起请求并带上cookie</li><li>利用requests库模拟登录新浪微博并在请求过程中保持cookie</li><li>利用selenium库模拟登录新浪微博然后取得页面内容</li><li>利用PhantomJS库模拟登录新浪微博然后取得页面内容</li></ul><p>可以看出差异主要集中在cookie的获取以及是否支持headless模式，并且我们得到一个共识，抓取新浪微博<a href="http://weibo.cn/" target="_blank" rel="noopener">移动版</a>要比<a href="https://weibo.com" target="_blank" rel="noopener">PC版</a>要容易，因为移动版优先为小尺寸屏幕设备提供服务，因而页面结构相对整洁便于我们提取数据。起初博主认为第一种方式太简单粗暴，坚持要采用第二种方式去实现，最终证明还是太年轻了啊，新浪微博的登录给人的感觉就是蛋疼，这里就简单介绍下思路哈。</p><p>&emsp;&emsp;首先我们会向服务器发出一次GET请求，它返回的结果是一段JavaScript代码，然后我们需要用正则匹配出其中的JSON字符，这样我们就获得了第二次请求需要用到的参数；接下来，第二次请求是一个POST请求，我们需要将用户名采用Base64加密，密码则采用RSA加密，需要用到第一次请求返回的参数。实际上，新浪微博官方给我们提供API获取微博数据，可这个API可以获取的微博数据非常有限，更让人难以接受的是新浪微博的应用授权方式，如果我们采用调用API的方式，在这里会有第三次POST请求，有朋友分析了完整的模拟登录过程，可我对此表示毫无兴趣啊。最早我采用了模拟这种方式，抓取第一页的时候还是登录的状态，可等到抓取第二页的时候变成了注销的状态，整个过程使用的是同一个session对象，所以我最后果断放弃了这种方式。</p><p>&emsp;&emsp;好了，现在我们只需要在Chrome里F12找到Network选项卡，抓一次包取得cookie，然后在请求的时候带上cookie即可。我们不用过分担心cookie过期的问题，在博主测试的时候，一个cookie可以持续工作3至5天，而且在后面我们会讲到，这个爬虫抓取的数据量其实并不大，在一两个小时内就可以完成抓取，没有必要将爬虫考虑得太严谨。在下图中我们标记出了博主计算机上存储的cookie，我们通过cookie就可以免登录抓取信息啦。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171224011921074" alt="提取Cookie" title="">                </div>                <div class="image-caption">提取Cookie</div>            </figure><p>&emsp;&emsp;解决登录的问题以后，回到这个问题本身，我们需要抓取<a href="https://weibo.com/u/5566882921" target="_blank" rel="noopener">@西安月老牵线</a>发布的所有微博，移动版对微博做了分页处理，所以我们只需要知道总共有多少页，然后循环去提取每一页里的信息即可，因为我们注意到每一页的地址都符合<a href="https://weibo.cn/u/3232168977?page=2" target="_blank" rel="noopener">https://weibo.cn/u/3232168977?page=2</a>这样的形式。首先页数，我们可以通过name为mp的隐藏控件来获得，其value属性表示总页数。其次，每条微博存放在class为c，id以M_开头的div标签里，在这里我们只需要文本信息，顺藤摸瓜我们发现信息被存放在class为ctt的span标签里，这里博主遇到一个奇怪的问题，BeautifulSoup默认的解析器html.parser，不知道因为原因无法解析出标签，而lxml当时因为pip的问题无法安装，所以不能使用XPath来解析DOM解构，在这里我认为XPath更适合这个场景，如果有时间可以考虑对代码进行重构。</p><p>&emsp;&emsp;在抓取微博的过程中，博主发现官方的反爬虫策略非常给力，连续工作超过5分钟IP就会被封锁，进而无法访问微博的服务器， 大概经过20至30分钟后会自动解封。或许主流的方案是花钱买动态代理，可我这个就是临时起意的一个想法，所以我采取了最简单粗暴的方法，让线程睡一会儿，在这样条件下，我花了大概1个半小时到2个小时左右的时间，从微博上抓取了5600条数据，并将其存储在了SQLite数据库中。什么？你问我为什么不考虑多线程，因为我这个人懒啊，这个问题最难的地方在数据分析，数据抓取方面我不太关注效率，因为我有足够的时间去等这些数据，所以关于性能方面的问题，有时间我们再做进一步讨论吧！</p><h2 id="数据处理过程"><a href="#数据处理过程" class="headerlink" title="数据处理过程"></a>数据处理过程</h2><p>&emsp;&emsp;数据处理这块，我本来打算尝试下MongoDB这个数据库的，而实际上这是我今年计划要去学习的内容之一，后来因为种种原因一直搁置到现在，可当我注意到Windows下安装MongoDB的繁琐后，我果断放弃了这种念头回归简单的SQLite，我基本上是交叉使用Windows和Linux，而我知道Linux下安装MongoDB是非常简单的。我反复强调我喜欢小而美的东西，就是因为我想保留对方案的选择权。在这里我们的数据处理，主要是数据清洗和中文分词。首先，我们来一起看看数据库表的设计：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171224120313193" alt="数据表结构" title="">                </div>                <div class="image-caption">数据表结构</div>            </figure><p>&emsp;&emsp;我这里一切从简，所以将这5600多条数据都存储在一张表里，表中有四个字段ID、Post、Wish和Tags。显然，ID是自增的主键，为每条微博提供一个唯一的标识；Post存储我们从微博上抓取的原始信息，这里不含HTML标签，可是会含有微博表情字符啊摔；Wish存储每条微博中对伴侣的要求具体有哪些，这里我们主要通过关键字来截取可谓简单粗暴，具体原因稍后会讲到:)；Tags存储Wish字段经过分词以后的结果，这里我们使用结巴分词和SnowNLP，该字段中存储的是序列化后的JSON字符串，下面我们具体来讲这些字段的处理。</p><p>&emsp;&emsp;首先，分析<a href="https://weibo.com/u/5566882921" target="_blank" rel="noopener">@西安月老牵线</a>发布的微博我们可以发现，所有征婚相关的微博都是以<strong>#征婚交友#</strong>或者<strong>#月老爱牵线#</strong>这样的话题开始，并且每条微博都是先介绍个人情况，然后再描述对理想伴侣的期望，所以我们只需要找出每条微博里对理想伴侣的期望相关的描述，然后再根据这条微博是由<strong>男嘉宾</strong>还是<strong>女嘉宾</strong>发布的，即可汇总出男、女性对各自伴侣的期望到底是什么，我们将这部分信息更新在Wish字段里，我们一起来看具体的代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Filter Data</span><br><span class="line">sql = <span class="string">"SELECT ID, Post FROM table_weibo WHERE POST LIKE '%%%%%s%%%%' OR POST LIKE '%%%%%s%%%%'"</span></span><br><span class="line">sql = sql % (<span class="keyword">u</span><span class="string">'#征婚交友#'</span>,U<span class="string">'#月老爱牵线#'</span>)</span><br><span class="line">self.<span class="built_in">cursor</span>.<span class="keyword">execute</span>(sql)</span><br><span class="line">rows = self.<span class="built_in">cursor</span>.fetchall()</span><br><span class="line"></span><br><span class="line"># Adjust Data</span><br><span class="line">patterns = [<span class="string">'想找'</span>,<span class="string">'希望找'</span>,<span class="string">'要求'</span>,<span class="string">'希望另一半'</span>,<span class="string">'择偶标准'</span>,<span class="string">'希望对方'</span>,</span><br><span class="line"><span class="string">'希望'</span>,<span class="string">'找一位'</span>,<span class="string">'找一个'</span>,<span class="string">'一半'</span>,<span class="string">'找'</span>,<span class="string">'想'</span>,<span class="string">'喜欢'</span>,<span class="string">'择偶条件'</span>,<span class="string">'寻'</span>,<span class="string">'期待'</span>,</span><br><span class="line"><span class="string">'女孩'</span>,<span class="string">'男孩'</span>,<span class="string">'女生'</span>,<span class="string">'男生'</span>,<span class="string">'女士'</span>,<span class="string">'男士'</span>,<span class="string">'理想型'</span>]</span><br><span class="line">sql = <span class="string">"UPDATE table_weibo SET Wish = ? WHERE ID = ?"</span></span><br><span class="line"><span class="keyword">for</span> row in row<span class="variable">s:</span></span><br><span class="line">    id = row[<span class="number">0</span>]</span><br><span class="line">    post = row[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">match</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> pattern in pattern<span class="variable">s:</span></span><br><span class="line">        <span class="keyword">if</span>(pattern in post):</span><br><span class="line">            <span class="keyword">match</span> = post.<span class="keyword">find</span>(pattern) + <span class="built_in">len</span>(pattern)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">match</span> != -<span class="number">1</span>):</span><br><span class="line">            wish = str(post[<span class="keyword">match</span>:])</span><br><span class="line">            wish = wish.replace(<span class="string">'#西安月老牵线#'</span>,<span class="string">''</span>)</span><br><span class="line">            wish = wish.replace(<span class="string">'[心]@月老蜀黍'</span> ,<span class="string">''</span>)</span><br><span class="line">            wish = wish.replace(<span class="string">'#月老爱牵线#'</span>  ,<span class="string">''</span>)</span><br><span class="line">            self.<span class="built_in">cursor</span>.<span class="keyword">execute</span>(sql,(wish,id))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.<span class="built_in">cursor</span>.<span class="keyword">execute</span>(sql,(<span class="string">''</span>,id))</span><br><span class="line">self.connect.commit()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以注意到，我们首先按照话题对微博进行了筛选，然后通过关键字列表patterns来截取我们所需要的Wish字段，实际上这里是需要反复去调整patterns的，直到所有满足我们期望的数据都被提取出来，所以这是一个渐进式的数据处理过程。或许我们能想到通过NLP相关的技术来分析这段文本，我尝试通过SnowNLP去分析这样一段长度为100到500的文本，因为SnowNLP具备分析一段话的摘要及关键字的能力。可我发现这样实践下来效果并不太好，这是因为SnowNLP本身是以电商网站的评论数据为基础的，所以遇到我们微博这样相对灵活的文本信息时，它提取出的关键字并不能完全地符合我们的期望。固然，我们可以通过训练SnowNLP来达到我们的目的，可训练需要准备大量的文本信息作为支撑。作为一个懒惰的人，我最终选择了通过关键字来提取关键信息，准确度基本可以保证90%以上，因为暴力截取难免会拆分出不符合期望的信息。</p><p>&emsp;&emsp;接下来，我们有了针对男、女择偶要求期望的Wish字段，可这些信息对我们而言，依然显得繁重而冗余，所以接下来我们考虑对Wish字段进行分词，最初的设想是通过词性和语法来分析，可当我分完词以后我就不得不佩服中文的博大精深，这里我选择了两个中文处理相关的库，即<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">结巴分词</a>和<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">SnowNLP</a>，它们都是开源项目并且有大量的文档作为参考，这里想说的是，SnowNLP中支持中文文本的情感分析，这是我最初想要使用这个库的一个重要原因，因为我想从这些微博中找出评价一个人的形容词或者名词，而这些词的情感分析，可以作为我们是否将其作为一个评价指标的重要依据。</p><p>&emsp;&emsp;可我们有句话叫做“认真你就输了”，尤其在女性的思维模式中，充满太多太多不能直接去理解的信息。这种我不用举例子啦，现在铺天盖地的直男癌/女权癌席卷而来，其实有太多问题无关对错，你输就输在没有照顾好对方的情绪，我们现在常常把情商挂在嘴上，可情商概念中的<strong>自我意识</strong>、<strong>控制情绪</strong>、<strong>自我激励</strong>、<strong>认知他人情绪</strong>和<strong>处理相互关系</strong>，有60%说的是自我管理，而其余的40%，恰恰就是我们日常理解中关于人际关系方面的，所以我们说人工智能不能完全代替人类，因为只有绝对理性的世界是恐怖的，可只有情绪化的感情而不讲道理的世界则是空虚的。我们可以去追逐人类内心中的灵性，即真、善、美，这是任何冰冷的计算机所不具备的东西。可我们能不能真诚一点呢，明明知道这一切都是套路可你还满心期待，我们并非不懂得什么是爱，爱不是我用一个又一个套路去套路你，而是我明知这是套路还愿意陪你表演下去，我没有在讽刺浙江卫视某节目，愿温柔的你被这个世界温柔地对待。</p><p>&emsp;&emsp;关于结巴分词和SnowNLP地对比评测，大家可以参考：<a href="http://blog.csdn.net/sinat_26917383/article/details/77067515" target="_blank" rel="noopener">Python︱六款中文分词模块尝试</a>，这里博主发现SnowNLP适合做大颗粒分词拆分，而结巴分词适合做小颗粒分词拆分。其实，从分词效果上来讲，结巴分词是要比SnowNLP效果更好一些的，可我这样说不是会显得情商比较高吗？这样你们会喜欢吗？最终我们采取的方案是两者混用，故而我们有了这样的代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTags</span><span class="params">(<span class="keyword">self</span>,text)</span></span><span class="symbol">:</span></span><br><span class="line">    snow = SnowNLP(text)</span><br><span class="line">    sentences = snow.tags</span><br><span class="line">    tags = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="symbol">sentences:</span></span><br><span class="line">        words = pseg.cut(s[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="symbol">words:</span></span><br><span class="line">            tags.append(&#123;<span class="string">'word'</span><span class="symbol">:w</span>.word,<span class="string">'flag'</span><span class="symbol">:w</span>.flag&#125;)</span><br><span class="line">    <span class="keyword">return</span> json.dumps(tags)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以注意到，这里我们使用结巴分词获得了每个词的词性，不过到我写这篇文章的时候，对于词性的处理我依然没有什么好的想法，这里仅将其作为结果以JSON的形式存储到数据库中，现在我们基本上完成了所有数据处理的流程，在这个过程中会有些特殊的中文字符，我们采取暴力替换的方式进行去除即可，对此不在这里展开说啦。下图展示了数据库中部分数据：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171224141144095" alt="处理后的数据" title="">                </div>                <div class="image-caption">处理后的数据</div>            </figure><h2 id="处理结果呈现"><a href="#处理结果呈现" class="headerlink" title="处理结果呈现"></a>处理结果呈现</h2><p>&emsp;&emsp;说起这篇文章，可以说这是我第一次接触数据分析，我们这个时代积累了大量的数据，所以我们有基于大数据的推荐和预测等等相关场景，知乎和微博的首页Feed流经过无数次算法调整，可人们依然在抱怨算法向人们推荐了无关的内容，这是否说明，我们所期待的智能，仅仅是让我们觉得智能而已，这一系列基于统计的数据分析理论，是否一定是符合某种冥冥之中的规则，我想起《模仿游戏》中和卷福扮演的图灵形成鲜明对比的，正是以休.压力山大为代表的统计方法派，电影中他们试图通过分析字母出现的频率来破解恩尼格玛。对于数据分析而言，如果说可视化是面向人类的分析手段，那么数据挖掘就是面向机器的分析手段。作为一个刚刚入门的萌新，我描述的是我对数据分析的一种感觉。回到本文主题，这里我选择以词云作为最终处理结果的呈现载体。</p><p>&emsp;&emsp;词云，即WordCloud，是一种展现关键字出现频率的表达方式，如果你对博客写作比较熟悉的话，就会知道诸如WordPress、Ghost、Hexo等都提供了标签云功能，我们每篇文章中都会给文章添加若干标签，而标签基本可以让读者了解这个博客都有哪些内容，在标签云中出现频率越高的标签其字体通常会越大，这样我们可以非常直观地了解到，每个因素在整体上占到的比重。本文之所以采用这种方案，正是希望通过词云来呈现男女在择偶观上更看重什么。生成词云的方式有很多，具体可以参考这篇文章：<a href="https://www.zhihu.com/question/28382979/answer/117544077" target="_blank" rel="noopener">除了 Tagxedo外，还有什么好的软件制作可以词云?</a>，而博主最终选择了<a href="https://github.com/amueller/word_cloud" target="_blank" rel="noopener">wordcloud</a>，你可以看到Python基本上是万能的语言，有这么多优秀的第三方库可以用，我就问你怕不怕，关于这个库的用法，请参考：<a href="https://amueller.github.io/word_cloud/" target="_blank" rel="noopener">https://amueller.github.io/word_cloud/</a>，如果通过pip无法直接安装该库，可以通过<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud" target="_blank" rel="noopener">这里</a>下载.whl文件进行安装，注意升级pip到最新版本即可。</p><p>&emsp;&emsp;参照官方的示例，我们从数据库中根据Post来过滤性别，根据Tags来获取关键字，然后将所有Tags串联成一个字符串，传递给WordCloud模块即可。下面给出代码片段：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filter Data</span></span><br><span class="line">sql = <span class="string">"SELECT Post, Tags FROM table_weibo WHERE Tags &lt;&gt; ''"</span></span><br><span class="line">self.cursor.execute(sql)</span><br><span class="line">rows = self.cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Filter Tags</span></span><br><span class="line">male_tags = <span class="string">''</span></span><br><span class="line">female_tags = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    post = row[<span class="number">0</span>]</span><br><span class="line">    tags = json.loads(row[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="string">u'男嘉宾[向右]'</span> <span class="keyword">in</span> post:</span><br><span class="line">        female_tags += <span class="string">','</span>.join(map(<span class="keyword">lambda</span> x:x[<span class="string">'word'</span>],tags))</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">u'女嘉宾[向右]'</span> <span class="keyword">in</span> row[<span class="number">0</span>]:</span><br><span class="line">        male_tags += <span class="string">','</span>.join(map(<span class="keyword">lambda</span> x:x[<span class="string">'word'</span>],tags))</span><br><span class="line">                </span><br><span class="line"><span class="comment"># WordCloud self.generateWordCloud(female_tags,'female.png','output_female.png') self.generateWordCloud(male_tags,'male.png','output_male.png')</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在这里我们主要将男嘉宾/女嘉宾分别筛选出来，然后将分词结果用逗号串联起来，这样即可得到male_tags和female_tags，我们会将其传递给WordCloud模块，可以注意到我们为男性/女性词云分别设置了不同的背景图片，最终会生成两张不同的图片，这里主要参考了<a href="https://amueller.github.io/word_cloud/auto_examples/colored.html" target="_blank" rel="noopener">Image-colored</a>这个示例，代码片段展示如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateWordCloud</span><span class="params">(self,text,background,output)</span>:</span></span><br><span class="line">    back_coloring = np.array(Image.open(background))</span><br><span class="line">    stopwords = set(STOPWORDS)</span><br><span class="line">    stopwords.add(<span class="string">u'西安'</span>)</span><br><span class="line">    stopwords.add(<span class="string">u'生活'</span>)</span><br><span class="line">    wordcloud = WordCloud(</span><br><span class="line">        font_path=<span class="string">'simfang.ttf'</span>,  <span class="comment"># 设置字体</span></span><br><span class="line">        background_color=<span class="string">"white"</span>,  <span class="comment"># 背景颜色</span></span><br><span class="line">        max_words=<span class="number">5000</span>,  <span class="comment"># 词云显示的最大词数</span></span><br><span class="line">        mask=back_coloring,  <span class="comment"># 设置背景图片</span></span><br><span class="line">        stopwords=stopwords, <span class="comment">#停用词设置</span></span><br><span class="line">        max_font_size=<span class="number">75</span>,  <span class="comment"># 字体最大值</span></span><br><span class="line">        random_state=<span class="number">42</span>,</span><br><span class="line">        width=<span class="number">1000</span>, height=<span class="number">860</span>, margin=<span class="number">15</span>,<span class="comment"># 设置图片默认的大小,但是如果使用背景图片的话,那么保存的图片大小将会按照其大小保存,margin为词语边缘距离</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    wordcloud.generate(text)</span><br><span class="line">    plt.imshow(wordcloud)</span><br><span class="line">    plt.axis(<span class="string">"off"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    wordcloud.to_file(output)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里我们注意到添加了两个停止词，这是因为我们发现，<strong>西安</strong>和<strong>生活</strong>这两个关键词，在整体中所占权重虽然较高，可是因为我们这里抓取的是西安本地的微博，所以这两个关键词对我们而言是没有意义的。再对这两个关键字进行剔除以后，我们最终生成的词云如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171224153059421" alt="男性心目中的伴侣" title="">                </div>                <div class="image-caption">男性心目中的伴侣</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171224153232864" alt="女性心目中的伴侣" title="">                </div>                <div class="image-caption">女性心目中的伴侣</div>            </figure><h1 id="这是个看脸的世界"><a href="#这是个看脸的世界" class="headerlink" title="这是个看脸的世界"></a>这是个看脸的世界</h1><p>&emsp;&emsp;对这样一个显然成立的结论，我是表示失望的，这种感觉像什么呢？就像你期待着对方说喜欢你，结果到最后她还是会说我们不合适。可花费如此大的篇幅来讲这样一个悲伤的故事，我们就象征性地分析下结论吧！首先，我们注意到男性心目中的伴侣，排名靠前关键字是<strong>性格</strong>、<strong>孝顺</strong>、<strong>善良</strong>、<strong>懂事</strong>、<strong>结婚</strong>、<strong>身高</strong>、<strong>眼缘</strong>，而女性心目中的伴侣，排名靠前的关键字是<strong>身高</strong>、<strong>稳重</strong>、<strong>责任心</strong>、<strong>上进心</strong>、<strong>工作</strong>、<strong>成熟</strong>。所以，我现在完全可以理解，为什么女生会对180的身高如此迷恋，因为她们想被男朋友举高高呀，我的一位朋友如是说。</p><p>&emsp;&emsp;与此同时，我们发现很多指标譬如<strong>孝顺</strong>、<strong>善良</strong>、<strong>稳重</strong>、<strong>责任心</strong>、<strong>上进心</strong>等，其实都是需要两个人在相处久了以后慢慢去验证的，可这些最终会被<strong>眼缘</strong>和<strong>身高</strong>这种因素阻挡在外面。或许你会觉得这样浅显的道理，居然值得我花费时间和精力去思考。一个你吸引不到的人，终究是难以拉近两个人心间的距离的。喜欢是两个人的事情，我不是要卑微地乞求你来见我，而是你想要来见我我就主动迎上去。有天在QQ空间看到有人在看《怦然心动》，就忍不住下载下来一个人看。有时候我们喜欢的那个人，或许并没有那么好，你会渐渐发现，那种因为喜欢而附加在对方身上的光环，会随着时光而慢慢变淡。而有那么一瞬间，我只想比她变得更优秀，而不再幻想她会转身回来看我，或许这就是成长吧！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;大概没有谁会像我这样，在写一篇技术文章的过程中，掺杂如此多的个人情感。可有时候，一个人做一件事情的动机，的确就是如此简单。我羡慕175以上的身高，可是不是我具备了这样的身高，你就会喜欢我呢？我想应该不会吧，因为你总能找到新的理由来拒绝我。所以，我写这篇文章，通过Python抓取新浪微博数据并对其进行分析，并不是想告诉你，你因为不具备哪些因素而不被人喜欢，而是想告诉你，我们每一个人都是这个世界上独一无二的存在，我们的优点同我们的缺点组合起来，这才是完整的我们。别人喜欢不喜欢我们到底有什么意义呢？就像我们喜欢许嵩、喜欢林依晨，难道就要让人家喜欢我们吗？我可以非常喜欢你，但我一定要骄傲地喜欢你，因为我骄傲时的样子最帅，谁让这是一个看脸的世界呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;或许是因为我喜欢的姑娘从来都不喜欢我，而感情上的挫折一度让我陷入无尽的自卑。朋友在朋友圈里发布一条关于皮影戏的动态，我开玩笑说这个皮影戏结局应该是个悲剧，因为我注意到在剧中，无论一个人如何卖力地表演甚至双腿跪倒在地，有的人从故事开场到结束一直对此无动
      
    
    </summary>
    
      <category term="数据分析" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="http://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="微博" scheme="http://qinyuanpei.github.io/tags/%E5%BE%AE%E5%8D%9A/"/>
    
      <category term="词云" scheme="http://qinyuanpei.github.io/tags/%E8%AF%8D%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>冬天来了，春天还会远吗？</title>
    <link href="http://qinyuanpei.github.io/posts/3111375079/"/>
    <id>http://qinyuanpei.github.io/posts/3111375079/</id>
    <published>2017-11-19T10:16:17.000Z</published>
    <updated>2018-03-01T01:38:10.358Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;接到妈妈打来的电话时，时间已然接近中午时分，从床上爬起来的刹那间，就听见妈妈熟悉的声音。妈妈问我年底公司有没有什么变动，顿时千万种思绪涌上心头，不知道该对电话彼端的妈妈说些什么。我突然想到二十四岁时的我，从第一家公司裸辞时的情景，可如今再度让父母为此焦虑，让身为人子的我感到惭愧不安。电话里妈妈让我照顾好自己，一个人在外不要太委屈自己。当一个人不被这个世界接纳的时候，就像是浑身长满刺的仙人掌。可在最亲近的家人眼里，我们永远是这个世界上独一无二的存在。我是一个不大主动同家里的人，在那一刻我忽然觉得，这个冬天没有那么冷了，即使我身处没有暖气的出租屋里，即使早晨带着体温的被子早已凉透，我想对自己说一句，冬天来了，春天还会远吗？</p><p>&emsp;&emsp;发生在年底的release事件，就像这个冬天里的雾霾如约而至，即使早在去年就经历过这样的事情，可当它真实地发生在自己身上时，依然不免让人感到这个冬天的寒冷。纵观二十朝兴废更替，历史对我们而言常常是相似的。诸葛亮为“克复中原”六次北伐出师未捷而身先死的遗憾，唐玄宗宠溺杨玉环终致“安史之乱”而奔走蜀中避祸时的仓皇，这一切大概是我们如今坐西成高铁时无法想到的吧。有时候人的命运像极了历史的兴衰，记得三年前和同学第一次来西安，那个时候我们说，总有一天我们会再来这里的，那时的我或许完全不知道现在会面临这种处境，看着那些年龄比自己大依然碌碌无为的人，看着那些面临中年危机而不得不向生活妥协的人…..我告诉自己，我永远都害怕自己变成这样的人，所以让我内心无法平静下来的，永远是我近乎自责的自我反省式人格。</p><p>&emsp;&emsp;在接受被release的事实以后，就开始频繁地去准备面试和跳槽。可年底时找工作注定是一个艰难的过程。其实回头想想今年面试的表现，前端、数据库等相关经验的匮乏，一度让我在面试中非常被动，而外冷内热的性格常常给人一种不自信的表现，特别是去葡萄城面试的这次体验，让我意识到在面试中我无法展示出和职位匹配的能力，我们说面试是双向选择的一个过程，这看起来有点像是找男女朋友一样，有时候我们太在乎对方而导致表现不佳。我花了时间去听知乎上有关面试技巧的Live，甚至找朋友帮我分析如何给出面试官满意的答案，有时候别人会觉得我对严厉到苛刻的程度，是因为我对某些东西太在乎的缘故，可是不在乎这些问题就能解决了吗？矫枉过正至少意味着出发点是好的，总比发现问题后一直无所作为要好很多。</p><p>&emsp;&emsp;我一直想找时间整理下这段时间面试遇到的题目，可令人窒息的拖延症让这种想法一直落空。有时候我怀疑，人和人的缘分都在第一眼就注定好了。或许你花时间和精力去追一个女生，但这种关系永远不会发生改变。人类总是肤浅地相信眼睛看到的，固执地认为自己的想法就是正确的，可人这种复杂的动物怎么会一眼就望穿呢，所以试图通过面试完全了解一个人，原本就是不切实际的想法。很多时候人与人接近并不是他们彼此熟悉，仅仅是因为大家的口味比较接近而已。无论多么熟悉的同事，在分开以后都会逐渐变得冷淡。每个人都像一只刺猬，离得太远会感觉到冷，而靠得太近会刺伤对方。大概是遇见小古花光所有运气，此后遇人不淑的厄运纷至沓来。人啊，简直是世界上最麻烦的一种动物。</p><p>&emsp;&emsp;有时候我会埋头去做自己的事情，朝着自己内心的目标一点点靠近，即使曾经想要和她分享这点喜悦的人，早已消失在茫茫的人海里。我写爬虫、做数据分析、做聊天机器人，这其中有太多事情，是我对记忆的一种自我延伸，因为在那些曾经灰暗的日子里，陪伴我的人除了她，就是这些我比任何人都要在乎的技术。《嫌疑人X的献身》里，石神说道：“通往山顶的路或许会有很多条，而找出最优雅的那一条，是数学家永恒的追求”。也许他们说得都是对的，即使翻过了2017年，这个季节依然属于冬天，她只会比以前更让你觉得寒冷，可这一切的一切终究是会过去的，冬天来了，春天还会远吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;接到妈妈打来的电话时，时间已然接近中午时分，从床上爬起来的刹那间，就听见妈妈熟悉的声音。妈妈问我年底公司有没有什么变动，顿时千万种思绪涌上心头，不知道该对电话彼端的妈妈说些什么。我突然想到二十四岁时的我，从第一家公司裸辞时的情景，可如今再度让父母为此
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="工作" scheme="http://qinyuanpei.github.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="生活" scheme="http://qinyuanpei.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感悟" scheme="http://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>迁移Hexo博客到Google渐进式Web应用(PWA)</title>
    <link href="http://qinyuanpei.github.io/posts/450254281/"/>
    <id>http://qinyuanpei.github.io/posts/450254281/</id>
    <published>2017-10-24T23:13:41.000Z</published>
    <updated>2018-03-01T01:38:10.362Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;如果说通过TravisCI实现博客的自动化部署，是持续集成这个概念在工作以外的一种延伸，那么今天这篇文章想要和大家分享的，则是我自身寻求技术转型和突破的一种挣扎。前段时间Paul同我聊到Web技术的发展趋势，Paul认为Web应用会逐渐取代原生应用成为主流，我对此不置可否。真正让我陷入思考的是，在这个充满变化的时代，知识的更新速度远远超过你我的学习速度，我们应该如何去追随这个时代的步伐。如同那些淹没在时间河流里的技术名词，当青春不再的时候，我们喜欢把这个过程称之为成长，当发现距离第一次使用FontPage制作网站已过去十年，当发现曾经的网页三剑客在岁月蹉跎里频频改换姓名，当发现那些淹没在历史里的技术来不及学习就成为过往……或许，这个世界真正迷人的地方，就在于它每天都在不断变化。</p><h1 id="新一代Web应用——PWA"><a href="#新一代Web应用——PWA" class="headerlink" title="新一代Web应用——PWA"></a>新一代Web应用——PWA</h1><p>&emsp;&emsp;接着Paul关于Web技术的这个话题，我认为Web技术在短期内会成为原生应用的一种补充。事实上，原生应用和Web应用哪一个会是未来，这个问题的争论由来已久，在业界我们可以看到HTML5、PhoneGap、React/React Native、Electron/NW.js、小程序等方案百家争鸣，每一种方案都可以让我们去Web技术去打破平台间的差异。与此同时，我们注意到移动开发领域对原生技术的需求在缩减，虽然马克·扎克伯格曾表示，“选择HTML5是Facebook最大的错误“，可我们注意到，越来越多的Web技术被运用在原生应用中，Web技术被认为是最佳的打造跨平台应用的技术，可以通过一套代码实现不同平台间体验的一致性。我们注意到知乎和天猫的客户端中都混合使用了一定的Web技术，因为纯粹使用原生技术去开发一个移动应用，其最大的弊端就在于我们要为Android和iOS维护两套不同的代码，从国内曾经疯狂火热的iOS培训就可以看出，单独使用原生技术去开发客户端，其成本实际上是一直居高不下的。</p><p>&emsp;&emsp;虽然我们有Xamarin这样的跨平台技术，试图用一种编程语言和代码共享的方式，去开发两种不同平台的应用程序，可是我们注意到，平台间的差异和抗阻是天然存在的，就像SQL和面向对象这样我们再熟悉不过的例子。同样的，Facebook的React Native项目，试图用Web技术去弱化平台间的差异，React Native存在的主要问题是，它依然依赖原生组件暴露出来的组件和方法，所以像DatePickerIOS、TabBarIOS等控件是iOS Only的，这意味着在开发过程中开发者还是要考虑平台间的差异性，其次React本身的JSX(对应HTML)、CSS Layout(对应CSS)本身是具有一定的学习曲线的，虽然底层因为没有使用WebView的原因提高了部分性能，然而整体上是牺牲了扩展性的。总而言之，这是一个介于Web技术和原生技术之间的中间技术，在我看来地位着实蛮尴尬的，因为无论在Web层还是Native层都选择了部分妥协，完美实现跨平台真心不容易啊。</p><p>&emsp;&emsp;要掌握一门新技术，最好的方法就是去应用它。我的博客使用的是Indigo主题，这是一个典型的Material Design风格的主题，所以我一直想尝试将其改造成原生应用，我曾经接触过移动端应用开发，如果通过WebView内嵌网页的方式来实现，我需要处理离线状态下页面的显示问题，以及所有混合应用开发都会遇到的一个问题，即原生应用层需要和Web应用层进行通信的问题。而如果采用Hybrid App的思路去开发一个混合应用，意味着我需要去学习Cordova这样的Hybrid开发框架，去了解JavaScript和Native交互的细节。那么有没有一种学习成本相对较低，同时可以提供原生应用体验的思路呢？答案是确定的，这就是我们下面要说的渐进式应用(PWA)。</p><p>&emsp;&emsp;渐进式应用(Progressive Web Apps，PWA)是Google提出的新一代Web应用概念，其目的是提供可靠、快速、接近Native应用的服务方案。我们知道传统Web应用有两个关键问题无法解决，即<strong>需要从网络实时加载内容而带来的网络延迟</strong>和<strong>依赖浏览器入口而带来的用户体验</strong>，从某种意义上而言，渐进式应用的出现有望让这些问题得到解决，首先，渐进式应用可以显著加快应用加载速度，其提供的离线缓存机制可以让应用在离线环境下继续使用，关键技术为Service Worker和Cache Storage；其次，渐进式应用可以被添加到主屏，有独立的图标、启动页、全屏支持，整体上更像Native App，关键技术为Web.App Manifest；最后，渐进式应用同操作系统集成能力得到提高，具备在不唤醒状态下推送消息的能力，关键技术为Push API和Notification API。</p><h1 id="PWA中关键技术解析"><a href="#PWA中关键技术解析" class="headerlink" title="PWA中关键技术解析"></a>PWA中关键技术解析</h1><p>&emsp;&emsp;Google对外提出PWA这个概念其实是在今天的二月份左右，所以现在我写这篇文章实际上是在赶一趟末班车。我最近比较喜欢的一个男演员张鲁一，在接受媒体采访时媒体称他是一个大器晚成的人，他的确让我找到了理想中成熟男人的一个标准，如果你要问我这个标准是什么，我推荐你去看他主演的电视剧《红色》。那么，好了，为了让大家了解渐进式Web应用(<strong>PWA</strong>)，相比其它跨平台方案有何优缺点，我们这里来简单讨论下PWA中的关键技术。</p><h2 id="ServiceWorker"><a href="#ServiceWorker" class="headerlink" title="ServiceWorker"></a>ServiceWorker</h2><p>&emsp;&emsp;我们知道，传统的Web应用需要在网络环境下使用，当处在离线环境下时，因为HTTP请求无法被发送到服务器上，所以浏览器通常会显示一个空白页，并告知用户页面无法加载，因此会影响用户在离线环境下的使用体验，与此同时，因为Web页面在打开的过程中需要加载大量资源，因此在页面刚刚打开的一段时间内，用户看到的页面通常都是一个空白页面，考虑到缓存或者是预加载的Web应用，通常都会以预设资源作为占位符来填充页面，因此带来访问者的印象往往会更好。那么渐进式Web应用带给我们最大的惊喜，就是它可以在离线环境下使用，其核心技术就是ServiceWorker，我们来一起看看如何使用SeviceWorker：<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker.register(<span class="string">'service-worker.js'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(registration)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'service worker 注册成功'</span>);</span><br><span class="line">  &#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'servcie worker 注册失败'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们这里看到一个基本的注册ServiceWorker的代码片段，并且它采用了业界流行的Promise的写法。那么首先第一个问题，ServiceWorker到底是什么？ServiceWorker本质上是一个Web应用程序和浏览器间的代理服务器，它可以在离线环境下拦截网络请求，并基于网络是否可用以及资源是否可用，来采取相对应的处理动作，所以ServiceWorker最基本用法是作为离线缓存来使用，而高阶用法则是消息推送和后台同步。通常来讲，ServiceWorker会经历如下的生命周期：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://jbcdn2.b0.upaiyun.com/2016/01/55b0169cdfe92b08203757ebc4e5ece2.png" alt="ServiceWorker生命周期" title="">                </div>                <div class="image-caption">ServiceWorker生命周期</div>            </figure><p>注：<strong>配图来自  <a href="http://web.jobbole.com/84792/" target="_blank" rel="noopener">http://web.jobbole.com/84792/</a></strong></p><p>&emsp;&emsp;按照<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">官方文档</a>中的定义，ServiceWorker同WebWorker一样，是一段JavaScript脚本，作为一个后台独立线程运行，其运行环境与普通的JavaScript不同，因此不直接参与Web交互行为，从某种意义上来说，ServiceWorker的出现，正是为了弥补Web应用天生所不具备的离线使用、消息推送、后台自动更新等特性，我们这里来看一个使用ServiceWorker缓存文件已达到离线使用的目的的例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheStorageKey = <span class="string">'minimal-pwa-1'</span></span><br><span class="line"><span class="keyword">var</span> cacheList = [</span><br><span class="line">  <span class="string">'/'</span>,</span><br><span class="line">  <span class="string">"index.html"</span>,</span><br><span class="line">  <span class="string">"main.css"</span>,</span><br><span class="line">  <span class="string">"e.png"</span></span><br><span class="line">]</span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(cacheStorageKey)</span><br><span class="line">    .then(<span class="function"><span class="params">cache</span> =&gt;</span> cache.addAll(cacheList))</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> self.skipWaiting())</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在这里例子中，我们在ServiceWorker的install事件中添加了待缓存文件列表，这将意味着这些静态资源，会在网页中的ServiceWorker被install的时候添加到缓存中，我们在某个合适的时机到来时就可以再次使用这些缓存资源。事实上考虑到安全性的问题，ServiceWorker在设计时被约束为按照路径给予最高权限，即ServiceWorker在指定路径下是有效的。这里简单提下ServiceWorker的缓存策略，因为这个问题在我看来蛮复杂的，例如官方出品的<a href="https://github.com/GoogleChromeLabs/sw-toolbox" target="_blank" rel="noopener">sw-tool</a>中定义的缓存策略就有如下五种：</p><ul><li>网络优先:：从网络获取, 失败或者超时再尝试从缓存读取</li><li>缓存优先:：从缓存获取, 缓存插叙不到再尝试从网络抓取</li><li>最快：同时查询缓存和网络, 返回最先拿到的</li><li>仅限网络：仅从网络获取</li><li>仅限缓存：仅从缓存获取</li></ul><p>&emsp;&emsp;我们刚刚提到被缓存的静态资源会在合适的时机被再次使用，那么什么时候可以称之未合适的时机呢？在这个问题中，我们是指fetch事件，事实上通过拦截fetch事件，我们就可以拦截即将被发送到服务器端的HTTP请求，ServiceWorker首先会检查缓存中是否存在待请求资源，如果存在，就直接使用这个资源并返回HTTP响应，否则就发起HTTP请求到服务器端，此时ServiceWorker担任的是一个代理服务器的角色。至此，我们就会明白，ServiceWorker的作用其实就是在离线条件下利用缓存伪造HTTP响应返回，这样我们就达到了离线使用的目的，传统的Web应用在离线环境无法使用，根本原因是没有这样一个Mock的Server去伪造HTTP响应并返回，因为HTTP请求此时根本就无法发送到服务端。为了让ServiceWorker全面接管HTTP请求以便利用请求，我们这里的实现方式如下：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span> &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.<span class="built_in">match</span>(event.request)</span><br><span class="line">      .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(response)</span></span> &#123;</span><br><span class="line">        // Cache hit - <span class="keyword">return</span> response</span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;好了，以上就是ServiceWorker在离线缓存方面的基本用法，希望进行深入了解的朋友，可以参考文末链接做进一步研究。</p><h2 id="Web-App-Manifest"><a href="#Web-App-Manifest" class="headerlink" title="Web App Manifest"></a>Web App Manifest</h2><p>&emsp;&emsp;接下来介绍Web App Manifest，它其实是Web开发领域的一个”叛徒”，因为它所做的事情为大家所不齿，基本可以概括为，怎么样假装自己是一个Native App，我们直接看它的定义：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Minimal app to try PWA"</span>,</span><br><span class="line">  <span class="attr">"short_name"</span>: <span class="string">"Minimal PWA"</span>,</span><br><span class="line">  <span class="attr">"display"</span>: <span class="string">"standalone"</span>,</span><br><span class="line">  <span class="attr">"start_url"</span>: <span class="string">"/"</span>,</span><br><span class="line">  <span class="attr">"theme_color"</span>: <span class="string">"#8888ff"</span>,</span><br><span class="line">  <span class="attr">"background_color"</span>: <span class="string">"#aaaaff"</span>,</span><br><span class="line">  <span class="attr">"icons"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"e.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"256x256"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个我确认没有什么好说的，详细的参数可以参考<a href="http://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/Manifest" target="_blank" rel="noopener">这里</a>，通常我们需要将以上文件命名为manifest.json，并通过以下方式引入到HTML结构中，通常是添加在<head>标签下，我们所期望的图标、启动页、主题色等Native App的特性都是在这里定义的，这里想吐槽的是，随着越来越多的平台开始向<head>标签中注入”新血液”，譬如<meta>标签和<link>标签：现在HTML结构变得越来越复杂，更不要说主流的AngularJS和Vue这类MVVM框架，基本上都是通过扩展HTML属性来完成数据绑定的。对PWA应用来讲，我们只需要在<head>标签下引入以下内容：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">"manifest"</span> <span class="attribute">href</span>=<span class="string">"manifest.json"</span> /&gt;</span><br></pre></td></tr></table></figure></head></head></head></p><p>这里简单介绍下Web App Manifest中常见的参数含义及其作用：</p><ul><li>name/short_name：表示应用被添加到屏幕上以后显示的名称，当屏幕空间不足以显示完整的name时，将显示short_name。</li><li>start_url：表示用户从屏幕启动应用时所加载网页的URL，通常我们将其指向网站的首页。</li><li>theme_color：表示应用程序的主题颜色，PWA事实上是建议使用Material Design设计风格的，因此该属性可以控制应用的主题颜色，并在页面加载完成前展示一个过渡动画。</li><li>scope：表示PWA应用的作用域，即哪些页面可以以PWA应用的形式呈现。</li><li>display：表示PWA应用呈现的方式，可以是fullscreen、standalone、minimal-ui和browser中的任意取值。</li><li>orientation：表示PWA应用的屏幕方向，如果你有移动开发的经验，对此应该不会感到陌生。</li><li>icons：表示PWA应用在屏幕上的图标，为了适配不同尺寸的屏幕，这里可以设置不同尺寸下的图标。同样地，如果你有移动开发的经验，对此应该不会感到陌生。</li></ul><h2 id="Push-Notification-API"><a href="#Push-Notification-API" class="headerlink" title="Push/Notification API"></a>Push/Notification API</h2><p>&emsp;&emsp;关于这两个东西，我们简单说一下啊，PWA中的Push机制主要有<a href="https://www.w3.org/TR/notifications/" target="_blank" rel="noopener">Notification</a>和<a href="https://www.w3.org/TR/push-api/" target="_blank" rel="noopener">Push API</a>两部分组成，前者用于向用户展示通知，而后者用于订阅推送消息。网络上对这块介绍的并不多，关于推送这个问题，一直是国内Android用户和开发者的一块心病，因为Google的推送服务在国内水土不服，因此国内厂商或者是SDK提供商基本上都有自己的一套方案，这就导致在用户的设备上同时开启着若干个消息推送服务，用户手机里的电就是这样一点点被耗尽的，所以这个问题大家看看就好。在PWA中，我们可以通过ServiceWorker 的后台计算能力结合 Push API 对推送事件进行响应，并通过 Notification API 实现通知的发出与处理：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'push'</span>, event =&gt; &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">// Process the event and display a notification.</span></span><br><span class="line">    <span class="keyword">self</span>.registration.showNotification(<span class="string">"Hey!"</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'notificationclick'</span>, event =&gt; &#123;  </span><br><span class="line">  <span class="comment">// Do something with the event  </span></span><br><span class="line">  event.notification.close();  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'notificationclose'</span>, event =&gt; &#123;  </span><br><span class="line">  <span class="comment">// Do something with the event  </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="移植Hexo博客到PWA应用"><a href="#移植Hexo博客到PWA应用" class="headerlink" title="移植Hexo博客到PWA应用"></a>移植Hexo博客到PWA应用</h1><p>&emsp;&emsp;现在，我们基本了解了PWA的概念以及实现PWA的关键技术，我们现在考虑将Hexo博客改造成一个PWA应用，我们这里不打算考虑消息推送的相关问题，所以对Hexo这样一个静态博客生成器而言，我们可以做的实际上只有两件事情，即通过Web App Manifest让它更像一个Native应用，通过ServiceWorker为它提供离线缓存的特性。我们从最简单的开始，我们需要在Hexo的根目录中增加一个manifest.json文件，该文件我们可以通过这个网站 <a href="http://www.manifoldjs.com/generator" target="_blank" rel="noopener">manifoldjs.com</a> 来生成。下面给出博主博客中使用的配置：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"飞鸿踏雪的部落格"</span>,</span><br><span class="line">  <span class="attr">"short_name"</span>:<span class="string">"Payne's Blog"</span>,</span><br><span class="line">  <span class="attr">"description"</span>:<span class="string">"人生到处知何似，应似飞鸿踏雪泥"</span>,</span><br><span class="line">  <span class="attr">"icons"</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird36.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"36x36"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird48.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"48x48"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird72.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"72x72"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird96.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"96x96"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird144.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"144x144"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"src"</span>:<span class="string">"assets/images/icons/bird192.png"</span>,</span><br><span class="line">    <span class="attr">"sizes"</span>:<span class="string">"192x192"</span>,</span><br><span class="line">    <span class="attr">"type"</span>:<span class="string">"image/png"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">"background_color"</span>:<span class="string">"#fff"</span>,</span><br><span class="line">  <span class="attr">"theme_color"</span>:<span class="string">"#000"</span>,</span><br><span class="line">  <span class="attr">"start_url"</span>:<span class="string">"/"</span>,</span><br><span class="line">  <span class="attr">"display"</span>:<span class="string">"standalone"</span>,</span><br><span class="line">  <span class="attr">"orientation"</span>:<span class="string">"portrait"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;好了，现在我们来考虑如何去实现一个ServiceWorker，Google官方提供了一个ServiceWorker的<a href="https://github.com/GoogleChrome/samples/tree/gh-pages/service-worker/basic" target="_blank" rel="noopener">示例项目</a>，以及网友提供的<a href="https://github.com/minimal-xyz/minimal-pwa" target="_blank" rel="noopener">Minimal-PWA</a>，这两个项目都可以帮助我们去了解，如何去实现一个ServiceWorker，甚至于我们有<a href="http://link.zhihu.com/?target=https%3A//github.com/GoogleChrome/sw-precache" target="_blank" rel="noopener">sw-toolbox</a>和<a href="http://link.zhihu.com/?target=https%3A//github.com/GoogleChrome/sw-precache" target="_blank" rel="noopener">sw-precache</a>这样的工具，配合gulp和webpack我们定制缓存策略并生成ServiceWorker。可是你要知道，懒惰对程序员而言是一种美德，在这里我选择了Hexo的插件<a href="https://github.com/JLHwung/hexo-offline" target="_blank" rel="noopener">hexo-offline</a>，该插件可以帮助我们生成ServiceWoker，关于它的使用及配置，大家可以自行去了解，我重点想说说支持ServiceWorker以后，我的博客所呈现出来的变化以及PWA实际运行的效果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171119125504778" alt="ServiceWorker和Cache Storage" title="">                </div>                <div class="image-caption">ServiceWorker和Cache Storage</div>            </figure><p>&emsp;&emsp;通过这张图，我们可以清楚地看到，ServiceWorker确实在后台工作着，而Cache Storage确实对博客内的静态资源做了缓存处理。事实上对Hexo这样的静态博客而言，整个博客都是静态资源，所以在实际运行中它会对所有内容进行缓存，我们可以在终端中验证这个想法：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171119130811446" alt="在Hexo中监听到的缓存请求" title="">                </div>                <div class="image-caption">在Hexo中监听到的缓存请求</div>            </figure><p>&emsp;&emsp;可我想说这一切并没有什么用，因为我并不能如愿地在离线状态下访问我的博客，甚至因为有了缓存机制，当我在撰写这篇博客时，虽然我改变了markdown文档的内容，但当我刷新博客的时候，因为缓存机制的存在，我不能像从前那样直接看到博客的变化，更重要的一点是，整个缓存大概有8M左右的体积，因此每次请求页面时，我能够明显地感觉到页面加载的延迟，看起来我们费了大量周折最终却一无所获，这听起来实在是讽刺不是吗？</p><p>&emsp;&emsp;说完了ServiceWorker，我们再来说说Web App Manifest，我尝试从豌豆荚下载了移动版Chrome，可我自始至终无法将应用添加到主屏幕，貌似这需要Android系统底层的支持，我测试了两部手机，一部OPPO手机和一部小米手机，发现都没有明显的PWA支持，当我访问页面的时候，浏览器更加不会主动提示我”将应用添加到主屏”，像UC浏览器是将网站以应用的形式添加到浏览器首页，这的确没有什么值得令人惊喜的地方，因为在PC端的时候，我们就可以做到类似地实现，这篇文章耗费时间蛮长的啦，大概是因为我不知道，该如何描述这个失败的尝试。最近接触到一位前辈的项目，这是一个需要跨PC端和移动端的项目。目前面临的一个挑战就是，移动端有太多依赖原生接口的功能设计，所以一套代码在全平台适配，真的仅仅是一个美好的理想，离实现永远有一段不可逾越的距离。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文主要以Google提出的渐进式Web应用(Progressive Web Apps)为主线，简单探讨了Google的渐进式Web应用及其关键技术。渐进式Web应用试图解决传统Web应用的两个关键问题，即<strong>需要从网络实时加载内容而带来的网络延迟</strong>和<strong>依赖浏览器入口而带来的用户体验</strong>。首先，渐进式应用可以显著加快应用加载速度，其提供的离线缓存机制可以让应用在离线环境下继续使用，关键技术为Service Worker和Cache Storage；其次，渐进式应用可以被添加到主屏，有独立的图标、启动页、全屏支持，整体上更像Native App，关键技术为Web.App Manifest；最后，渐进式应用同操作系统集成能力得到提高，具备在不唤醒状态下推送消息的能力，关键技术为Push API和Notification API。在此背景下，我们对静态博客Hexo进行了改造，尝试将其迁移到一个PWA应用上，虽然最终以失败告终，可是在整个过程中我们依然有所收获，我觉得一件事情能让我们有所思考或者有所感悟的话，这就已然是一种幸运、一种成功啦。</p><p>&emsp;&emsp;其实Web应用与原生应用并非彼此水火不容，除了纯粹的Web技术和Native技术以外，在这两者之间我们看到的更多是混合技术的应用，所以我认为开发人员在未来一定要具备两种能力，即跨语言和跨平台开发的能力。比如小程序是在微信原生生态下建立的定制化Web应用，它有着类似HTML/CSS/JavaScript的技术方案，同时提供了统一的应用程序外观和使用体验；而跨平台游戏引擎cocos2d-x，通过JavaScript Bridge等类似技术，则可以实现将Web技术转化为Native技术…..总而言之，在技术选型这个问题上，我们可以选择的方案越来越多，如何让想法可以伴随技术产生优秀的产品，这是我们在这个时代真正该去思考的问题。目前来讲，国内普遍重视iOS，可惜遗憾的是iOS不支持PWA；国内的Android系统经过阉割以后，国内用户无法使用Chrome，以及各个厂商定制的浏览器存在兼容性问题；国内因为政策及现实原因，第三方推送相对GCM推送要活跃很多，厂商并不会太关注对PWA应用推送的支持。虽然现实如此，可Web技术发展到今天为止，我们能做的就是希望它越来越好，在此引用<a href="https://huangxuan.me" target="_blank" rel="noopener">黄玄</a>的一句话：</p><blockquote><p>我们信仰 Web，不仅仅在于软件、软件平台与单纯的技术，还在于『任何人，在任何时间任何地点，都可以在万维网上发布任何信息，并被世界上的任何一个人所访问到。』而这才是 web 的最为革命之处，堪称我们人类，作为一个物种的一次进化。」</p></blockquote><hr><ul><li><a href="http://harttle.com/2017/01/28/pwa-explore.html" target="_blank" rel="noopener">PWA 初探：基本特性与标准现状</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service Worker API</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API/Using_the_Push_API" target="_blank" rel="noopener">Using the Push API</a></li><li><a href="http://web.jobbole.com/84792/" target="_blank" rel="noopener">Service Worker初体验</a></li><li><a href="https://zhuanlan.zhihu.com/p/25524382" target="_blank" rel="noopener">PWA 入门: 理解和创建 Service Worker 脚本</a></li><li><a href="https://zhuanlan.zhihu.com/p/25459319" target="_blank" rel="noopener">PWA 入门: 写个非常简单的 PWA 页面</a></li><li><a href="http://huangxuan.me/2017/02/09/nextgen-web-pwa/" target="_blank" rel="noopener">下一代 Web 应用模型 —— Progressive Web App</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;如果说通过TravisCI实现博客的自动化部署，是持续集成这个概念在工作以外的一种延伸，那么今天这篇文章想要和大家分享的，则是我自身寻求技术转型和突破的一种挣扎。前段时间Paul同我聊到Web技术的发展趋势，Paul认为Web应用会逐渐取代原生应用成
      
    
    </summary>
    
      <category term="独立博客" scheme="http://qinyuanpei.github.io/categories/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://qinyuanpei.github.io/tags/Hexo/"/>
    
      <category term="Web" scheme="http://qinyuanpei.github.io/tags/Web/"/>
    
      <category term="PWA" scheme="http://qinyuanpei.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>持续集成在Hexo自动化部署上的实践</title>
    <link href="http://qinyuanpei.github.io/posts/3521618732/"/>
    <id>http://qinyuanpei.github.io/posts/3521618732/</id>
    <published>2017-10-21T22:57:55.000Z</published>
    <updated>2018-03-01T01:38:10.362Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;曾经听到过这样一句话，”不要用战术上的勤奋掩盖战略上的懒惰”，所以战术和战略更像是抽象类和具体类，而面向对象设计实际上是现实等级制度的一种映射。因此我们注意到，决策者通常关注的是战略层面的抽象概念，而执行者通常更关注战术层面的具体实现，正如在代码的架构设计中，处在顶层的代码以发送指令为主要使命，处在底层的代码以实现功能为主要使命。面对日新月异的互联网技术，当我们听到越来越多的新名词，譬如微服务、DevOps、单页面应用、前后端分离等等，这些概念曾让我们迷恋于追寻一个又一个风口，一如曾经的O2O、VR、共享经济和人工智能，那么我们真的懂得如何让这些概念落地吗？在今天这篇文章中，我想和大家一起探讨持续集成相关的话题，并以Hexo结合TravisCI实现自动化部署为例，聊聊我心目中的DevOps。</p><h1 id="从DevOps谈谈持续集成"><a href="#从DevOps谈谈持续集成" class="headerlink" title="从DevOps谈谈持续集成"></a>从DevOps谈谈持续集成</h1><p>&emsp;&emsp;不知从何时起，DevOps开始成为大家竞相追捧的概念，同ThoughtWorks所倡导的微服务、敏捷开发一样，大家仿佛抓住了一根新的救命稻草一般，那么我们在说DevOps的时候，我们到底想要表达什么观点呢？想要搞清楚这个问题，我认为首先要明白，什么是DevOps？从概念上讲，DevOps是一个面向IT运维的工具流，以IT自动化以及持续集成(CI)、持续部署(CD)为基础，目的是优化开发、测试、运维等所有环节，所以DevOps本质上是一组部门间沟通协作的流程和方法，其目的是为了协调开发(DEV)、测试(QA)、运维(OPS)这三种角色，使开发运维一体化，通过高度自动化工具和流程，来确保软件构建、测试和发布更加快捷、频繁和稳定。</p><p>&emsp;&emsp;所以，我们在说DevOps的时候，我们想表达的或许是流程和管理、运维和自动化、架构和服务、文化和组织等等的概念，那么在这些观点中，最重要的是什么呢？我认为是持续集成(CI)和持续部署(CD)，这是DevOps中从始至终贯穿的一条主线。通过Git这样的源代码控制工具，我们可以确保项目在一条主干上开发。而自动化测试/部署等周边工具，则为我们提供了实施持续集成/持续部署的必要条件。从公司角度出发，公司普遍更看重项目的交付能力，所以在传统持续集成/部署的基础上，我们时常会听到持续交付这样的声音，这时我们就会意识到，DevOps实则是持续集成思想的一种延伸，它并不是一个新的概念，事实上我们这个行业，每年都喜欢这种“旧酒换新瓶”的做法，持续集成/部署/交付是DevOps的核心技术，如果没有自动化测试和自动化部署，DevOps就是难以落地的空中楼阁。</p><p>&emsp;&emsp;由此，我们就引出今天这篇文章的主题，即持续集成。我们提到，DevOps是是一套面向IT的跨部门协作的工作流，它是持续集成思想的一种延伸，所以持续集成首先是一组工具链的集合。从某种意义上来讲，决策者喜欢DevOps，并不是真正喜欢DevOps，而是形式上的DevOps非常容易实现，因为有形的工具资源的整合是非常容易的，真正困难的是无形的流程资源的整合。你可以让两个陌生人在一起假装情侣，但你永远不可能真正拉近两个人心间的距离。通常而言，我们会用到下列工具：</p><ul><li>版本控制和协作开发：Github、GitLab、BitBucket、Coding等。</li><li>自动化构建和测试：Apache Ant、Maven、Selenium、QUnit、NUnit、XUnit、MSBuild等。</li><li>持续集成和交付：Jenkins、TravisCI、Flow.CI等。</li><li>容器/服务部署：Docker、AWS、阿里云等。</li></ul><p>&emsp;&emsp;从术和道的角度来看待持续集成，我们会发现在术的层面上，我们有非常多的选择空间，所以接下来我们主要从道的层面，来说说持续集成的核心思想。我们提到在实践DevOps的时候，需要有一条项目主干，那么持续集成的基本概念，就是指频繁地提交代码到主干分支，这样做的目的是，保证问题被及时发现以及避免分支大幅度偏离主干。</p><p>&emsp;&emsp;在使用Git的场景下来看待持续集成，及时提交代码到主分支，可以避免因为分支改动过大而带来的冲突问题。按照敏捷开发的理论，每个feature通过迭代开发来集成到最终产品中，那么持续集成的目的，就是为了让产品可以在快速迭代的同时保证产品质量。在这里产品质量有两层含义，第一，本次feature提交通过测试；第二，本次feature提交无副作用。我们可以注意到，持续集成的第一个目的，即保证问题被及时发现，对应前者；持续集成的第二个目的，即避免分支大幅度偏离主干，对应后者。</p><p>&emsp;&emsp;所谓持续集成，是指代码在集成到主干前，必须要通过自动化测试，只要有一个测试用例失败，就不能集成到主干，所以持续集成和自动化测试天生就是紧密联系在一起的。我们不能只看到持续集成/部署/交付，如果连流程上的自动化都无法实现，这些都是无从谈起的，从开发者的角度来看，理想的状态是编译即部署，我们提交的每一行代码，都是可以集成、交付和部署的代码，所以实际上是对开发者的代码质量提高了要求。所有我们觉得美好的事情，其实核心都在于人如何去运作，想到一位前辈说过的话，“软件开发没有银弹”，所有试图通过某种方法论解决软件工程复杂性的想法，都是天真而幼稚的。</p><h1 id="Jenkins持续集成落地实践"><a href="#Jenkins持续集成落地实践" class="headerlink" title="Jenkins持续集成落地实践"></a>Jenkins持续集成落地实践</h1><p>&emsp;&emsp;博主曾经在公司项目上实践过持续集成，深感持续集成想要真正在团队里落地，受到太多太多的因素制约。我们采取的方案是，使用Git/Github作为源代码版本控制工具，使用Jenkins作为持续集成工具，使用MSBuild作为项目构建工具，使用MSTest/NUnit作为单元测试框架，使用Selenium/UI Automation作为UI自动化测试框架，这些工具可以很好地同Jenkins整合起来。在持续集成工具的选择上，我们并没有太多的选择空间，因为公司需要同时支持Java和JavaScript/Nodejs项目的持续集成，在持续集成落地这件事情上，我们最终选择了妥协，我们不再追求自动化部署，而是选择通过这个过程来快速定位问题，具体原因我们下面来讲。</p><p>&emsp;&emsp;首先，我们期望的是开发者在提交代码以后，可以触发编译、构建、测试和部署等一系列操作，我们会通过Git从远程仓库拉取最新代码，然后通过MSBuild来编译整个代码，由于MSBuild提供了定制化的脚本，可以对编译、测试和部署等环节进行精准控制，所以我们在Jenkins上触发的实际上是一系列动作，而这些都是可以在Jenkins上进行配置的，我们通常会将Jenkins上的日志以邮件形式发送给开发者，所以在很长一段时间里，每天到公司第一件事情，就是查看邮箱里的邮件，一旦发现有测试用例没有通过测试，我们就需要重复“修改代码“-&gt;“提交代码“这个过程，直至所有用例都完全通过测试，理论上通过测试的代码就可以直接部署上线，因为MSBuild可以帮助我们生成最终文件，我们只需要将其打包然后上传到服务器即可，可是实际上这是我们假想的一种场景而已，因为现实场景中我们考虑得通常会更多。</p><p>&emsp;&emsp;一个关键的问题是，我们没有可以量化的标准去评估，本次提交是否可以集成到主干。我知道你一定会说测试，事实是开发者不喜欢写测试，或者是写了不可测的测试，前一种观点认为写测试会占用开发时间，所以在开发时间相对紧张的时候，这就变成了我们不写测试的借口；后一种观点则是不会写可测试代码的表现，典型的表现是代码耦合度高、依赖大量无法Mock的对象实例、不会合理使用断言，所以在这种情况下，持续集成是没有意义的，我们不知道何时代码可以集成、交付和部署。我承认自动化测试无法全面替代人工测试，但当我们的关注点放在交付和部署上的时候，是否应该考虑先让持续集成落地，这实在是比DevOps更基础、更接地气，因为我相信持续集成是一种思想，它对开发团队中的每一个人都提出了更高的要求，持续集成是为了在保证产品质量的同时快速迭代，如果你心中没有产品质量的概念，DevOps并不能帮你提高产品质量。</p><p>&emsp;&emsp;第二个关键的问题是，开发和运维该如何去协作，DevOps是为了促进部门间沟通协作而提出的一套工作流，自动化是这套机制能够良好运行下去的前提，可是在现实场景中一切并没有那么理想。以我们公司为例，开发组和运维组分属两个不同的部门，运维组在上线、部署等关键环节设置了严格的审批流程，即运维组牢牢地控制着线上生产环境，所以即使我们通过MSBuild在Jenkins上为程序打好了包，我们依然需要按照运维组的要求，提交上线请求、人工上传程序以及等待部门审批，通常我们上线只有等到每周五，而上线流程所需的东西，我们需要在一周前准备好，所以你可以注意到一个现象，虽然在流程上开发团队和运维团队是结合在一起的，但实际上两者的工作目标依然是分离的。那是不是将两个团队放在一起工作，就能解决这个问题呢？我想合作的前提是相互理解和信任，如果彼此都不愿意去了解对方的工作流程，DevOps可能仅仅是我们用工具堆积出来的虚幻感。</p><h1 id="实现Hexo博客的自动化部署"><a href="#实现Hexo博客的自动化部署" class="headerlink" title="实现Hexo博客的自动化部署"></a>实现Hexo博客的自动化部署</h1><p>&emsp;&emsp;好了，在公司使用Jenkins实践持续集成，在现实场景中总会受到各种各样的制约，这并不是因为持续集成这个想法不好，而是在现实面前我们都选择了妥协。有句话说，“如果没有见过光明，我本可忍受黑暗”，我们喜欢一个人或者是一样东西，都是因为我们觉得它是美好的，可以让我们觉得这个世界温暖，那么在公司以外的地方，我想更加自由地做些我喜欢的事情。在公司实践持续集成的时候，因为公司对权限的严格控制，我难以实现那种想象中的持续集成，即在成功地在提交代码以后直接触发编译和部署，我想在公司之外做成这件事情。</p><p>&emsp;&emsp;为什么想到要给博客做持续集成呢？首先，持续集成和单元测试联系紧密，我自认为我的单元测试刚刚入门，为了写出更好的单元测试，我必须要这样做，来强迫自己努力去写好单元测试；其次，持续集成可以将开发和部署分离，所以我在任何一台计算机上撰写博客，都可以通过TravisCI实现编译和部署，对Hexo这种静态博客而言，部署其实就是推送页面到Github而已，整体难度并没有太高。最后，我平时更新博客都是手动推送页面，因为我不喜欢用Hexo提供的部署功能，现在我想让自己专注在内容写作上，而一切都可以在我的控制范围内。这正是我所想，如果能让一切更好一点，我都愿意去尝试和努力。</p><p>&emsp;&emsp;关于Hexo这类静态博客生成器搭建博客的原理，我这里不想在赘述，因为我愿意相信，懂得搭建博客的人，一定是了解Git、Github Pages和Markdown等等的概念的，关于配置相关的细节大家可以参考官网。这里想着重介绍下TravisCI，TravisCI是一个在线的、分布式的持续集成服务，可以用来构建和测试托管在Github上的代码，并且其本身就是开源的。TravisCI提供了主流编程语言如C#、Java、JavaScript、Ruby、PHP、Node.js等的支持，相比Jenkins而言，它是一个轻量级的持续集成平台，它会在每次提交代码后，根据配置文件来创建一个虚拟机，并执行用户定义的Build任务，这个虚拟机提供版本控制(<strong>Git</strong>)、项目构建(<strong>Node.js</strong>)等，在此前提下，我们下面着手Hexo的自动化部署。</p><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>&emsp;&emsp;Hexo博客实际上可以分成两部分，即博客源代码和静态页面。其中博客源代码主要是指Hexo及其相关模块、博客内容(<strong>source</strong>)、博客主题(<strong>theme</strong>)，而静态页面由Hexo动态生成，通常放置在<strong>public</strong>目录中。对Hexo来讲，我们最终部署需要的是这些静态页面，所以我们设计得一个方案是，将静态页面存放在master分支，将博客源代码存放在blog分支。当用户提交代码到blog分支后，会触发TravisCI中定义的一系列操作，它会首先从blog分支拉取博客源代码，然后在TravisCI中完成静态页面的生成，最后将其提交到master分支以完成博客的更新，整个过程非常优雅，终于让我彻底摆脱了手动更新博客的过去，而更重要的是，从此写博客不再受地点的制约，因为写博客就是提交代码，生成静态页面以及部署到Github Pages，现在全部交给了TravisCI.</p><h2 id="配置TravisCI"><a href="#配置TravisCI" class="headerlink" title="配置TravisCI"></a>配置TravisCI</h2><p>&emsp;&emsp;TravisCI是一个轻量级的持续集成方案，其轻量级主要体现在它的配置文件，即使用TravisCI并不需要我们安装任何软件，我们仅仅需要提供一个.travis.yml文件即可，该文件通常被放置在项目根目录里。和Jenkins这样的持续集成工具不同，我们在这个文件中即可定制Build任务，下面给出一个基本的配置文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">language</span>: node_js</span><br><span class="line"><span class="attribute">node_js</span>: stable</span><br><span class="line"></span><br><span class="line"># S: Build Lifecycle</span><br><span class="line"><span class="attribute">install:</span></span><br><span class="line">  - npm install</span><br><span class="line"></span><br><span class="line"><span class="attribute">script:</span></span><br><span class="line">  - hexo clean</span><br><span class="line">  - hexo generate</span><br><span class="line"></span><br><span class="line"><span class="attribute">after_script:</span></span><br><span class="line">  - cd ./public</span><br><span class="line">  - git init</span><br><span class="line">  - git config user.name "qinyuanpei"</span><br><span class="line">  - git config user.email "qinyuanpei@163.com"</span><br><span class="line">  - git add .</span><br><span class="line">  - git commit -m "Update Blog"</span><br><span class="line">  - git push --force --quiet "https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;" master:master</span><br><span class="line"># E: Build LifeCycle</span><br><span class="line"></span><br><span class="line"><span class="attribute">branches:</span></span><br><span class="line">  only:</span><br><span class="line">    - blog</span><br><span class="line">    </span><br><span class="line"><span class="attribute">env:</span></span><br><span class="line"> global:</span><br><span class="line">   - GH_REF: github.com/qinyuanpei/qinyuanpei.github.io</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果大家熟悉Jenkins的使用，就会发现这里定义的Build任务似曾相识。在这里我们首先指定了项目构建语言，即这是一个node.js的项目，然后我们会通过npm安装所有依赖，我们注意到在根目录里有一个package.json文件，该文件定义了整个项目依赖的项目。如果你使用过Nuget，你会发现这一切都是如此的合理。那么当整个环境准备就绪以后，我们就可以着手博客的构建啦，和平时一样，我们会执行hexo clean和hexo generate命令，这样Hexo会帮助我们生成所有的静态页面，现在我们通过Git将其推送到master分支，通常基于Github Pages托管的页面都是存放在gh-pages分支的，可是对Hexo而言，我们放在master分支是没有问题的，这就是TravisCI构建整个博客的具体过程。</p><h2 id="关联TravisCI"><a href="#关联TravisCI" class="headerlink" title="关联TravisCI"></a>关联TravisCI</h2><p>&emsp;&emsp;到目前为止，我们定义好了TravisCI将会在虚拟机中执行的Build任务。我们知道，这里TravisCI是需要访问我们托管在Github上的代码仓库的，所以我们必须将这个代码仓库和Travis关联起来，这样它就具备了从代码仓库拉取代码(<strong>Pull</strong>)和向代码仓库推送(<strong>Push</strong>)代码的能力。印象中公司是给每一个Jenkins服务器关联了一个Github账户，这样需要持续集成的项目只需要添加这个账号，并为其赋予基本的读写权限即可。在这里是类似的，我们有两种方案来关联TravisCI，即为TravisCI虚拟机添加SSH-Key和使用Github提供的Personal Access Token。</p><p>&emsp;&emsp;前者和我们平时使用Git时配置SSH-Key是一样的，但考虑到公开密钥产生的安全性问题，TravisCI建议我们使用官方的一个工具来对密钥进行加密，这是一个基于Ruby开发的命令行工具，加密后的内容可以在TravisCI中解密，这种方案需要安装Ruby，博主选择放弃。如果你要问我为什么放弃Ruby，大概是因为我忘不了曾经被Jekyll支配的恐惧感。而后者的原理是将Github生成的Token作为一个环境变量存储在TravisCI中，我们在定义TravisCI中的Build任务时可以引用这些环境变量，我们只需要在执行Git命令时带上这个Token就可以了。显然这种方式更合我的胃口，它的缺点是对此Github采用了粗放式的权限控制，即这个Token时可以访问所有代码仓库的，这一点大家自己可以根据自身情况来决定要使用哪一种方式。</p><p>&emsp;&emsp;我们在Github中的Setting-&gt;Developer Settings找到Personal Access Token，然后选择所有repo相关的权限，生成这个token后将其复制下来备用，因为它只有在这个地方是可见的。接下来我们打开<a href="https://www.travis-ci.org" target="_blank" rel="noopener">TravisCI</a>，在使用Github登录后我们就可以在这里看到所有的项目，如图是我个人的TravisCI界面：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171028234101618" alt="TravisCI主界面" title="">                </div>                <div class="image-caption">TravisCI主界面</div>            </figure><p>大家可以注意到，这里我开启了qinyuanpei.github.io这个仓库的持续集成服务，如果大家没有在这里看到项目列表，可以点击”Sync account”按钮进行同步。好了，现在我们继续配置：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171028234224795" alt="配置TravisCI" title="">                </div>                <div class="image-caption">配置TravisCI</div>            </figure><p>在这里我们配置了名为CI_TOKEN的环境变量，该值对应.travis.yml文件中的${CI_TOKEN}。现在我们在本地提交代码到blog分支，就会触发TravisCI执行Build任务，在这里Build任务是从blog分支拉取博客内容及主题，通过npm安装依赖的nodejs模块，最终Hexo生成的静态页面会被推送到master分支，这样就完成了整个自动化构建的流程。下面是TravisCI执行Build过程中的日志界面：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20171029001105352" alt="TravisCI日志" title="">                </div>                <div class="image-caption">TravisCI日志</div>            </figure><p>&emsp;&emsp;从计划写这样一篇文章，到我一边写博客一篇将它发布在网络上，前后花了大概我3天左右的时间。这段时间发生了太多太多的事情，所以写东西受难免受到情绪影响，你现在看到这篇由TravisCI自动生成的博客，大概无法想象屏幕前的我有着怎样复杂的心绪，有时候我告诉自己要沉下心来学点什么，有时候我会觉得此时的我和过去没有什么区别。转眼间忙忙碌碌一年到头，可会想起来顿时觉得时间像虚度一般，有人说，当你对未来不再有什么期许的时候，就是你开始衰老的迹象，可我真的老了吗？我不是只有25岁吗？好啦，夜深人静，该去睡觉了，这篇文章就是这样子啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;曾经听到过这样一句话，”不要用战术上的勤奋掩盖战略上的懒惰”，所以战术和战略更像是抽象类和具体类，而面向对象设计实际上是现实等级制度的一种映射。因此我们注意到，决策者通常关注的是战略层面的抽象概念，而执行者通常更关注战术层面的具体实现，正如在代码的架
      
    
    </summary>
    
      <category term="开发工具" scheme="http://qinyuanpei.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Hexo" scheme="http://qinyuanpei.github.io/tags/Hexo/"/>
    
      <category term="CI" scheme="http://qinyuanpei.github.io/tags/CI/"/>
    
      <category term="Travis" scheme="http://qinyuanpei.github.io/tags/Travis/"/>
    
  </entry>
  
  <entry>
    <title>不如归去</title>
    <link href="http://qinyuanpei.github.io/posts/720539850/"/>
    <id>http://qinyuanpei.github.io/posts/720539850/</id>
    <published>2017-10-21T22:31:48.000Z</published>
    <updated>2018-03-01T01:38:10.354Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;独自一个人在火车上望着窗外出神，而这种情景我再熟悉不过，或许风景会因为季节而不同，或许时间会因为年龄而不同，但对我而言，这个过程熟悉得就像一个我讲了无数遍的故事，从开篇布局到故事脉络都清楚到严丝合缝。印象中是从初中时候就开始寄宿生活，所以这种漂泊的感觉成为我生命里重要的烙印，而从那一刻起，我最期待的是寒暑假期，因为这象征着一段漂泊旅程的结束。大概是因为双子座属于风象星系，所以每次回家的旅程都伴随着忧愁风雨，我喜欢将这个过程理解为，生命不经意的装点。风有质而无形，或飞沙走石，或拈花弄叶；雨有质而无形，或坠散成珠，或凝聚成流。大概都是在世间漂泊的浪子，每一刻都摇曳不定。</p><p>&emsp;&emsp;有人说，放假回家是学生时代做的事情，因为那时我们还没有脱离父母的庇护。可当我工作了以后，当我同他们的距离不再是学校和家的距离，当我同他们打电话不再是因为生活费告拮，我忽然发现我同他们交换了这场漂泊里的角色，从前是我期待着假期，因为我可以见到他们；现在则是他们期待着假期，因为他们可以见到我。我忽然发现我一年中我陪他们的日子屈指可数，从前向往远方觉得在那里能找到我的梦，现在越发地觉得他们一天天老去，想努力长大成熟，让他们能够放心，可更怕因为距离而疏远了他们，古人说『树欲静而风不止，子欲养而亲不待』，这个世界固然不再是古人所认识的世界，这种感情却超越了时间和空间轮回至今。</p><p>&emsp;&emsp;国庆本来打算不回家的，因为即使无人可约无人可陪，我一个人同样可以给自己放假。我从来都是这样，如果有人愿意陪我做一件事情，我会很乐意接纳这番好意，并尝试用最好的状态去让彼此享受这个过程。如果没有人愿意陪伴我做一件事情，我不会勉强更不会因此而沮丧，因为当你习惯了一个人去面对所有事情，你会发现你从来不缺乏做一件事情的动力。可当家里人问我国庆要不要回家的时候，我突然心软得像融化了的雪，我意识到是我心底涌出的一股暖流，快速地打开微信买回家的火车票，结果发现15号的时候票就没有了，妈妈发微信给我说，『如果实在买不到火车票，就买机票回来吧，不用太心疼钱，人回来了就好』。</p><p>&emsp;&emsp;我记得以前他们都不大会用这类IM产品的，但现在他们学会了怎么发消息发朋友圈。记得过年的时候，我教妈妈怎么样发红包，虽然只有三块钱这样来回发着玩，但她玩得比我都开心，或许父母就是这样，曾经青春期叛逆时觉得他们的世界和自己格格不入，等他们老去的时候依然在努力着融入我们的世界。小时候他们紧紧追逐着我们，是怕我们在成长路上摔倒；长大了他们依然紧紧追逐着我们，是怕我们的世界里没有了他们。可他们在一天天地老去，如果有一天他们追不动了，我们是否愿意停下来等等他们呢？窗外的若明若暗的，像极了我往常回家路上数过的每一盏灯，可是我最喜欢的那一盏，是来自那个叫做家的地方，它或许并不璀璨耀眼，但向来不吝于为你释放光和热，永远为你指示着家的方向。</p><p>&emsp;&emsp;早上去北客站取票坐车，就接到朋友从中卫打来的电话，询问我国庆是不是要回家，这种感觉就像家里人一直记挂着你。我经常会想起高中时候，有时同朋友出去玩到很晚回家，常常会到朋友家里借宿，两个人寝则同床食则同桌，到今天我们依然是特别特别好的朋友。我幸运的是一直被朋友这样照顾着，即使我们两个在毕业后天各一方，我这个人不大懂得经营感情，被这样的朋友一直照顾着，我该是有多幸运啊。因为没有买到直达的车票，所以坐动车到兰州去转车，然后遭遇了人生中第一次火车晚点。火车晚点近三个小时，第一次迫切地感觉离家好远好远，每次回家都是披星戴月，或者在夜深人静时，或者在曙光初现时，让家人和朋友等我，我总是过意不去的。大概他们都太了解我，知道我会永远都是这副『长不大』的样子，可我总要长大成熟啊！</p><p>&emsp;&emsp;我记得以前还在父母身边时，我脑子里想的是『父母在，不远游，游必有方』，我一位同学曾问我，何谓有方，当时的我真的是不知道该怎么样回答。后来，一个人去西安发展，终于明白，以前公司里一个女生所说的，在哪里都一样。想到父母孤零零地待在家里，想到每年屈指可数的回家次数，曾几何时，我们想去更广阔的世界寻找诗和远方，可父母逐渐蹒跚的步履注定无法，陪伴我们去那些遥远的地方。诗经里说『青青子衿，悠悠我心，纵我不往，子宁不来』，如果他们不能再紧紧追随我们的步伐，我们为什么不停下甚至转身回去去看望他们呢？以前和我徒弟聊天，她说男生都不大喜欢和家里人联络，我本来就是沉默寡言的性格，从初中时候就不主动和家里人联络，现在我想改变这种想法，因为我想有空就陪陪家里人。</p><p>&emsp;&emsp;我喜欢在漫长的旅途中看书，这种习惯在我有了Kindle以后变得更为明显。早上看到这样一句话，『你懂得越多，就越觉得自己像这个世界里的孤儿』，人生而孤独，父母总有一天会离开我们，但他们教会我们如何去爱这个世界，我希望我可以用他们教会我的，在他们有生之年做些在他们眼里不再『孩子气』的事情，虽然在他们眼里我们永远都是孩子，我觉得真正的成熟并不是变得冷酷麻木，而是你知道这个世界有黑暗的一面，依然愿意相信那些温暖的事情。我到现在依然不喜欢听别人讲“道理”，因为我觉得人生最奇特的地方就在于，即使别人讲得这些“道理”都对，别人依然无法代替你去体验整个生活。每个人都是生活这片大海里的一朵浪花，为了不被岁月冲上荒凉寂寞的沙滩，我们唯有追逐巨浪努力生存。有那么一瞬间，我想和我喜欢的姑娘生活在一个城市里，等有空了就带上她回家陪陪父母。</p><p>&emsp;&emsp;或许有些地方有比故乡更广阔的天空，或许有些地方有比故乡更湿润的土壤，或许有些地方有比故乡更精彩的旅程，我想说的是，不论你是在追求诗和远方，还是在忍受眼前的苟且，如果你觉得累了，请停下忙碌的脚步，找找回家的路，那里永远有人在等你！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;独自一个人在火车上望着窗外出神，而这种情景我再熟悉不过，或许风景会因为季节而不同，或许时间会因为年龄而不同，但对我而言，这个过程熟悉得就像一个我讲了无数遍的故事，从开篇布局到故事脉络都清楚到严丝合缝。印象中是从初中时候就开始寄宿生活，所以这种漂泊的感
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="成长" scheme="http://qinyuanpei.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="回家" scheme="http://qinyuanpei.github.io/tags/%E5%9B%9E%E5%AE%B6/"/>
    
      <category term="亲情" scheme="http://qinyuanpei.github.io/tags/%E4%BA%B2%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>秋风劲似去年时</title>
    <link href="http://qinyuanpei.github.io/posts/2617501472/"/>
    <id>http://qinyuanpei.github.io/posts/2617501472/</id>
    <published>2017-09-25T00:56:50.000Z</published>
    <updated>2018-03-01T01:38:10.362Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;连续数日的秋雨绵绵，依然固执地不肯转身离开，而之所以选择在国庆节前徘徊，或许是为了让离开家的人，多些同江湖风雨漂泊的味道。印象中这样的日子常常是相似的，譬如穿行在骤雨中被来往车辆溅得一身水，或者行走在上班的路上抬头看见第一场雪，或者是倚靠在公交车窗边上看风景转眼即逝，这些再熟悉不过的场景对我熟悉而又陌生，我惊异于记忆常常像盗梦空间般重叠，我感概于时间常常像钟表指针般流连。我不知道这个世界上是不是有平行世界，但我知道我再回不去曾经某一个时刻，我一直想写下这段时间的状态，可当我准备下笔时才发现，它需要我努力想好多事情，我依然还是曾经的我，风景依稀还是曾经的风景，到底是谁在一直变化呢？</p><p>&emsp;&emsp;我不知道要从什么时候回忆这些事情，这种感觉就像是你期待了许久之后，在触碰到她的那一刻都不复存在了。我曾经答应过一个人要去看望她，如果你读过《一个人的朝圣》这本书，或许就会明白这是一种怎么样的执念，即使在明明知道一切再无法挽回的时候，这种执念还是让我想要达成这个愿望。我一直不知道两个人怎么就自然而然地在一起了，那种感觉如果一定要用语言来形容，我觉得是一种熟悉到灵魂里的默契。你想要牵着她的手的时候，她假装挣扎下后就一直让你牵着，那种娇羞中透着可爱的神情，在四目相对的时候眼睛里都是闪着光的。我忘不了在人潮中牵着她的手穿过整条街市，我忘不了抱着她的时候街市两边灯笼通红。有时候觉得人生充满了遗憾，好像错过她花光了我这辈子的好运气，从那以后我总是重复着昨天的故事。</p><p>&emsp;&emsp;其实我自己都不清楚，我到底喜欢什么样的女孩子，甚至有时候我喜欢的是，我心中她最美好的样子。一个人少不经事的时候，大概会喜欢对女孩子说甜言蜜语，可当他经历过失去以后，他变得不再轻易许诺，这就好像我小时候是一个特别喜欢说话的人，在经历过因为紧张而变得口吃以后，我终于变成了今天这副沉默寡言的样子。有时候会陡然间觉得自己并没有怎么变，或许是因为她说过她喜欢我这个样子，所以我就固执地不肯改变，因为我怕有一天她回来的时候认不出我来，即使这是我脑补的一个剧情。曾经看过一个电影《这个男人来自地球》，当我们熟知的宗教历史变成一个人的回忆，这种超越哲学意义上的时间我认为是荒凉的。曾经的小伙伴Alex、Sandy、Kent、Andy、Kent、Kavin和Joe都渐行渐远，到底是我停留在原地还是我超越了时间？</p><p>&emsp;&emsp;不知道该怎么样描述这种感觉，或许我就是一个不擅长联络感情的人，生命中有太多太多东西，我眼睁睁看它离我远去而又无可奈何，想要安慰我的人总是劝我同昨天告别。但像我这样太看重感情的人，无论外表多么风平浪静，内心永远不肯残忍地删除回忆。所以，我记得Jackson、Lynn、Candy他们陪我度过的二十五岁生日，我记得Candy问我当时暗自许了什么样的愿望，坦白来讲，我没有想着脱单这样离我很遥远的愿望，我只想时间能够永远定格在那一刻，大家都可以开开心心地直到永远。你一定觉得我幼稚或者是不成熟啦，我问过人家要怎么样变得成熟，人家说你去找一个女朋友就好啦，然后就会在喜欢的人面前紧张甚至自卑，我曾一度很讨厌下雨天，因为我怕两个人遇到一起，我既没有伞亦没有外套。</p><p>&emsp;&emsp;二十五岁的我，喜欢一个人还是和从前一样无所顾忌，我还是学不会那些复杂的套路，不喜欢单方面付出，不喜欢卑微地爱一个人，每一次都会因为喜欢某个女孩子而尝试改变，想和她站在一起的时候不会被她的光芒完全覆盖，想和她待在一块的时候不让她觉得我这个人枯燥，想和她抱在一起的时候给她讲我从书里看到的某个故事……我一直在想，如果我们的感情不是以异地恋这种方式会不会有不一样的结局，我喜欢《星月神话》这首歌，是因为我们的确呼吸着同一片天空的气息而注定无法再相遇，就像两条相交的直线一样从陌生到熟悉再到陌生。我现在再看《嫌疑人X的献身》这部电影，我总在想，如果那天我们看的是这部电影会怎么样，此时的我比上大学时候胖了许多，大概一开始我在她心目中的样子，应该是张鲁一这样温润如玉的谦谦君子吧！生命就是这般离奇玄妙，你不能假设更无从假设应该发生什么，因为每一天都是无法重现的Case，你觉得它相似，仅仅是因为相似而已。</p><p>&emsp;&emsp;我喜欢穿裙子的女孩子，这一点完全是因为受到她的影响，虽然她一再告诉我，是我喜欢这样的女孩子，而她恰好喜欢穿裙子而已，可这些淹没在风声里的话语，谁会去盘问孰是孰非呢，如果她此刻愿意同我争论这个问题，我直接认输就好啦，我对输赢看得并不重要，这就像在工作中，没有人在意做的产品是不是好用，大家关注的是始终是它能节省多少个FTE，所以为了达到这些光鲜亮丽的指标，没有人会在意工程师的代码被改成什么样子，我们所追求的东西是否显得舍本逐末，我们所在意的东西到底是否真正发自你我的本心。以前觉得两个人在一起简单，是因为我们没有想那么多；现在觉得两个人在一起困难，是因为我们习惯性想太多。你有没有在脑海中设想过，和一个人走完一生是种什么样的体验，我想说那是一个很美好的想象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;连续数日的秋雨绵绵，依然固执地不肯转身离开，而之所以选择在国庆节前徘徊，或许是为了让离开家的人，多些同江湖风雨漂泊的味道。印象中这样的日子常常是相似的，譬如穿行在骤雨中被来往车辆溅得一身水，或者行走在上班的路上抬头看见第一场雪，或者是倚靠在公交车窗边
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="回忆" scheme="http://qinyuanpei.github.io/tags/%E5%9B%9E%E5%BF%86/"/>
    
      <category term="年华" scheme="http://qinyuanpei.github.io/tags/%E5%B9%B4%E5%8D%8E/"/>
    
  </entry>
  
  <entry>
    <title>从React专利事件看开源软件许可</title>
    <link href="http://qinyuanpei.github.io/posts/1166840790/"/>
    <id>http://qinyuanpei.github.io/posts/1166840790/</id>
    <published>2017-09-20T23:06:45.000Z</published>
    <updated>2018-03-01T01:38:10.354Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;各位朋友，我是Payne，大家好，欢迎大家关注我的博客，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。最近前端技术圈因为React专利事件再次被大家关注，印象中Angular和Vue的纷争刚刚过去不久，果然前端技术圈对”造轮子”和”搞事情”有着近乎执著的追求。作为一个在知乎吃瓜的伪前端工程师，我对这凑热闹这种事情从来都是是颇为喜欢的。如果说Angular和Vue冲突主要来自大漠穷秋和尤小尤的个人战场，那么这次React专利事件则是商业公司之间对社区主导力量的一次争夺和抗衡。开源是一种近似乌托邦般的理想社会，它倡导的”人人为我，我为人人”这种近乎大同社会的观念，在面临商业化浪潮洗礼的时候难会和商业利益发生冲突，譬如Google因为使用Java而和甲骨文纠纷不断，最终不得不选择Kotlin作为Android开发的主力语言。所以这篇文章我想和大家通过React专利事件来聊聊开源软件许可，以及我们如何在商业化和开源社区间找到一个平衡点。</p><h1 id="事件始末"><a href="#事件始末" class="headerlink" title="事件始末"></a>事件始末</h1><p>&emsp;&emsp;其实React专利事件由来已久，如果不是在知乎上看到<a href="">“百度要求内部全面停止使用React/React Native”</a>的问题，我是完全没有意识到事态居然发展到如此严重的。每次前端技术圈”搞事情”的时候，基本上都会在我的知乎首页刷屏，可是对我这样的伪前端工程师而言，我仅仅是关注了”Web开发”这个话题而已。忽略知乎首页推荐算法的缺陷，这的确动侧面说明了目前前端领域非常热门的事实，可它不能说明某些前端工程师的技术水平有多高，在引入前后端分离和前端构建工具以后，前端开发的基础设施渐渐地丰富起来了，可是前端开发目前经历着的一切，无一不在后端开发中涉及到，我没有想要成为全栈工程师的野心，在讨论这个事件以前我认为有必要了解下整个事件的始末：</p><ul><li>2016年7月，Facebook在React.js的开源许可协议中添加的附加专利条款首次在社区中引发广泛讨论。</li><li>2016年11月，Facebook发布官方问答，对附加专利条款进行了澄清，强化了其BSD许可证 + 专利许可证的概念。</li><li>2017年4月，Apache Cassandra项目正在考虑是哟过Facebook开源的数据库RocksDB作为存储引擎，可是考虑到专利授权的问题，Jeff Jirsa向Apache法律社区寻求帮助。</li><li>2017年6月，Apache 法律社区开始讨论Facebook Patents License协议专利授权的不对称问题，且该协议与Apache Software License，即Apache 2.0等不兼容。</li><li>2017年7月15日，Apache软件基金会正式发表声明称：Facebook BSD + Patense License正式被列入”Category X”列表，因此Apache项目中将不能含有或者依赖任何该协议的代码，而已发布的代码必须在8月31日前完成替换。</li><li>2007年8月19日，Facebook对Facebook BSD + Patense License有了新的解释，解释指出，专利许可证的存在是为了防御无量的专利诉讼，Facebook增加专利许可证是为了保护核心技术。</li><li>2017年9月16日，百度内部全面禁止使用React/React Native的消息在知乎上引发热烈讨论。</li><li>2017年9月17日，Wordpress官方称因为React专利问题而停止在博客程序Wordpress中使用React技术。</li><li>2017年9月23日，Facebook迫于社区压力对外宣称将在数周后将React授权许可修改为MIT。</li></ul><h1 id="主流软件许可"><a href="#主流软件许可" class="headerlink" title="主流软件许可"></a>主流软件许可</h1><p>&emsp;&emsp;其实作为一名软件工程师，这些和法律息息相关的内容，原本是不需要我们去关注的，因为即使公司在使用这些开源软件中发生法律纠纷，通常都会有法务人员协助公司去解决相关事宜，无论如何都轮不到我们这些人来关心的。不过这个事件的现实意义是，我们在做技术选型时，专利等可能引起法律纠纷的问题，一样是需要纳入考虑范围的。因为如果是个人性质或者纯玩性质的项目，我们的确无需在意太多。而如果你是商业性质项目、或者是公司自营项目，或者是服务于甲方，那么你必须考虑你使用开源软件的方式是否符合相关的软件许可。国内因为盗版软件盛行的原因，大家在心底里好像都不认同软件许可，但是像外企或者是对信息安全比较重视的企业，通常要么对许可证书比较看重，要么对开源软件不太感冒，所以像最近的WePhone创始人自杀这种事件，都在告诉我们一个道理，程序员不要整天都关注技术层面上的东西，虽然技术世界有很多纯粹而美好的事情，但当它和人类联系在一起、和政治联系在一起的时候，它就完全不在我们的控制之中了，所以我觉得我们有必要了解些法律相关的事情，那么从何处开始呢？我们不妨就来说说主流的开源软件许可吧！</p><p>&emsp;&emsp;这个世界上的开源软件许可证书大约有<a href="http://www.gnu.org/licenses/license-list.html" target="_blank" rel="noopener">上百种</a>，我们不可能也没有必要了解所有的开源软件许可证书。对于主流的开源软件许可，我们有GPL、BSD、MIT、MPL、Apache和LGPL，相信大家都没有兴趣去阅读这些晦涩深奥的License，所以我们不打算在这里逐一介绍它们，事实上搞清楚它们在具体限制上的差异是件非常困难的事情。我们希望用最简洁的语言来描述这些开源软件许可：</p><ul><li>GPL： 即GNU通用公共授权(<strong>GNU General Public License</strong>)，其出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但是不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这就是为什么我们能用免费的各种包括商业公司在内的Linux版本，以及Linux上各种各样的由个人、组织和商业软件公司开发的免费软件。</li><li>BSD： 即<strong>Berkly Software Distribution</strong>， 基本上是一个给予使用者极大自由空间的一种开源协议，使用者可以自由地对代码进行使用、修改和二次发布，该协议鼓励代码共享，其出发点是尊重代码作者的著作权，要求保留原代码中的BSD协议，保留创作者署名权利，即不得以开源软件作者/机构的名义进行市场推广。</li><li>MIT： 即<strong>Massachusetts Institute of Technology</strong>，这是一个完全给予使用者自由空间的 简短而宽泛的授权协议，作者唯一的诉求是保留版权，使用者可以复制、修改、合并、发布、分、授权和销售软件副本，并根据程序的需要适度修改授权条款，唯一的要求是必须在发行版里附加原许可协议的声明，无论是以源代码还是二进制形式发布。</li><li>MPL：即<strong>The Mozilla Public License</strong>，该协议同GPL和BSD基本一致，差异主要体现在：源代码提供者不能提供已经受到专利保护的源代码、要求再发布者必须提供对代码程序修改的说明、允许通过MPL许可获得的源代码同其他类型源代码进行混合(第二条献给那些不好好在Git里写注释的同学)。</li><li>Apache：即著名的非盈利开源组织Apache采用的协议，该协议和BSD类似，同样<strong>鼓励代码共享和尊重原作者的著作权，同样允许代码修改，作为开源或商业软件再发布</strong>，主要关注点有：（1）需要给代码的用户一份Apache License；（2）如果改动代码需要在被修改文件中做出说明；（3）衍生代码必须保留原有协议、商标、专利或者说明等；（4）不得对Apache协议进行修改。</li><li>LGPL：LGPL，即GPL V2，是GPL的一个为主要为类库使用设计的开源协议，和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(<strong>link</strong>)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码，可以被商业软件作为类库引用并发布和销售的同时，保障作者的知识产权，避免有人利用源代码复制并开发类似产品。</li></ul><p>&emsp;&emsp;好了，相信到这里大家就能够明白，为什么这次React专利事件能在社区里引起轰动。我认为主要的原因有两点：</p><p>&emsp;&emsp;第一，React在BSD协议许可的基础上增加的专利许可，对许可证书授权方和被授权方而言，存在待遇上的不对等性。实际上在React为前端带来虚拟DOM、单向数据流和不可变对象等一系列函数式编程的概念的同时，Facebook在开源社区中的话语权同样越来越大，Facebook在开源协议中夹藏私货的确让人有种”挟天子以令诸侯”的感觉，曾几何时，社区指责微软没有开放全部的OpenXML标准，因为大家都觉得按照这个标准实现的Office文档和微软家的存在差异，可是面对这种和自家产品紧密联系的项目要开源，我觉得这不单是Facebook会有所提防，恐怕所有的商业公司都会有类似的想法吧，所以在这个事件中，隐含的一个点就是，一旦当使用React的公司和Facebook发生业务上的竞争，React将成为Facebook获得诉讼胜利的一个重要筹码，因为根据React的专利协议，Facebook有权在开展诉讼时从被授权方手中收回React的使用权，所以我们不难理解为什么百度和Wordpress都宣称要停止使用React，除了不想受制于人以外，像百度这种未来可能会和Facebook在AI等领域发生竞争的公司，宁可自己造一套轮子而不愿让自家专利被对方使用的做法，我觉得是可以理解的。</p><p>&emsp;&emsp;第二，React在开源协议中附加专利许可的做法，从商业公司自我保护的角度来看，的确是无可厚非，不过这种做法未免会给开源社区带来不好的风气。我们都知道开源软件并不等同于免费软件，因为开源软件通过许可证书来保证开源软件代码是以一种合理的方式被使用。在很久很久以前，MySQL是我非常喜欢的一个数据库，因为它可以让我摆脱SQLServer臃肿的体积。什么？你说.NET技术体系中怎么会出现MySQL？可这正是.NET选择开源、选择了跨平台，我们才有机会在更广阔的世界里去做些有趣的事情不是吗，我们必须承认开源对这个世界的重要意义，当你发觉你身边的同事都在重复写些垃圾的代码时候，你或许就会意识到，其实在这个世界上有很多东西，我们是可以站在巨人的肩膀上看得更远的。当你因为目光短浅而小心谨慎地维护着那些破旧的代码的时候，我们除了一天天老去别无所获。自从MySQL被甲骨文收购以后，我觉得这个世界开始缺少些有趣的东西，甲骨文和Google关于Java的官司让Google最终选择了Kotlin，所以你可以看到开源这件事情对这个世界是绝对有利的，很多人担心这些代码开源到互联网上对商业公司不利，其实我们都清楚，没有环境和生态的代码基本不会有人关心，我们是不是该重新审视下开源？</p><p>&emsp;&emsp;OK，我知道现在大家都在思考一件事情，既然开源对这个世界的进步是有利的，那么是否开源就不应该成为我们思考的问题，我们真正应该考虑的问题是，如何选择一个合适的开源软件许可证书，在商业化和开源间找到一个平衡点。对于这个问题，我想大家一定会犯选择困难症，不过没有关系啦，我想下面这张图可以帮到大家：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://image.beekka.com/blog/201105/free_software_licenses.png" alt="如何选择开源软件许可证书" title="">                </div>                <div class="image-caption">如何选择开源软件许可证书</div>            </figure><h1 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h1><p>&emsp;&emsp;或许在数日前，你还在为React专利事件而苦恼，或者考虑在Preact的基础上实现一个新的React，或者考虑转向Angular和Vue这两个框架，此时此刻Facebook宣布将React的开源协议修改为MIT，或许这算是开源社区的一次胜利，或许这算是整个专利事件的尘埃落定，或许有人继续担心Facebook搞其他事情，可是这个世界原本就是在每天都发生变化着的，对于未来我们常常是无从得知它的足迹会在哪里。人生本来就是一个人的逆旅，要想在这充满变化的世界里获得安全感，唯有努力让自己处于不败之地，技术何尝不是这样呢，想想这20年间我们经历了多少技术的变革，从来没有一门框架可以让我们一劳永逸，所以对于小公司而言，大可不必担心Facebook会因为专利问题和你产生法律上的纠纷，该用什么就用什么框架，因为没有绝对完美的框架，能结合业务场景选择合适的框架，为这个世界带来一点点微小的变化，这样子我们就足够开心啦！而对于BAT这样的互联网大厂，则应该考虑走自主研发的差异化路线，因为如果你不想受制于人，最好的方法就是让别人依赖你，而不是去努力依赖别人。作为一个伪前端工程师，我觉得不管什么时候，我们都要努力打好基础，而不是在一堆框架中疲于奔命，对热衷于搞事情和造轮子的前端技术圈来说，下一次的讨论热点会是什么，你我都未必能想到，这个时候还有什么比努力更重要的事情呢。好了，这篇文章就是这样了，希望大家能够喜欢，我们下一篇见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;各位朋友，我是Payne，大家好，欢迎大家关注我的博客，我的博客地址是&lt;a href=&quot;https://qinyuanpei.github.io&quot;&gt;https://qinyuanpei.github.io&lt;/a&gt;。最近前端技术圈因为React专利事件
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="前端" scheme="http://qinyuanpei.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://qinyuanpei.github.io/tags/React/"/>
    
      <category term="开源" scheme="http://qinyuanpei.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存技术学习系列之Lua脚本</title>
    <link href="http://qinyuanpei.github.io/posts/4197961431/"/>
    <id>http://qinyuanpei.github.io/posts/4197961431/</id>
    <published>2017-09-17T10:49:07.000Z</published>
    <updated>2018-03-01T01:38:10.350Z</updated>
    
    <content type="html"><![CDATA[<p>  各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。想起来大概有一个月没有更新博客啦。或许是因为这中间发生了太多的事情，想来人生原本就充满曲折和变数。在微信群里得知家中舅爷去世的消息，突然意识到时间早已摧毁你我的一切。那个曾经同你有千丝万缕联系的人，会在某一刻同你彻底失去联系。所以我更珍视彼此在一起的时光，因为在这个世界上每天都面临着改变。有时候工作上遇到不开心的时候，会想着一个人去一个陌生的地方，我们就在不断地相聚和离别中慢慢老去。这段时间一直在学习做饭，为此特意买了本菜谱，结果发现，最难的并不是如何去做好一道菜，而是你为了做好一道菜需要准备各种食材，就像人与人交流并没有什么困难，真正困难的地方，是你找不到一个可以一直陪你说话的人。熟悉的店面会被拆迁转让，熟悉的人事会被错过改变，上帝想把世界煮成一锅粥，可味道的调配却由我们来掌控。</p><p>  好了，所谓“如人饮水，冷暖自知”，人生奇就奇在你没有办法用三言两语去描述它。这段时间面试过两三家公司，整体上感觉自己的生活太安逸了些，虽然我现在依然住在租来的房子里，转眼间2017年接近尾声啦，可是回想起来今年年初制定的计划，在广泛阅读和提升技术上都是不及格的状态，印象中打算研究Redis和MonogoDB这两种数据库的(因为没有购买为知笔记会员导致部分笔记损坏或者丢失)，然而到现在为止我还有研究完Redis。尤其当我面试的时候，我发现好多我写在简历上的内容，都会成为某种意义上的呈堂证供，这让我更加确信好多东西需要不断地去巩固，所以尝试在实际项目上使用Moq、考虑怎么写出更好的测试方法以及时刻保持自我的不可替代性，这些都是我最近在考虑的事情，有时候发脾气是因为觉得自己在浪费生命，可越是被这种无力感笼罩的时候，就越是要对自己狠一点儿，所以在这篇博客中，让我们重新拾起对Redis的学习兴趣，今天我们来说说Redis中的Lua脚本。</p><p>  熟悉我博客的朋友一定都知道，我曾经开发过Unity3D相关的项目，而Lua脚本正是Unity3D中主流的热更新方案。关于Lua脚本相关的文章，大家可以通过下面的链接来了解，在这里我们不再讲述Lua的基础内容，本篇文章所讲述的是如何通过Redis内置的Lua解释器来执行脚本，我们为什么使用脚本语言进行开发呢，因为这样可以降低开发的难度啊。</p><ul><li><a href="https://qinyuanpei.github.io/2015/02/03/programing-with-the-lua-base.html">脚本语言编程：Lua脚本编程入门</a></li><li><a href="https://qinyuanpei.github.io:4000/2015/04/16/building-lua5-3-with-visual-studio-2012-in-windows.html">在Windows下使用Visual Studio编译Lua5.3</a></li><li><a href="http://blog.csdn.net/qinyuanpei/article/details/39826323" target="_blank" rel="noopener">Unity3D游戏开发之Lua与游戏的不解之缘(上)</a></li><li><a href="http://blog.csdn.net/qinyuanpei/article/details/39910099" target="_blank" rel="noopener">Unity3D游戏开发之Lua与游戏的不解之缘(中)</a></li><li><a href="http://blog.csdn.net/qinyuanpei/article/details/40050225" target="_blank" rel="noopener">Unity3D游戏开发之Lua与游戏的不解之缘(下)</a></li><li><a href="http://blog.csdn.net/qinyuanpei/article/details/40213439" target="_blank" rel="noopener">Unity3D游戏开发之Lua与游戏的不解之缘终结篇：UniLua热更新完全解读</a></li></ul><p>  好了，既然我们已然了解到Redis是通过内置的Lua解释器来执行脚本，所以Redis中的Lua脚本其实可以理解为Lua语法 + Redis API。为了写作这篇文章，我不得不将我的操作系统切换到Linux，因为这样我可以随时在写作过程中使用终端，我写作的一个重要特点，就是所有的内容都尽量保证有测试覆盖，我知道有许多人都不喜欢写测试，测试虽然不能保证你没有BUG，可是有了BUG以后可以直接在测试中定位问题，这就是我们为什么要重视测试的原因所在。在Redis中我们有两类命令用以处理和脚本相关的事情：</p><h1 id="Eval系列"><a href="#Eval系列" class="headerlink" title="Eval系列"></a>Eval系列</h1><p>  熟悉JavsScript的朋友应该会更熟悉这个方法，因为Eval在JavaScript是个神奇的存在，它可以执行任何合法的JavaScript代码，我和我的同事就曾经在一个项目中写过两层嵌套的Eval方法，显然这是为了实现某种奇怪的需求。那么在Redis中有EVAL和EVALSHA两个命令可以使用，这两个命令是从Redis2.6.0版本开始的，通过内置的Lua解释器来实现对脚本求值。EVAL命令的基本格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure><p>  我们可以注意到在这里EVAL命令由三部分组成，即第一个部分，表示一段Lua脚本程序，并且这段脚本不需要更不应该定义函数；第二部分，表示参数列表，指在脚本中需要用到的键，因为Redis是一个键值数据库，这些键名可以通过全局变量KEYS来访问，默认索引将从1开始，事实上我们更推荐你使用这种方式来访问键名；第三部分，表示除建键名参数以外的附加参数，和第二部分类似，这里我们可以通过全局变量ARGV来访问，这里就不再赘述啦。我们一起来看下面的例子：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL <span class="string">"return &#123;KEYS[1],KEYS[2]&#125;"</span> <span class="number">2</span> <span class="keyword">ab</span> <span class="keyword">cd</span></span><br></pre></td></tr></table></figure><p>  此时我们会返回一个由KEYS[1]和KEYS[2]组成的集合，集合中的两个元素分别是ab、cd，注意到这里有一个参数2,它表示我们这里将有两个参数，事实上Redis将从这个位置开始解析参数，所以我们必须告诉Redis参数解析到什么位置结束，因为主要参数(KEYS)和附加参数(ARGV)是从解析的角度上是无法区分的，所以我们期望的结果会是：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"ab"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"cd"</span></span><br></pre></td></tr></table></figure><p>  现在我们来增加点难度，显然你明白我在说什么，请注意我要引入附加参数(ARGV)啦！</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL  <span class="string">"return &#123;KEYS[1]..ARGV[2] ,KEYS[2]..ARGV[1] &#125;"</span> <span class="number">2</span> <span class="keyword">ab</span> <span class="keyword">cd</span> <span class="keyword">ab</span> <span class="keyword">cd</span></span><br></pre></td></tr></table></figure><p>  这里我们尝试对KEYS和ARGV进行拼接，需要说明的是Lua中连接字符串使用的是. .，所以这里将得到结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"abcd"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"cdab"</span></span><br></pre></td></tr></table></figure><p>  好了，现在大家应该理解EVAL这个命令的使用方法啦，那么对EVALSHA命令来说，顾名思义，它就是使用了SHA1验证的EVAL方法，我们注意到现在脚本都是定义在EVAL命令的第一个参数上，假如我们需要复用一个脚本，而该脚本可以为我们提供Sum这样的功能，即它可以返回一组参数的和给我们，显然参数的个数是不同的，那么这个时候我们总不能每次都重复写这个脚本吧，所以Redis会为脚本创建一个指纹，我们使用EVALSHA命令来传入一个指纹，Redis将从缓存的脚本中找到这个脚本，并结合我们的参数来调用它，这样我们就可以获得脚本执行以后的结果，关于指纹的这种说法，大家可以结合Git提交代码时的感受进行理解，除此以外，它和EVAL在使用方法上是完全一致的，所以不再举例子说明啦。</p><h1 id="Script系列"><a href="#Script系列" class="headerlink" title="Script系列"></a>Script系列</h1><p>  好了，下面我们来介绍第二类和Lua脚本相关的API，相比Eval给人云里雾里的感觉，Script系列的命令处处洋溢着规范命名的美好气息，我们通过这些命令的名字基本上就可以知道它是做什么事情的，这告诉我们平时写代码的时候如何去写出优雅的代码。我们通过下面一组命令来了解Script系列命令的具体用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 载入一个脚本到缓存中 */</span><br><span class="line">SCRIPT LOAD "return 'Hello Redis'" </span><br><span class="line">/* Redis返回该脚本的指纹信息 */</span><br><span class="line">"e509eb0869056563287758d23146eb00e0518da5"</span><br><span class="line">/* 查询脚本是否存在于缓存中 */</span><br><span class="line">SCRIPT EXISTS "e509eb0869056563287758d23146eb00e0518da5"</span><br><span class="line">/* Redis返回1表示脚本存在，反之不存在 */</span><br><span class="line">1) (integer) 1</span><br><span class="line">/* 从缓存中清空所有脚本 */</span><br><span class="line">SCRIPT FLUSH</span><br><span class="line">OK</span><br><span class="line">/* 此时脚本在缓存中是不存在的 */</span><br><span class="line">SCRIPT EXISTS "e509eb0869056563287758d23146eb00e0518da5"</span><br><span class="line">1) (integer) 0</span><br></pre></td></tr></table></figure><p>  至此，我们了解到了Redis中对Lua脚本支持的主要特性，坦白地讲，我认为Lua脚本在这里的应用极其薄弱，完全达不到我们印象中Lua脚本的强大，甚至我对Redis中的KEYS和ARGV依然有些模糊，大概越想搞明白的事情有时候就越搞不清楚。这里我没有提到的一个SCRIPT系列的命令是SCRIPT KILL，这个命令的作用是杀死当前正在运行的脚本，并且当且仅当这个脚本没有执行过任何写操作时，这个命令才会生效，所以这个命令主要用于杀死长时间运行的脚本，执行完这个命令后，执行这个脚本的客户端将从阻塞的EVAL命令中退出，并收一个错误作为返回值，所以我们可以理解为这是一个强行终止脚本执行的方法，因为我这里这个脚本非常的简单，所以它执行起来非常快，而我没有这样一个足够长的脚本去验证这个命令，所以在上面的脚本示例中我没有去验证这个命令，对此感兴趣的朋友可以自行去研究啦。</p><h1 id="Lua脚本应用"><a href="#Lua脚本应用" class="headerlink" title="Lua脚本应用"></a>Lua脚本应用</h1><p>  通过本文前面两个部分，我们基本了解了Redis中Lua脚本是如何工作的，在演示示例脚本的时候，我是直接在终端下运行redis-server和redis-cli的，并且所有的命令都是在终端下手动键入的，难道在实际的使用中我们要这样子玩Redis吗？想起来都觉得好可怕是不是？所以我们下面来通过一个具体的案例，来演示Redis怎么去和一个Lua脚本脚本进行交：</p><p>  首先，我们来定义一个简单的Lua脚本文件<strong>script01.lua</strong>，该脚本将对集合中的元素进行求和：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> length = redis.call(<span class="string">"LLEN"</span>,key)</span><br><span class="line"><span class="keyword">local</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (index &lt; length)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  sum = sum + redis.call(<span class="string">"LINDEX"</span>,key,index)</span><br><span class="line">  index = index + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>  现在我们在终端中执行这个脚本，为了方便起见，我们这里将其放在redis-3.2.8目录下的scripts目录。我们首先在Redis中准备些数据来做好准备，在终端中执行命令：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LPUSH data <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line">src/redis-cli --eval ~/文档/redis<span class="number">-3.2</span><span class="number">.8</span>/scripts/script01.lua data</span><br><span class="line">(<span class="type">integer</span>) <span class="number">30</span></span><br></pre></td></tr></table></figure><p>  好了，我们下面来解释下这段脚本，我们向Redis中键名为<strong>data</strong>的集合中添加了5个元素，注意这句脚本是在执行<strong>src/redis-cli</strong>后执行的，这部分内容我们在前面讲解Redis中的数据结构的时候提到过，博主表示在写这篇文章的时候依然要去看文档，总之现在我们有一个集合，并且这个集合中有5个元素，与此同时呢，我们编写了一个Lua脚本文件<strong>script01.lua</strong>，这个脚本的作用是对集合中的元素进行求和。在这里我们注意到，我们可以通过redis.call()这个方法来调用redis中的命令，具体到这里我们使用LLEN命令获取了集合的长度，使用LINDEX命令获取了集合中的元素。我们在前面提到两个全局变量KEYS和ARGV，可以完全当作Lua脚本中的两个变量来处理，从编程角度来讲，我们可以将其直接在脚本中写死。可是考虑到Redis是一个键值数据库，所以我们很容易想到键名应该对外暴露出来，以满足复用Lua脚本的目的。这里我们直接用redis-cli来运行EVAL命令，所以我们注意到它的传参方式有点不一样，事实上KEYS和ARGV中间使用逗号隔开即可。</p><p>  所以我们可以想到一种Lua脚本自动管理的思路，即通过命令行读取指定目录下的Lua脚本文件，通过SCRIPT LOAD方法获得其在Redis中的SHA1指纹，然后我们将脚本名称或者ID和这个指纹关联起来并将其存储在Redis中，此时我们只需要传入脚本名称和参数即可返回脚本执行后的结果，这样是不是感觉非常优雅呢？虽然Redis是一个键值性数据库，它不具备传统关系型数据库的查询能力，但是现在我们有了Lua脚本以后一样可以通过脚本来定制出查询，而到此时此刻我或许才真正明白Redis中Lua脚本是一种怎样神奇的存在。我们心怀敬畏，同时对这个世界永远充满期待，因为我们从来不知道人类潜能开发的极限在哪里。我们创造了太多不可思议的事情，有时候甚至连我们自己都怀疑，为什么我们会走到今天这一步。在脚本语言里我最喜欢的编程语言是Lua和Python，如果说我喜欢Lua源于我对游戏开发的兴趣，喜欢Python源于我对编写网页爬虫的兴趣，那么我很庆幸今天我又多了一个使用Lua的原因。世上美好的事情莫过于，你喜欢一样东西，恰好有人和你一样喜欢，可惜那是很久以前的事情啦。</p><p>  我们现在可以了解到，Redis提供了一种机制可以让Lua脚本同Redis进行交互。可是事实上Redis和Lua在数据结构定义上存在一定差异。所以，下面我们来了解下这两种数据结构是如何进行转换的，了解完这些我认为这篇文章就可以结束啦，因为现在接近1点钟啦而明天还要上班。在Lua脚本中调用call()或者pcall()方法来执行Redis命令时，Redis命令执行的结构会被转换为Lua中的数据结构。同理，当Lua脚本在终端中执行时，Lua脚本的返回值会被转化为Redis的协议并经由EVAL返回给客户端。关于call()和pcall()这两个方法，一个显著的区别是前者在出错时返回的是错误信息，而后者返回的是经由Lua table包装后的结果。我们知道table在Lua语言中是一个非常强大的数据结构，显然后者对调用者更为友好些啦。通常在处理类型转换时我们有以下原则：</p><ul><li>Lua table结构中不能含有nil，否则Redis将从第一个为nil的位置返回</li><li>Lua number结构中不能区分浮点类型，默认会转换为整型并舍弃小数部分，如果需要保留小数部分请返回string类型</li><li>Lua boolean结构在Redis中会被转换为0和1的取值</li><li>Redis提供了redis.error_reply()和redis.error_status()两个辅助方法来完成Lua-&gt;Redis的转换</li></ul><p>  好了，这篇博客就是这样子啦，关于为什么使用Lua脚本这个问题，我认为可以从减少网络开销、原子性和脚本复用三个角度来考虑，尤其是第二点，因为Redis执行脚本的时候是整体的、阻塞的执行，中间不会被插入新的命令，因此它完全可以不用担心出现竞态或者事务相关的问题，可是即使这样我们还是建议编写短小精悍的Lua脚本。以上就是这篇博客的全部内容啦，感谢大家关注，欢迎在博客留言及讨论相关技术问题，谢谢大家。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://segmentfault.com/a/1190000007892988" target="_blank" rel="noopener">Xbynet - Redis与Lua及Redis-py应用Lua</a></li><li><a href="http://www.cnblogs.com/yourarebest/p/5987438.html" target="_blank" rel="noopener">一路向前走 - 【原】Redis基本操作</a></li><li><a href="http://www.cnblogs.com/dgcx/p/4967175.html" target="_blank" rel="noopener">小咚 - Redis Lua 总结</a></li><li><a href="http://www.redis.net.cn/tutorial/3516.html" target="_blank" rel="noopener">Redis中文网 - Redis 脚本</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是&lt;a href=&quot;https://qinyuanpei.github.io&quot;&gt;https://qinyuanpei.github.io&lt;/a&gt;。想起来大概有一个月没有更新博客啦。或许是因为这中间发生了
      
    
    </summary>
    
      <category term="数据存储" scheme="http://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="Redis" scheme="http://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="缓存" scheme="http://qinyuanpei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="数据库" scheme="http://qinyuanpei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>基于特性(Attribute)的实体属性验证方案设计</title>
    <link href="http://qinyuanpei.github.io/posts/3873710624/"/>
    <id>http://qinyuanpei.github.io/posts/3873710624/</id>
    <published>2017-08-21T14:25:41.000Z</published>
    <updated>2018-03-01T01:38:10.358Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;各位朋友，我是Payne，大家好，欢迎大家关注我的博客，我的博客地址是<a href="https://qinyuanpei.github.io">https://qinyuanpei.github.io</a>。在这篇文章中，我想和大家探讨下数据校验的相关问题，为什么我会对这个问题感兴趣呢？这其实是来自最近工作中相关需求场景，而这篇文章其实是我在去年就准备要写的一篇文章，这篇文章一直存放在草稿箱里没有发布出来，所以结合这段时间项目上的思考，对当初的设计方案进行了改进，所有就有了大家现在看到的这篇文章，我始终认为思考是一个持久的过程，就像我们对这个世界的理解，是会随着阅历的变化而变化的。我们知道现实通常都会很残酷，不会给我们太充裕的时间去重构。可是思考会是人生永远的功课，当你忙碌到无暇顾影自怜的时候，不妨尝试慢下来抬头看看前方的路，或许原本就是我们选择了错误的方向呢，因为有时候作出一个正确的选择，实在是要比埋头苦干要重要得多啊。</p><p>&emsp;&emsp;好啦，既然我们提到了思考，那么我们来一起看一个实际项目中的业务场景，在某自动化项目中，用户会将大量数据以某种方式组织起来，然后藉由自动化工具将这些数据批量上传到一个系统中，该系统实际上是一个由各种表单组成的Web页面，并且这些Web表单中的控件都有着严格的验证规则，当数据无法满足这些验证规则时将无法上传，因此为了提高自动化工具上传的成功率，我们必须保证用户组织的这些数据是合法的，假设我们的用户是一个仅仅会使用Office三件套的普通人，他们可以想到的最好的方式是将这些数据录入到Excel中，而Excel中的数据有效性验证依附在单元格上，一旦验证规则发生变化，我们就不得不去维护这个Excel文件，这绝对不是一个软件工程师该做的事情好吗？我们当然是需要在提交数据前做验证啦，然而我看到Excel中100多列的字段时，我瞬间就不淡定了，这么多的字段难道我们要逐个写if-else吗？不，作为一个提倡少写if-else的程序员，我怎么可能会去做这种无聊的事情呢？下面隆重推出本文的主角——Attribute。</p><h1 id="你的名字是？"><a href="#你的名字是？" class="headerlink" title="你的名字是？"></a>你的名字是？</h1><p>&emsp;&emsp;如你所见，本文的主角是Attribute，那么当它出现在你面前的时候，你是否会像《你的名字。》里的泷和三叶一样，互相问候对方一句：你的名字是？因为我们实在不知道应该叫它特性还是属性。可事实上这篇文章的标题暴露了这个问题的答案，这里我们应该叫它特性。好了，按照数学理论中的观点，任何问题都可以通过引入一个中间层来解决，现在我们有了一个新的问题，Attribute和Property到底有什么区别？虽然这两者都可以翻译为”属性”，可实际上它们表达的是两个不同层面上的概念，一般我们倾向于将Attribute理解为编程语言文法上的概念，而将Property理解为面向对象编程里的概念。</p><h2 id="Attribute-特性"><a href="#Attribute-特性" class="headerlink" title="Attribute/特性"></a>Attribute/特性</h2><p>&emsp;&emsp;我们将Attribute称为特性，那么我们在什么地方会用到特性呢？两个个非常典型的例子是超文本标记语言(HTML)和可扩展标记语言(XML)。首先这两种标记语言都是结构化、描述性的标记语言。结构化表现在节点间可通过父子或者兄弟的关系来表示结构，描述性表现在每个节点都可以附加不同的描述来丰富节点。例如下面的XML文件中，我们使用了描述性的特性来提高元素间的辨识度，即特性为元素定义了更多的额外信息，而这些额外信息并不作为元素数据结构的一部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"COOKING"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"CHILDREN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个例子中，bookstore节点由两个book节点组成，而每个book节点则由title、author、year和price四个节点组成，显然这些节点描述的是一种结构化的数据，而这些数据同时附加了相关描述性的信息，例如book节点有category信息，title节点有lang信息。在XML中最基本的一个内容单元我们称之为元素，即Element，而描述这些元素的最基本内容单元我们称之为特性。所以，这种在语言层面上进行描述而与实际抽象出的对象无关的概念就称为”特性”，人们认知和描述一个事物的方式会有所不同，所以在XML中会有这样一个历史遗留问题，我们应该使用Element还是Attribute，而产生这个问题的根源在于我们认识这个世界，是通过语言描述还是通过概念抽象。</p><p>&emsp;&emsp;如果我们了解GUI相关技术的演进过程，就会发现历史总是如此的相似。为什么微软会在XML的基础上扩展出XAML这种专门为WPF而设计的界面设计语言呢？因为历史告诉我们GUI中的大量特性都应该使用声明式的、描述式的语法来实现，从苹果的Cocoa、微软的XAML、Qt的QML、Android的XML等无一不证明了这个观点，而采用过程式的MFC、WinForm、Swing等，我们常常需要为它们编写大量的交互性的逻辑代码，今天我们会发现前端领域的声明式编程、MVVM、组件化等技术点，其实都是这种思想的无限延伸，我们可以使用jQuery去直接操作DOM，但面向过程的命令式代码一定不如声明式容易理解。虽然在面向对象编程的世界里，我们最终还是需要将这些描述性的语法结构，转化为面向对象里的类和属性，可这已然是一种进步了不是吗？</p><h2 id="Property-属性"><a href="#Property-属性" class="headerlink" title="Property/属性"></a>Property/属性</h2><p>&emsp;&emsp;我们认识这个世界的过程，恰恰折射出这两者截然不同的风格，从孩提时代理解的“天空是蓝色的”到学生时代认识到“大气是由氮气、氧气和稀有气体组成”，这种转变从本质上来看其实是因为我们认识世界的角度发生了变化。《西游降魔篇》里玄奘寻找五行山，第一次是风尘仆仆“看山是山”，第二次是由“镜花水月”启发“看山不是山”，第三次借“儿歌三百首”降伏孙悟空后“看山还是山”。面向对象编程(OOP)的一个重要思想是抽象，而抽象即是我们从描述性的语言中对事物属性进行构建的一个过程。例如现实生活中的汽车会有各种各样的数据信息：长度、宽度、高度、重量、速度等等，而与此同时汽车会有启动、刹车、减速、加速等等的行为，所以将事物的“数据”和“行为”提取出来进行抽象和模拟的过程，就是面向对象编程，我们在这个过程中可以注意到一点，所有的这一切都是针对对象而言的，所以Property是针对对象而言的。</p><p>&emsp;&emsp;这里提到的一个重要概念是抽象，什么是抽象呢？我认为它恰好和具体相对的一个概念。所谓具体，即相由心生，你看到什么就是什么，与此同时通过一组描述性的语言将其描述出来，我以为这就是具体。例如”火辣辣的太阳挂在天上”，这是具体到太阳颜色和温度的一种描述；所谓抽象，即返璞归真，我们看到的并非世间阴晴圆缺的月亮，而是这浩瀚宇宙中国一颗遥远的行星，此时此刻我们将行星具备的特点概括出来，推而光之，我以为这就是抽象，所以对我们而言，属性是事物抽象后普遍具有的一种特征，它首先要达到一种抽象的层次，其次它要能表现出事物的特性，我更喜欢将Property称之为属性，它和我们在面向对象编程中的概念是完全统一的。</p><h1 id="方案设计及其实现"><a href="#方案设计及其实现" class="headerlink" title="方案设计及其实现"></a>方案设计及其实现</h1><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ul><li>免除配置开箱即用：无需任何配置文件，直接在实体上添加Attribute即可实现验证</li><li>非侵入式验证设计：验证与否对实体结构无任何副作用，可以随时添加验证或卸载验证</li><li>扩展灵活高度复用：可以自由派生自定义特性，通过泛型来支持不同实体类型的验证</li></ul><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>&emsp;&emsp;所有校验相关的Attribute都派生自ValidationAttribute这个父类，其核心方法是Validate()方法，该方法被声明为一个虚方法，因此所有的子类都必须对这个方法进行重写，它将返回一个叫做ValidationResult的结构，这是一个非常简单的数据结构，它仅仅包含Success和Message两个属性，前者表示当前校验是否成功，后者表示验证失败时的错误信息。显然，一个实体结构中将包含若干个不同的属性，所以在对一个实体结构进行验证的时候，会通过反射遍历每一个属性上的ValidationAttribute并调用其Validate()方法，所以最终返回给调用者的应该是由一组ValidationResult组成的集合，为此我们设计了ValidationResultCollection这个类，该类实现了ICollection接口，在此基础上我们增加了一个Success属性，当集合中所有ValidationResult的Success属性为true时，该属性为true反之为false。我们将数据校验的入口类EntityValidation设计成了一个静态类，它提供了一个泛型方法Validate<t>()方法，所以对整体设计而言，它的灵活性和扩展性主要体现在：(1)通过派生自定义特性来增加验证规则；(2)通过泛型方法来支持不同类型的校验。下面给出UML类图供大家参考，最近刚刚开始学习UML，有不足之处请大家轻喷哈：</t></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20170927223615167" alt="UML类图" title="">                </div>                <div class="image-caption">UML类图</div>            </figure><h2 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h2><p>&emsp;&emsp;首先，在.NET中特性的基类是Attribute，Attribute从表现形式上来讲类似Java中的注解，可以像标签一样添加在类、属性、字段和方法上，并在运行时期间产生各种不同的效果。例如[Serializable]标签表示一个实体类可以序列化，[NonSerializable]标签则可以指定某些属性或者字段在序列化的时候被忽略。而从本质上来讲，Attribute是一个类，通常我们会将派生类以Attribute结尾，而在具体使用的时候可以省略Attribute，所以[Serializable]标签其实是对应.NET中定义的SerializableAttribute这个类。在我们定义Attribute的时候，一个需要考虑的问题是Attribute的作用范围，在.NET中定义了AttributeUsageAttribute这个类，它可以是Class、Property、Field、Method等，所以Attribute本质上是在运行时期间为元素提供附加信息的一种机制，即Attribute可以添加元数据。我们知道元数据是(MetaData)实际上是程序集(Assembly)中的一部分，显然这一切都是在编译时期间定义好的，所以Attribute的一个重要特征是在运行时期间只读(Readonly)。Attribute必须依附在指定目标上，当当前目标与AttributeUsage定义不符时，将无法通过编译。Attribute的实例化依赖于目标实例的实例化，无法直接通过new完成实例化。通常我们需要配合反射来使用Attribute，在运行时期间做些有意义的事情，例如ORM中实体字段与数据库字段的绑定、Unity中配合AOP使用的ExceptionHnadler等等，都是非常典型的Attribute的应用。</p><p>&emsp;&emsp;了解了Attribute是什么东西，接下来我们要考虑的就是如何访问Attribute，在.NET中主要有两种方式来获取Attribute，即通过Attribute类提供的静态方法获取Attribute和通过Attribute依附的对象实例的元数据来获取Attribute。下面我们来看一段简单的代码实例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static T GetAttribute&lt;T&gt;(<span class="keyword">this</span> PropertyInfo propertyInfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> attrs = propertyInfo.GetCustomAttributes(typeof(T), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span>(attrs == <span class="literal">null</span> || attrs.Length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> atts[<span class="number">0</span>] <span class="keyword">as</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这段代码展示了如何通过反射访问附加在属性上的Attribute，事实上除了PropertyInfo以外，它还可以从任何支持附加Attribute的元素，例如MethodInfo、FieldInfo、ConstructorInfo等。Attribute类提供了类似的静态方法，第一个参数可以是这些元素中的任何一个，第二个参数和第三个参数和这里的示例代码一致，分别是返回的Attribute的类型，以及是否要搜索父类的Attribute，它的返回值类型为Attribute[]。在这个方案中，我们通过下面的方式来对实体属性进行验证：<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static ValidationResultCollection Validate&lt;T&gt;(T entity)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> type = entity.GetType();</span><br><span class="line">  <span class="keyword">var</span> properties = type.GetProperties();</span><br><span class="line">  <span class="keyword">var</span> results = <span class="keyword">new</span> ValidationResultsCollection();</span><br><span class="line">  foreach(<span class="keyword">var</span> <span class="keyword">property</span><span class="string"> in properties)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> propertyValue = <span class="keyword">property</span><span class="string">.GetValue(entity</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">var</span> validationAttributes = <span class="keyword">property</span><span class="string">.GetCustomAttributes(typeof(ValudationAttribute)</span>,fasle);</span><br><span class="line">    <span class="keyword">if</span>(propertyValue == <span class="literal">null</span> &amp;&amp; (validationAttributes == <span class="literal">null</span> || valudationAttributs.Length &lt;= <span class="number">0</span>)) <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//优先验证RequiredAttribute</span></span><br><span class="line">    <span class="keyword">var</span> requiredAttributes = <span class="keyword">property</span><span class="string">.GetCustomAttributes(typeof(RequiredAttribute)</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(requiredAttributes.Length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> requiredResult = (requiredAttributes[<span class="number">0</span>] <span class="keyword">as</span> ValidationAttribute).Validate(propertyValue);</span><br><span class="line">      results.Add(requiredResult);</span><br><span class="line">      <span class="keyword">if</span>(propertyValue == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其次验证ValidationAttribute</span></span><br><span class="line">    foreach(<span class="keyword">var</span> validationAttribute <span class="keyword">in</span> validationAttributes)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(propertyValue != <span class="literal">null</span> &amp;&amp; !validationAttribute.GetType().Equals(<span class="keyword">typeof</span>(RequiredAttribute)))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> validationResult = (validateAttribute <span class="keyword">as</span> ValidationAttribute).Validate(propertyValue);</span><br><span class="line">        results.Add(validationResult);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在这里我们注意到在对ValidationAttribute进行处理的时候，优先验证了RequiredAttribute，因为如果它验证失败意味着下面的验证都不需要了，所以当一个Property上附加了RequiredAttribute并且它的值为null的时候，我们将不会进行下面的验证，这是在设计过程中发现ValidationAttribute的优先级不同而做出的一个简单地调整。关于ValidationAttribute，我们提到这是所有自定义特性的基类，实际在使用中我们会有各种各样的派生类，我们这里以RegexAttribute为例来看看它具体怎么实现：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> RegexAttribute : ValidationAttribute</span><br><span class="line">&#123;</span><br><span class="line">  private string regexText;</span><br><span class="line">  private string defaultMessage = "value is required to match a Regex rule &#123;<span class="variable">$regex&#125;</span>;</span><br><span class="line">  </span><br><span class="line">  public RegexAttribute(string regexText,string message = null)</span><br><span class="line">  &#123;</span><br><span class="line">    this.regexText = regexText;</span><br><span class="line">    this.message = message == null ? defaultMessage : message;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public VelidationResult Validate(object value)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">var</span> regex = new Regex(regexText);</span><br><span class="line">  <span class="keyword">var</span> match = regex.<span class="built_in">match</span>(value.<span class="keyword">ToString</span>());</span><br><span class="line">  <span class="keyword">var</span> success = match.Success;</span><br><span class="line">  <span class="keyword">if</span>(!success)</span><br><span class="line">  &#123;</span><br><span class="line">      message = message.<span class="keyword">Replace</span>(<span class="string">"&#123;$regex&#125;"</span>,regexText);</span><br><span class="line">      <span class="keyword">return</span> new ValidationResult()&#123;Success = success, Message = message&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> new ValidationResult()&#123;Success = success&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;好了，以上就是整个校验设计中关键的技术点啦，我认为整体上没有多少难点，因为这是我在项目上造的一个简单的轮子，相比ASP.NET  MVC 中的校验要简单很多，相信大家可以根据这些内容轻松地实现一个自己的版本，虽然不主张”重复造轮子”，可博主在很多时候都是通过”造轮子”来学习的啊，哈哈。</p><h1 id="数据校验示例"><a href="#数据校验示例" class="headerlink" title="数据校验示例"></a>数据校验示例</h1><p>&emsp;&emsp;下面我们来通过一个简单的示例来了解，如何在实际项目中使用这个验证方案：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">  [<span class="meta">Required</span>]</span><br><span class="line">  [<span class="meta">Regex(<span class="meta-string">"(\d+)&#123;3&#125;-(\d+)&#123;1&#125;-(\d+)&#123;6&#125;"</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> CardNumber &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">  </span><br><span class="line">  [<span class="meta">Required</span>]</span><br><span class="line">  [<span class="meta">MaxLength(20,<span class="meta-string">"AccountNumber is required within 20 characters"</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> AccountNumber &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">  </span><br><span class="line">  [<span class="meta">Values(<span class="meta-string">"FCY,DCP,ATM"</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> TransactionType&#123;<span class="keyword">get</span>；<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里使用了三种验证规则，Required表示该字段不可以为空，Regex表示字段值要匹配指定的正则表达式，MaxLength表示字段长度不能超过指定长度，Values表示字段允许的取值范围，在实际使用中我们可以通过派生定义更多的验证规则，每一种验证规则都可以设置一个验证失败的信息，例如当AccountNumber的长度超过20时，将会返回指定的错误信息。我们可以通过下面的代码来验证Foo这个实体中的属性：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="attr">foo</span> = new Foo();</span><br><span class="line">foo.<span class="attr">CardNumber</span> = <span class="string">"234-7-4567"</span>;</span><br><span class="line">foo.<span class="attr">AccountNumber</span> = <span class="string">"12345678900"</span>;</span><br><span class="line">foo.<span class="attr">TransactionType</span> = <span class="string">"DCP"</span></span><br><span class="line"></span><br><span class="line">var <span class="attr">results</span> = EntityValidation.Validate&lt;Foo&gt;(foo);</span><br><span class="line"><span class="keyword">if</span>(!result.Success) results.ToList().Foreach(<span class="attr">r</span> =&gt; </span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine(r.Message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>#本文小结<br>&emsp;&emsp;本文首先讲述了特性和属性两者在概念上的不同，即特性是编程语言文法上的概念，而属性是面向对象编程里的概念。接下来，我们针对.NET中的Attribute的表象和具象进行了讨论，Attribute从表象上看是和Java中的注解类似，可以像使用标签一样附加在类、方法、属性或者字段等元素上，而从具象上看Attribute提供了一种在运行时期间通过元数据访问附加信息的能力，Attribute是附加在类、方法、属性或者字段等元素上的一个类，需要继承自Attribute，它的实例化必须依赖这些附加对象的实例化，并且Attribute在运行时期间是Readonly的，Attribute通常需要配合反射来使用。在具备这些基础知识以后，我们开始和大家分享这个验证方案的设计思路及其技术要点，所谓抛砖引玉，本文的目的是想让大家借鉴这种思路，努力让业务代码更干净些，因为只有我们在乎这件事情，我们才会努力去将它做好。好了，今天这篇文章就是这样啦，谢谢大家关注！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;各位朋友，我是Payne，大家好，欢迎大家关注我的博客，我的博客地址是&lt;a href=&quot;https://qinyuanpei.github.io&quot;&gt;https://qinyuanpei.github.io&lt;/a&gt;。在这篇文章中，我想和大家探讨下数据校
      
    
    </summary>
    
      <category term="编程语言" scheme="http://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C#" scheme="http://qinyuanpei.github.io/tags/C/"/>
    
      <category term="校验" scheme="http://qinyuanpei.github.io/tags/%E6%A0%A1%E9%AA%8C/"/>
    
      <category term="特性" scheme="http://qinyuanpei.github.io/tags/%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
</feed>
